diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.cache/v/cache/lastfailed pyaccumulo-new/.cache/v/cache/lastfailed
--- pyaccumulo/.cache/v/cache/lastfailed	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.cache/v/cache/lastfailed	2017-03-15 23:38:56.423403005 +0000
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.coverage pyaccumulo-new/.coverage
--- pyaccumulo/.coverage	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.coverage	2017-03-15 23:38:53.479403005 +0000
@@ -0,0 +1 @@
+!coverage.py: This is a private format, don't read it directly!{"lines":{"/home/ubuntu/accumulo/proxy/src/main/python/pyaccumulo/pyaccumulo/iterators/__init__.py":[17,18,21,22,23,24,25,26,27,29,30,31,32,33,34,35,37,38,40,41,43,44,45,46,47,48,50,51,53,55,56,57,58,60,62,64,65,66,69,70,73,74,75,76,78,79,80,81,83,84,85,86,88,89,90,91,93,94,95,96,97,98,100,102,103,106,123,124,125,126,127,128,131,132,133,134,135,136,137,138,139,140,142,143,145,146,147,148,150,151,153,156,157,158,159,160,161,163,165,167,168,169,171,172,174,175,176,178,180,181,182,183,184,188,189,190,191,192,193,194,196,197,198,199,200],"/home/ubuntu/accumulo/proxy/src/main/python/pyaccumulo/pyaccumulo/proxy/constants.py":[],"/home/ubuntu/accumulo/proxy/src/main/python/pyaccumulo/pyaccumulo/proxy/ttypes.py":[2714,3077,2762,2391,3089,3092,1569,23,24,25,1050,27,3100,2906,30,31,32,33,34,35,36,1062,39,40,41,42,43,44,1070,48,49,1074,51,52,53,1078,57,58,59,60,61,62,63,1088,2400,66,67,68,69,70,71,2120,2121,2122,75,76,77,78,79,80,2130,3155,84,85,86,87,88,89,90,91,92,93,94,95,96,99,100,101,102,103,104,105,106,107,108,109,110,1913,114,115,116,117,118,119,120,121,122,123,124,125,2610,129,130,131,132,133,134,135,136,137,138,1047,141,142,143,144,145,146,147,148,149,2585,153,154,155,156,157,158,159,160,161,165,166,167,1193,170,171,1197,175,176,180,181,182,183,1208,1209,186,1211,188,1213,1216,193,194,198,199,200,201,202,203,1058,206,207,208,209,210,3107,214,215,216,217,218,3103,222,223,224,225,226,227,2086,230,231,232,233,234,2283,238,239,240,241,242,894,246,247,248,249,250,2299,2300,253,254,255,256,2306,3115,260,1285,262,263,2313,267,268,269,270,271,272,275,276,277,278,279,2737,283,284,285,286,287,291,292,293,294,1073,297,298,299,50,303,304,305,1075,309,310,311,1336,1076,314,315,1340,1077,320,1345,2533,324,1349,1350,1353,332,1357,2380,335,336,337,338,339,340,2389,343,344,345,2800,2395,348,350,1921,1205,2403,2404,2405,1382,2408,2089,3095,2280,3140,1398,1401,899,1581,1406,1409,2911,456,389,1918,2442,1419,2114,1422,1423,1424,1425,1428,2969,3014,1433,2287,2462,2117,417,457,420,2118,2470,425,426,2094,428,2477,432,2481,2484,2485,1462,2488,441,2491,444,445,446,447,448,449,450,2123,453,454,2465,1413,2124,1482,2295,461,2510,2125,1490,1493,1925,1497,2522,2127,2298,1503,2528,3152,1506,1507,1508,1509,1512,2540,1517,2301,2544,2547,2548,187,1210,505,2554,2303,3111,2097,2596,1546,2573,2989,2302,2307,537,540,1566,261,545,546,2914,548,3121,1574,2599,552,1577,2603,557,2607,560,561,562,1212,1588,565,2614,1591,1592,569,1594,1595,1598,949,1604,2101,2636,2611,2918,598,2648,2651,458,2654,2659,2662,617,2666,620,1645,2670,625,2674,628,2677,2309,632,3158,637,640,641,642,645,2974,1672,649,1675,192,2272,1680,1683,1687,1917,1692,2717,2848,1695,1696,1697,674,3114,1701,2673,2473,1705,967,2733,3118,2736,968,690,2740,693,2743,698,701,705,459,710,713,714,715,1741,718,1485,2680,722,2851,1081,2774,1145,2777,2780,2903,2925,2785,1763,2788,1593,1766,2275,2792,1771,2796,2308,1774,2799,752,2311,1778,2803,2806,2412,1786,455,1789,1790,1791,1792,1793,1794,771,1797,774,2825,779,1804,346,782,1325,786,2837,2840,793,2119,2843,796,797,798,799,800,1328,803,804,805,806,2855,809,2859,2862,2525,2866,2869,1698,1848,1333,3040,2310,2699,2888,2142,845,807,2900,1879,1915,1882,2992,3163,1887,1890,869,1894,872,2922,3166,877,2926,880,2536,884,1911,1912,889,1914,319,892,893,1223,1919,1920,897,1922,898,901,2951,2711,2617,2722,1938,2963,2966,1348,3055,2126,925,2588,2929,2977,347,2981,2985,2988,941,2352,944,2995,1182,950,952,956,963,966,1185,1055,969,970,2551,973,974,975,976,977,3026,979,3029,3032,1908,2383,3037,2725,2932,2863,3044,1190,1056,3048,2025,3051,3052,1916,3058,2729,2591,2388,1019,2218],"/home/ubuntu/accumulo/proxy/src/main/python/pyaccumulo/pyaccumulo/proxy/AccumuloProxy.py":[16384,8194,16387,16391,8200,16396,16399,16400,16401,16404,23,24,25,26,27,28,29,32,33,41,8240,50,59,16448,16451,69,16456,8267,8270,79,8275,16468,20494,8278,87,16472,16473,8282,16476,8288,99,8292,8293,8294,8297,8302,113,121,16506,131,24282,16522,139,16525,8334,16408,16530,149,16537,158,16545,8354,16547,8357,16550,169,8362,8365,8369,8374,185,8378,8379,8382,8386,195,20514,208,16594,16597,216,8410,2767,16605,16609,227,16615,8426,16619,236,8429,16623,8434,16628,245,8441,5503,252,8445,8448,8449,260,8455,268,278,16664,8475,287,16432,12337,296,8490,8495,305,8498,8502,16695,16698,315,16702,8511,8514,8515,324,8517,8518,8519,8520,16713,16714,8523,333,16722,8531,342,352,362,16751,370,377,387,16774,8586,395,16782,16786,403,16791,16794,411,16796,16799,7106,418,16803,23746,425,432,8625,8628,9630,440,8633,8636,16829,8640,449,16459,8647,3834,8650,8651,8652,8653,8654,16848,8657,467,16853,8663,16856,16463,476,16771,16867,485,16870,16871,16872,16873,16874,16877,494,16883,502,8701,510,22658,519,16471,529,16917,8728,538,8733,8736,8740,1457,555,16941,8751,16944,8754,8755,564,8757,8758,8759,16952,8761,8762,16956,8765,574,16480,16962,23307,16965,16966,8775,584,16971,16976,594,8291,604,613,622,17008,629,636,644,17031,651,17036,17039,17043,660,17049,17052,17053,17054,17055,17058,11035,677,17063,684,8879,8882,691,8887,8890,701,8894,8900,710,8903,8904,8905,8906,8909,718,1485,8914,23331,725,12409,17112,17115,732,20602,17120,17123,740,17127,746,17133,17136,753,8946,17141,761,17146,769,1494,8966,777,8974,8977,786,8981,17177,8986,796,8989,8990,8991,8994,805,8998,17197,17200,820,17205,17208,17212,830,17219,17222,17223,17224,17225,17226,17229,9038,9041,850,17235,9046,9049,858,9053,13797,9059,868,9062,9063,9064,9065,9068,877,9073,17269,886,894,16533,905,906,907,908,17293,910,912,9105,17301,17304,921,17308,930,17315,9125,17318,8760,9128,17321,17324,9714,9136,17330,947,9140,16542,9147,957,9150,9151,9152,9153,9154,15035,967,11084,9163,16546,17367,6991,988,998,9197,17391,1008,17394,17399,17402,16554,17406,17410,1027,9221,17414,9224,17417,17420,9229,1038,9232,9236,1049,9242,9245,9246,9247,9248,9251,9734,177,9256,17451,1068,17454,17459,17462,1079,17466,17473,1090,17476,17477,17478,17479,9288,17482,17488,1109,8377,9308,1118,9311,9316,9319,9323,9328,9331,9332,9333,1142,9336,17530,9340,1155,16578,1168,9364,17557,17560,17565,17568,9755,9380,1189,9383,17578,9388,17581,17582,9391,17584,9395,1204,17592,9401,9404,9405,9406,9407,9410,1219,9415,20685,17621,1238,1247,9447,1256,17641,17644,2941,17649,17652,17656,1275,17661,9470,20693,17664,17665,17666,9475,17669,1286,11137,17673,9482,11138,21320,1297,9492,9493,9494,9495,9496,23428,9499,16602,9505,17699,1316,2950,1325,17715,1334,17723,23434,17726,17730,9539,1353,17740,17741,17742,17743,17744,17747,1364,17753,9563,9566,1375,9571,18940,12518,9574,9578,20711,9584,1394,9587,9588,9589,9590,9593,17787,1404,16618,9598,1414,16620,10413,17811,17814,1433,17819,17822,17826,1445,17832,17835,17836,17837,17838,17841,9650,9653,17846,13897,9658,9661,8437,3595,9665,1476,9671,9674,9675,9676,9677,22093,9680,15267,9685,17878,17898,1515,17901,17906,1524,17909,17913,1533,17920,17923,17924,17925,17926,17927,9737,17930,9742,17936,9745,1554,9749,1625,8452,13691,1565,9758,9759,9760,9761,9764,1576,9769,17970,20745,1597,9801,17994,1611,17997,18002,18005,18009,9821,18014,9824,18017,18018,18019,9829,18022,9832,18026,9836,1646,9844,9847,9848,9849,9850,9851,9852,9855,1664,18052,9862,11202,18068,1685,18071,18076,18079,1697,18083,18090,9901,18094,18095,18096,18097,18100,12605,18106,1728,9929,1738,1655,9932,9937,9940,9944,18140,9950,9953,9954,9955,9956,9959,8487,9964,1777,18164,18167,3028,1787,18172,18175,18179,18185,18188,18189,18190,1808,18193,18198,1816,16687,10016,10019,10024,10027,16690,10031,20787,10036,18229,10039,10040,10041,10044,10048,1857,18249,18252,18257,18260,1878,18264,10077,1887,18274,18275,18276,18277,18278,1896,18281,18287,10096,10099,10104,10107,1917,10111,10118,1928,10121,10122,10123,10124,10127,18321,1939,10133,8516,1958,18345,16711,18348,1968,16712,21888,18356,18360,1978,22175,18365,18368,18369,18370,18373,18377,1997,16717,2007,10203,23546,10206,2017,10211,10214,10218,10223,20799,10226,10227,10228,18422,10231,18427,2046,18434,18440,18443,18444,18445,18446,1709,18449,10259,18454,2075,10275,10278,10283,10286,2097,10290,18484,10297,10300,10301,10302,10303,10306,2116,10312,18507,2126,18512,23530,18515,18519,2136,18526,18529,18530,18531,18532,18535,2155,18541,2165,10360,2175,18578,2196,10391,10394,2206,10399,24351,10402,10406,2216,18602,18605,10416,10417,18610,10419,10420,18613,10423,18617,2235,10429,18623,18626,18627,18628,18629,2246,18632,23534,18637,2257,19170,10463,20807,20859,2276,18667,2287,11304,10487,1748,10490,18687,18690,19499,10502,18695,11308,18698,10509,18702,2319,10512,10513,10514,10515,18709,10518,2328,18713,18714,18715,10524,18718,2337,18724,22446,2352,3889,2360,2368,10562,16779,11263,18761,2383,2394,10589,18785,10594,18788,2405,18793,1767,18796,18800,10611,18804,10614,10615,10616,10617,2426,18811,10620,10621,18814,10624,2435,10633,2444,18833,18845,18848,16795,18853,2470,18856,18860,2479,18865,18868,18869,18872,18876,10687,2498,23627,10176,7818,2507,14072,2516,18901,18917,10726,2535,18920,10729,24362,18925,10734,2543,18928,10737,18932,10741,2551,18936,22271,10748,10751,10752,10753,10754,10757,2570,10763,2578,18965,2586,18977,18980,18985,18988,2605,10800,2613,18999,19002,19003,19004,19005,19008,19014,10824,9996,10827,2636,23547,10832,10835,2645,10839,10844,2654,10847,10848,10849,10852,10856,22184,19052,2671,23821,2681,10880,18093,2691,19076,19079,19084,19087,10896,10899,2708,10904,10907,19100,19101,2718,10911,19104,19108,10918,2728,10921,10922,10923,10924,11378,10927,23823,10933,2747,19132,458,1824,2757,19148,19151,19156,19159,19163,21915,10976,2786,19173,19174,19175,19176,19179,2796,19185,2806,11391,11004,11007,11012,2823,11019,11394,2833,11027,11030,19223,11032,11033,11034,2843,11038,11045,16860,2860,19247,11400,19250,2870,19255,19258,19262,2880,19266,19269,19270,19273,19276,11405,2897,3214,2906,19295,2915,11112,11115,19310,11120,19315,2932,19318,11127,19322,11133,19326,11136,19329,19330,11139,19333,11142,19336,11147,22339,2969,19356,2979,19368,19371,2989,19376,19379,19383,23711,19389,3006,11199,19392,19393,19394,19395,19398,11207,3017,11210,19403,11214,11220,11223,11224,11225,11226,11229,22352,11234,3047,3057,19444,3067,23722,22357,3086,19471,19474,11283,11286,19479,3097,19482,11291,11294,11298,3108,19493,19496,19497,19498,11307,19500,11309,11310,19503,11015,11313,19509,11318,3129,18271,3137,3145,11350,19547,23738,3166,3176,11370,11373,23741,3186,19571,11381,19574,11385,19579,19582,8725,19586,3203,11396,11397,19592,19595,19596,19597,19598,19601,8836,19606,3225,11434,3244,19636,3255,11454,11457,3266,11462,19656,11465,19659,11469,19664,3283,11476,19671,11480,548,11482,11485,3294,19681,19682,11491,19684,19687,3305,19693,19667,3324,3335,11479,11533,3346,11481,3363,11560,19754,11563,3373,11568,19762,11571,19678,3383,8756,11579,11582,16949,19777,11586,19779,11589,19782,19786,12855,3404,21048,19683,3414,11608,3424,11620,11623,11628,19822,11631,11635,3445,11639,11642,11645,22421,11648,21392,3461,19848,19853,19856,19860,3478,16708,19864,19867,19868,3486,19871,19874,3494,11687,11690,16967,14237,16968,11698,23795,19893,11702,3515,11710,11711,11712,19905,11715,19908,22433,19913,19916,3533,19920,19925,19928,19929,19930,21071,19933,11743,19937,3554,19486,11759,3570,11767,11770,19963,11774,3585,13229,11781,11784,11785,11786,19979,19982,11031,19987,11796,3605,19990,19994,21082,19998,20001,20002,20005,18353,20008,3626,3636,20027,3646,11844,20039,20042,20047,20050,3667,23822,20054,20059,14266,20062,20063,20064,20067,3684,11878,20071,11883,3692,19730,11886,21400,3700,11895,11898,11899,11900,11903,669,20097,11907,3717,3725,20113,20116,3733,20121,11931,20124,20128,3750,20135,20138,20139,20140,20141,20142,20145,11955,11958,20151,11962,3772,11969,11972,11973,11974,11975,11978,11984,3793,20186,3803,12922,18403,3813,20210,20213,20218,12027,20221,20225,3843,20232,20235,20236,20237,20238,19757,20241,20247,17028,12058,19769,12063,3873,12066,12070,3881,12077,12080,12081,12082,12083,12084,12087,20284,12093,3902,19765,3910,11575,22498,3918,19307,20308,20311,20316,3933,12127,20323,3942,20329,20332,20333,20334,20335,20338,19774,20343,12154,11583,3966,12159,3970,12166,3977,12172,19778,12175,12176,12177,12178,20373,12953,3992,12186,3996,4003,20393,20396,21149,20401,4018,18419,20404,17319,20408,2036,12218,20415,20418,20419,20420,20421,20424,20430,12241,17320,4053,12246,12249,12253,4062,10235,12966,12262,4071,12264,12265,12268,12273,20467,18430,4090,22527,4099,20491,4108,12302,20499,20502,20506,4127,12322,20515,20516,12325,20519,4136,12330,20523,12333,23901,4145,21415,12343,12346,12347,12348,12349,12352,12357,4166,20554,4176,4186,20574,20577,12389,20582,20585,20589,4207,20596,20599,20600,20601,4218,12412,20605,12417,20611,12420,4229,12424,12430,12433,12434,12435,12436,23918,12439,4248,17092,23919,12444,4258,4268,20654,12963,12473,4287,4296,20682,12493,12496,4305,20690,23057,12501,12504,20697,12508,20701,20704,20705,12514,20708,2086,4326,12519,12520,7548,12523,4334,3453,12528,4342,20730,20742,4361,20750,12560,20753,4372,20757,20759,20762,4383,12580,12583,20776,24151,12588,12591,20784,4402,12595,2056,20792,12601,20795,12604,4413,12606,12607,12610,20803,20806,12615,4424,20810,20813,4443,20832,12644,4454,743,20844,20847,4465,20852,20855,12664,12667,20863,12672,20866,12675,20869,4486,12679,20872,12685,4495,12688,12689,12690,12691,12694,4504,12699,20892,4849,20904,20907,4525,20912,18504,20915,20919,4536,12731,20924,20927,20928,20929,4547,20932,20936,21239,12751,12754,22606,4566,12759,12762,21242,12766,4576,20961,12773,12776,12777,4586,12779,12780,12783,20977,20980,12789,7593,20985,20988,4607,20992,20996,20999,4617,21002,21005,4627,11695,12828,21025,4646,21037,4655,21040,13794,21045,8969,4664,12858,21052,21054,12863,21057,12866,12870,12876,4685,12879,12880,12881,12882,12885,21079,4696,12890,21087,21090,4707,21094,21098,21101,21104,21107,4729,4730,21126,7617,12942,12945,21138,21141,12950,3524,21146,12957,21153,21155,21158,12967,12968,12969,11719,12972,12977,21172,21180,21183,21188,21191,24012,21195,13006,21199,21202,21205,21208,11707,13026,13029,13034,21227,13037,13041,13047,13050,13051,13052,13053,21247,13056,21250,13061,21254,4871,21258,21261,21262,813,21265,21268,23928,4899,13093,21287,21299,21302,13113,21307,13116,21310,4927,13121,21314,13124,13128,21323,21324,21325,13134,21328,13137,13138,13139,13140,21333,13143,4955,13148,22673,9022,4983,13177,3562,5005,13200,21395,13205,13208,21403,13212,21407,13219,21412,13222,13223,13224,21417,13226,21420,11762,21424,840,13235,5064,23355,21464,13273,21467,21472,21475,5092,21479,21485,21488,13297,21490,13300,21493,13305,21498,13308,13312,13318,13321,13322,13323,13324,13327,13332,21529,5148,10418,21552,21557,5176,13372,21569,11787,21572,21573,21574,21577,21581,5204,11790,13399,13402,13407,13410,21605,13414,13420,13423,13424,13425,13426,21621,21624,13434,21629,21632,21636,21642,5260,21645,21646,21647,21648,24088,21651,24089,21656,13466,5288,24092,13486,13489,13494,21688,13497,13501,13508,13511,13512,13513,13514,13515,21708,13518,21711,21716,21719,21723,5344,21731,21732,21733,21736,21740,13558,5372,21764,13582,13585,21780,13590,21783,5400,13593,21788,13597,21791,13603,13606,13607,13608,13609,21802,13612,21805,21806,21807,21808,13617,24368,5428,21818,13197,5456,13649,21856,17296,5475,13669,13672,13677,13680,13684,22761,21880,21883,13694,13695,13696,13697,13698,21891,13701,21895,13707,21901,21904,21905,21906,21907,21910,5531,13742,5559,21944,13766,13769,21964,13774,21967,13777,5587,21972,13781,21975,21979,13788,2298,13791,13792,13793,21986,21989,21990,21991,21992,21993,13803,21996,5615,21416,22002,13225,10495,5036,5643,10498,9133,13846,22040,8099,21369,3675,5671,22064,13873,22067,13876,22072,13881,22075,13884,22079,13888,5699,13893,22086,24161,13896,22089,13898,22091,22092,13901,22096,13905,11875,22102,5730,13929,24167,22136,13945,13948,5758,13953,23651,13956,13960,13964,13967,22160,18712,13970,22163,13973,9467,22168,5786,22171,9157,22181,13992,22185,22186,22187,7794,22190,21448,22195,14004,5814,14007,14012,14015,14019,14023,5833,14026,14027,14030,14033,22227,5852,7802,14052,22247,22250,22255,14064,22258,14067,22262,5880,14075,22268,14079,22272,22273,22274,14083,22277,14086,14089,22282,14092,5905,4834,22831,14117,22311,5930,14133,7817,14136,22331,14141,22334,14144,5955,14148,22342,22346,14155,14158,14159,14160,14161,14162,22355,22356,14165,22358,22361,14171,5980,22366,8110,7826,6005,14205,22398,6024,22418,14229,14232,22426,22429,14240,6049,14244,22438,21489,22441,22442,14251,14254,14255,14256,14257,22450,14260,6074,1839,22474,6099,22490,22493,14303,9478,22501,22505,6124,22512,22515,22516,22517,22518,14327,22521,14330,14335,5120,14338,11947,6149,14342,19845,14347,14350,14351,14352,14355,11950,14359,16845,10586,6174,17413,3761,22570,14383,6199,24244,14399,14402,22598,14407,22601,14410,14414,6224,22609,14419,22613,14422,14423,14424,22617,14427,22620,22621,14431,22624,22627,6249,22646,10601,14457,24255,6274,22661,14473,22666,14476,22669,14481,14484,22679,14488,22682,22683,22684,14493,6302,22687,14496,14497,14498,22692,14501,14505,6327,17439,14529,7883,11395,22729,18807,1848,14545,6355,14548,24270,14553,11123,14556,10618,14560,22753,10619,22756,14566,24273,14569,14570,14571,22764,14574,6383,22768,14579,22775,24276,22778,22779,22780,22781,22782,16085,22785,7894,22791,6408,21549,14616,7898,6436,14639,14642,14647,14650,6461,14654,4034,11672,14659,14662,14663,14664,22858,14667,22861,14671,21560,22866,22869,6486,22873,22879,22882,22883,22884,22885,14695,22888,21564,22893,6511,14711,14714,14719,14722,14726,6539,14732,22925,14735,14736,14737,14740,14745,22945,22948,6567,22953,22956,2461,22960,22967,22970,22971,22972,6589,14782,22977,22983,14805,14808,6617,14813,14816,14820,14824,24316,14827,14828,23022,14831,14834,6645,14853,23049,6667,23052,14865,14868,23064,14873,14876,23070,14880,23073,23074,23075,23076,14886,23079,14889,6698,14891,23084,14894,14899,6726,3852,23116,6737,14936,17137,23136,23139,23144,6762,1127,22973,14960,14963,22974,23158,14968,17138,23162,14971,23164,23165,14975,23168,6787,14982,14983,14986,12055,14989,6815,15008,5232,23208,15020,15023,15028,15031,6843,13429,23232,15041,23235,15044,15045,15046,23240,15049,23243,15054,23247,23254,6871,23257,23258,23259,23260,23263,23269,6890,16167,15091,6909,12778,15115,15118,24365,6928,15123,15126,15130,15134,15137,15138,6947,15141,23334,10597,15144,23339,23342,23346,6966,23351,23354,15163,23356,23359,23363,15175,15178,15183,15186,15190,24377,15194,23387,15197,15200,15203,7016,23403,23406,23411,23414,23418,15227,23425,7044,23429,23430,23431,15242,15245,23440,15250,15253,15257,15262,15265,15266,7075,15270,12238,15274,23488,15298,15314,15317,17572,15322,15325,7134,23519,15329,23522,18939,15334,23527,15337,15338,15339,15342,15346,23541,23544,23545,7162,18943,23548,23551,23557,15372,18946,7190,17583,15388,15391,15396,15399,15403,23597,7215,15409,17587,15412,15413,15414,15415,15418,20319,15423,23624,7243,23632,23174,23635,23639,15452,23645,23648,23649,23650,12517,23654,7271,23659,15472,15475,22443,15480,23060,15483,15487,7299,15492,15495,15496,15497,23691,15500,15504,5316,3951,7327,23714,23719,15530,23726,23732,23735,23736,23737,15546,7355,15549,23977,15554,15557,15561,12151,15567,15570,15571,15572,15573,7383,15576,15581,23775,7411,23798,13524,15610,23803,14890,23806,23810,24252,23161,23817,23820,12162,15630,7439,15633,23826,15638,23832,15641,15645,18992,15651,15654,15655,15656,15659,7470,15664,7475,14979,7478,7479,7480,7483,23869,7487,21728,23163,15695,23893,23896,7517,23904,15715,23908,15718,23914,15723,23917,15726,2621,23920,7537,15730,23923,7540,15736,7545,15739,15740,15741,15742,12181,7552,15745,7557,15750,7560,7561,7564,7568,23957,16282,15785,23980,23985,23988,7891,23992,7609,7612,23998,15809,24002,24003,7620,24007,7624,15817,15820,7630,15824,7633,7634,7635,7636,15830,7639,15833,15834,15835,7644,15838,15843,24044,7673,24064,15874,24067,24072,24075,7693,24079,7696,24084,7701,15894,24087,7704,15897,7708,15902,24096,15905,7715,15909,7718,7719,7720,7721,15915,7724,15918,15919,15920,15921,7730,15924,11890,24120,15929,24136,24139,24144,24147,7767,15963,4026,24158,18808,24162,24163,24164,9489,24173,7791,15986,15989,7799,15994,15997,7806,16001,23147,7812,16006,7815,7816,16009,16010,16011,7821,16014,16018,24216,23151,16044,7860,24247,16060,16063,24259,16068,16071,24266,16075,24269,7886,24271,24272,16081,21795,16084,8142,16086,16087,16090,20511,16095,7904,7907,7908,7909,7910,7913,15812,7918,16124,7950,16144,16147,24340,24343,16152,16155,24348,16159,7970,24355,16164,7973,21809,16168,16169,7978,16172,7981,24366,24367,16176,7985,24371,7992,21812,7995,7996,7997,7998,7999,8002,17718,8008,16202,12259,16218,16221,24414,16226,22090,16229,16233,12263,11179,16239,8048,16242,16243,16244,16245,24438,16248,24441,16253,24446,24449,8075,8078,19096,24001,8083,19091,8086,8090,8096,19099,8100,8101,8102,8105,16302,16305,16310,17737,16313,16317,16322,16325,16326,16327,16330,16334,8184,8162,8187,8165,16360,8170,24004,8173,8177,16376,16379,8188,8189,8190,8191],"/home/ubuntu/accumulo/proxy/src/main/python/pyaccumulo/pyaccumulo/__init__.py":[17,18,19,20,22,23,24,26,27,29,31,33,34,35,36,37,38,39,40,41,42,44,45,46,48,50,58,59,60,61,62,63,64,65,66,67,68,70,71,72,73,74,76,77,79,81,82,84,86,87,88,89,90,91,93,94,95,96,97,98,100,103,105,106,107,108,109,110,111,112,114,117,118,121,122,123,124,126,127,128,129,131,132,133,134,136,139,140,141,142,143,144,145,148,149,150,152,153,154,155,158,159,160,161,163,164,165,166,168,169,170,172,173,174,175,176,177,178,180,184,185,187,188,190,191,193,194,196,197,199,200,202,203,204,206,207,208,210,211,212,214,216,217,218,220,222,223,226,227,228,229,230,232,234,239,244,254,257,260,261,263,264,266,267,269,270,272,276,277,278,279,280,281,283,284,286,287,289,290,292,293,295,296,298,299,301,302,304,305,307,308,310,311,313,314,316,317,319,320,322,323,325,330],"/home/ubuntu/accumulo/proxy/src/main/python/pyaccumulo/pyaccumulo/proxy/__init__.py":[15]}}
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/analytics.py pyaccumulo-new/examples/analytics.py
--- pyaccumulo/examples/analytics.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/analytics.py	2017-03-15 22:31:52.126584651 +0000
@@ -57,6 +57,6 @@
 wr.close()
 
 for e in conn.scan(table):
-    print e
+    print(e)
     
 conn.close()
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/indexed_doc_iterator/ingest.py pyaccumulo-new/examples/indexed_doc_iterator/ingest.py
--- pyaccumulo/examples/indexed_doc_iterator/ingest.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/indexed_doc_iterator/ingest.py	2017-03-15 22:31:52.218584651 +0000
@@ -27,7 +27,7 @@
 NUM_SHARDS=4
 
 def usage(msg=None):
-    print "Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0]
+    print("Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0])
     sys.exit(1)
 
 def get_uuid(filePath):
@@ -60,7 +60,7 @@
 conn = Accumulo(host=settings.HOST, port=settings.PORT, user=settings.USER, password=settings.PASSWORD)
 
 if not conn.table_exists(table):
-    print "Creating table: %s"%table
+    print("Creating table: %s"%table)
     conn.create_table(table)
 
 wr = conn.create_batch_writer(table)
@@ -69,7 +69,7 @@
     for root, subFolders, files in os.walk(indir):
         for filename in files:
             filePath = os.path.join(root, filename)
-            print "indexing file %s"%filePath
+            print("indexing file %s"%filePath)
             uuid = get_uuid(filePath)
             with open( filePath, 'r' ) as f:
                 write_mutations(wr, get_shard(uuid), uuid, filePath, get_tokens(f))
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/indexed_doc_iterator/search.py pyaccumulo-new/examples/indexed_doc_iterator/search.py
--- pyaccumulo/examples/indexed_doc_iterator/search.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/indexed_doc_iterator/search.py	2017-03-15 22:31:52.250584651 +0000
@@ -27,15 +27,15 @@
 
 table = sys.argv[1]
 if not conn.table_exists(table):
-    print "Table '%s' does not exist."%table
+    print("Table '%s' does not exist."%table)
     sys.exit(1)
 
 search_terms = [term.lower() for term in sys.argv[2:] if len(term) > 3]
 
 if len(search_terms) < 2:
-    print "More than one term of length > 3 is required for this example"
+    print("More than one term of length > 3 is required for this example")
     sys.exit(1)
 
 for e in conn.batch_scan(table, iterators=[IndexedDocIterator(priority=21, terms=search_terms)]):
-    print e.val
+    print(e.val)
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/intersecting_iterator/ingest.py pyaccumulo-new/examples/intersecting_iterator/ingest.py
--- pyaccumulo/examples/intersecting_iterator/ingest.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/intersecting_iterator/ingest.py	2017-03-15 22:31:52.362584651 +0000
@@ -27,7 +27,7 @@
 NUM_SHARDS=4
 
 def usage(msg=None):
-    print "Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0]
+    print("Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0])
     sys.exit(1)
 
 def get_uuid(filePath):
@@ -63,7 +63,7 @@
 conn = Accumulo(host=settings.HOST, port=settings.PORT, user=settings.USER, password=settings.PASSWORD)
 
 if not conn.table_exists(table):
-    print "Creating table: %s"%table
+    print("Creating table: %s"%table)
     conn.create_table(table)
 
 wr = conn.create_batch_writer(table)
@@ -72,7 +72,7 @@
     for root, subFolders, files in os.walk(indir):
         for filename in files:
             filePath = os.path.join(root, filename)
-            print "indexing file %s"%filePath
+            print("indexing file %s"%filePath)
             uuid = get_uuid(filePath)
             with open( filePath, 'r' ) as f:
                 write_mutations(wr, get_shard(uuid), uuid, filePath, get_tokens(f))
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/intersecting_iterator/search.py pyaccumulo-new/examples/intersecting_iterator/search.py
--- pyaccumulo/examples/intersecting_iterator/search.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/intersecting_iterator/search.py	2017-03-15 22:31:52.258584651 +0000
@@ -27,13 +27,13 @@
 
 table = sys.argv[1]
 if not conn.table_exists(table):
-    print "Table '%s' does not exist."%table
+    print("Table '%s' does not exist."%table)
     sys.exit(1)
 
 search_terms = [term.lower() for term in sys.argv[2:] if len(term) > 3]
 
 if len(search_terms) < 2:
-    print "More than one term of length > 3 is required for this example"
+    print("More than one term of length > 3 is required for this example")
     sys.exit(1)
 
 uuids = []
@@ -42,8 +42,8 @@
 
 if len(uuids) > 0:
     for doc in conn.batch_scan(table, scanranges=[Range(srow=uuid, erow=uuid) for uuid in uuids]):
-        print doc.val
+        print(doc.val)
 else:
-    print "No results found"
+    print("No results found")
 
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/regex_search.py pyaccumulo-new/examples/regex_search.py
--- pyaccumulo/examples/regex_search.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/regex_search.py	2017-03-15 22:31:52.258584651 +0000
@@ -48,6 +48,6 @@
 regex3 = RegExFilter(priority=23, val_regex='have made', match_substring=True, name="RegExFilter3")
 
 for e in conn.batch_scan(table, cols=[["e"]], iterators=[regex1, regex2, regex3]):
-    print e
+    print(e)
 
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/simple.py pyaccumulo-new/examples/simple.py
--- pyaccumulo/examples/simple.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/simple.py	2017-03-15 22:31:52.214584651 +0000
@@ -27,7 +27,7 @@
 conn.create_table(table)
 wr = conn.create_batch_writer(table)
 
-print "Ingesting some data ..."
+print("Ingesting some data ...")
 for num in range(1, 100):
     label = '%03d'%num
     mut = Mutation('r_%s'%label)
@@ -37,12 +37,12 @@
 wr.close()
 
 
-print "Rows 001 through 003 ..."
+print("Rows 001 through 003 ...")
 for entry in conn.scan(table, scanrange=Range(srow='r_001', erow='r_003'), cols=[]):
-    print entry
+    print(entry)
 
-print "Rows 001 and 011 ..."
+print("Rows 001 and 011 ...")
 for entry in conn.batch_scan(table, scanranges=[Range(srow='r_001', erow='r_001'), Range(srow='r_011', erow='r_011')]):
-    print entry
+    print(entry)
 
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/config pyaccumulo-new/.git/config
--- pyaccumulo/.git/config	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/config	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/jt6211/pyaccumulo
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/description pyaccumulo-new/.git/description
--- pyaccumulo/.git/description	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/description	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/HEAD pyaccumulo-new/.git/HEAD
--- pyaccumulo/.git/HEAD	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/HEAD	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/applypatch-msg.sample pyaccumulo-new/.git/hooks/applypatch-msg.sample
--- pyaccumulo/.git/hooks/applypatch-msg.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/applypatch-msg.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/commit-msg.sample pyaccumulo-new/.git/hooks/commit-msg.sample
--- pyaccumulo/.git/hooks/commit-msg.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/commit-msg.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/post-update.sample pyaccumulo-new/.git/hooks/post-update.sample
--- pyaccumulo/.git/hooks/post-update.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/post-update.sample	2017-03-15 22:26:08.858584651 +0000
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/pre-applypatch.sample pyaccumulo-new/.git/hooks/pre-applypatch.sample
--- pyaccumulo/.git/hooks/pre-applypatch.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/pre-applypatch.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/pre-commit.sample pyaccumulo-new/.git/hooks/pre-commit.sample
--- pyaccumulo/.git/hooks/pre-commit.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/pre-commit.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/prepare-commit-msg.sample pyaccumulo-new/.git/hooks/prepare-commit-msg.sample
--- pyaccumulo/.git/hooks/prepare-commit-msg.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/prepare-commit-msg.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,36 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples.  The first comments out the
+# "Conflicts:" part of a merge commit.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+case "$2,$3" in
+  merge,)
+    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+
+# ,|template,)
+#   /usr/bin/perl -i.bak -pe '
+#      print "\n" . `git diff --cached --name-status -r`
+#	 if /^#/ && $first++ == 0' "$1" ;;
+
+  *) ;;
+esac
+
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/pre-push.sample pyaccumulo-new/.git/hooks/pre-push.sample
--- pyaccumulo/.git/hooks/pre-push.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/pre-push.sample	2017-03-15 22:26:08.858584651 +0000
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/pre-rebase.sample pyaccumulo-new/.git/hooks/pre-rebase.sample
--- pyaccumulo/.git/hooks/pre-rebase.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/pre-rebase.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up-to-date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/hooks/update.sample pyaccumulo-new/.git/hooks/update.sample
--- pyaccumulo/.git/hooks/update.sample	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/hooks/update.sample	2017-03-15 22:26:08.862584651 +0000
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/index pyaccumulo-new/.git/index
--- pyaccumulo/.git/index	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/index	2017-03-15 22:26:09.702584651 +0000
@@ -0,0 +1,16 @@
+DIRC      X…øÅ)£éKX…øÅ)£éK   ‘+  Å§  Ë  Ë   ^b <‰í◊¯-·ñD≠]Œ·* 
+.gitignore        X…øÅ)£éKX…øÅ)£éK   ‘,  Å§  Ë  Ë  ï=›ùl
+9^≈Ω©·÷CMü¨˝Êƒñ LICENSE   X…øÅ)£éKX…øÅ)£éK   ‘-  Å§  Ë  Ë   ˜]òÚÂM´Ä≥ﬁ.”‡ûÒx"åK MANIFEST.in       X…øÅ)£éKX…øÅ)£éK   ‘.  Å§  Ë  Ë  ôÛËàí¡,vkXÀ$ùTD…y… Makefile  X…øÅ)£éKX…øÅ)£éK   ‘/  Å§  Ë  Ë  œxC¢¸Áa[Ë0,P¶Ãnı@ˇ%† 	README.md X…øÅ)£éKX…øÅ)£éK   ‘0  Å§  Ë  Ë    Êù‚õ≤—÷CKã)ÆwZÿ¬‰åSë examples/__init__.py      X…øÅ)£éKX…øÅ)£éK   ‘1  Å§  Ë  Ë  °‰kkÏ3#Á¶>ÄÀ= ñ¨Å9 examples/analytics.py     X…øÅ)£éKX…øÅ)£éK   ‘2  Å§  Ë  Ë  	˚ÎeÀñ‰x?wµ&ÓÌOé¸ 'examples/indexed_doc_iterator/ingest.py   X…øÅ)£éKX…øÅ)£éK   ‘3  Å§  Ë  Ë  '&˜’Ypâ(nï¬Wl?›#?kæ 'examples/indexed_doc_iterator/search.py   X…øÅ)£éKX…øÅ)£éK   ‘4  Å§  Ë  Ë  
+NëË¯6™n„vkZL?ﬂ/Œs  (examples/intersecting_iterator/ingest.py  X…øÅ)£éKX…øÅ)£éK   ‘5  Å§  Ë  Ë  !éIk√Ê”9˚÷≤œ£Á¢Ï•‰– (examples/intersecting_iterator/search.py  X…øÅ)£éKX…øÅ)£éK   ‘6  Å§  Ë  Ë  äQäÁ!π≈'Í 0›ÿ+¬N{ examples/regex_search.py  X…øÅ)£éKX…øÅ)£éK   ‘7  Å§  Ë  Ë  ≠ Ω¯i’»ﬁiºû-iY]èÒI” examples/simple.py        X…øÅ)£éKX…øÅ)£éK   ‘8  Å§  Ë  Ë   è¶/kÙg¿§”mÂb´!•ÊÂTë examples/util.py  X…øÅ)£éKX…øÅ)£éK   ‘9  Å§  Ë  Ë  0´wRINƒôóH˘äæm†'*8π pyaccumulo/__init__.py    X…øÅ)£éKX…øÅ)£éK   ‘:  Å§  Ë  Ë  $CzjC];ûvÈY‡t€ƒ§–Ò=w  pyaccumulo/iterators/__init__.py  X…øÅ)£éKX…øÅ)£éK   ‘;  ÅÌ  Ë  Ë  K‘.wÅç8§vÈ·‡Tó@=¯8/ %pyaccumulo/proxy/AccumuloProxy-remote     X…øÅ)£éKX…øÅ)£éK   ‘<  Å§  Ë  Ë µ≠¸‰Ö¬‹GzéÂ‰2éa!xì" !pyaccumulo/proxy/AccumuloProxy.py X…øÅ)£éKX…øÅ)£éK   ‘=  Å§  Ë  Ë   3ÊøÿŒ§ƒ/ ≤ï"Ï˘wÌlõ∆ pyaccumulo/proxy/__init__.py      X…øÅ)£éKX…øÅ)£éK   ‘>  Å§  Ë  Ë   Ù¢62lÛåÚ
+M0∆Î.ˇÈ>ÚÁ pyaccumulo/proxy/constants.py     X…øÅ)£éKX…øÅ)£éK   ‘?  Å§  Ë  Ë €XÿD.ˇË„∞‰gõM[Ω(ì pyaccumulo/proxy/ttypes.py        X…øÅ)£éKX…øÅ)£éK   ‘@  Å§  Ë  Ë   πg_%1\˛¢ŒÓıKhΩó	 requirements.txt  X…øÅ)‡óKX…øÅ)‡óK   ‘A  Å§  Ë  Ë  AC…ÙÓƒœGˇaﬁ>qQƒ;˘ rpm-install-script.sh     X…øÅ)‡óKX…øÅ)‡óK   ‘B  Å§  Ë  Ë  f/K_ZÿÆ3≥çzïÔÂ◊1•W„∂ settings.py       X…øÅ)‡óKX…øÅ)‡óK   ‘C  Å§  Ë  Ë  Âã,Ù≈PÏ u+{mœ1Îq∏Ê setup.py  X…øÅ)‡óKX…øÅ)‡óK   ‘D  Å§  Ë  Ë    Êù‚õ≤—÷CKã)ÆwZÿ¬‰åSë tests/__init__.py X…øÅ)‡óKX…øÅ)‡óK   ‘E  Å§  Ë  Ë  KXá!îV∂‘*%Õè´´@€ãÆ¿ tests/test_core.py        X…øÅ)‡óKX…øÅ)‡óK   ‘F  Å§  Ë  Ë  q∆–4L¨~√”[w∑}í∏>b˘@ tests/test_iterator.py    X…øÅ)‡óKX…øÅ)‡óK   ‘G  Å§  Ë  Ë  CLqí.ÕY8KHh≥œ‘Èı.àGÛ 
+version.py        TREE   29 3
+$#“é–€¸ﬁk=ﬂ rløÒtests 3 0
+6eÏ !d∞¨Ü´â√i*€3ìexamples 9 2
+%]∏1ØzaìƒLéí7œAˆ¬3indexed_doc_iterator 2 0
+-†g´ÿ^x!~¥£À%ÉB‚ “êintersecting_iterator 2 0
+∫TØ¢7q~C1Æ¢™<ÌRìüBípyaccumulo 7 2
+{cvÍ≠Æ∞ñ®©›
+œ—í◊∂l& proxy 5 0
+” ∆	‹aÛ€1º“!EÚiterators 1 0
+˝áúú—Ìå}“#∑{(–kÊ©ﬂ¡…≥ã,~Waìø
+Èr¸b
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/info/exclude pyaccumulo-new/.git/info/exclude
--- pyaccumulo/.git/info/exclude	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/info/exclude	2017-03-15 22:26:08.858584651 +0000
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/logs/HEAD pyaccumulo-new/.git/logs/HEAD
--- pyaccumulo/.git/logs/HEAD	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/logs/HEAD	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 8adcf535bb82ba69c749efce785c9efc487e85de gbrener <gbrener@continuum.io> 1489616769 +0000	clone: from https://github.com/jt6211/pyaccumulo
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/logs/refs/heads/master pyaccumulo-new/.git/logs/refs/heads/master
--- pyaccumulo/.git/logs/refs/heads/master	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/logs/refs/heads/master	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 8adcf535bb82ba69c749efce785c9efc487e85de gbrener <gbrener@continuum.io> 1489616769 +0000	clone: from https://github.com/jt6211/pyaccumulo
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/logs/refs/remotes/origin/HEAD pyaccumulo-new/.git/logs/refs/remotes/origin/HEAD
--- pyaccumulo/.git/logs/refs/remotes/origin/HEAD	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/logs/refs/remotes/origin/HEAD	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 8adcf535bb82ba69c749efce785c9efc487e85de gbrener <gbrener@continuum.io> 1489616769 +0000	clone: from https://github.com/jt6211/pyaccumulo
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.idx pyaccumulo-new/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.idx
--- pyaccumulo/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.idx	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.idx	2017-03-15 22:26:09.674584651 +0000
@@ -0,0 +1,31 @@
+ˇtOc                                                                                                 "   &   '   )   *   *   +   ,   ,   .   /   /   0   1   1   3   4   6   6   7   7   7   7   8   :   ;   ;   =   =   =   >   ?   @   @   @   @   @   A   A   C   H   I   M   N   O   O   R   S   U   U   W   X   Y   Z   Z   Z   \   ]   `   a   b   b   c   d   f   g   h   i   k   k   l   l   l   l   l   l   m   n   o   p   r   t   u   v   v   v   w   x   y   {   |   }      Ä   Ä   Å   É   É   Ñ   Ñ   Ü   á   à   â   ã   å   å   é   ë   í   ì   ì   ï   ñ   ñ   ò   ò   ô   ô   ú   ù   ù   û   ü   ü   †   °   °   §   §   ¶   ¶   ©   ©   ™   ™   ´   ≠   ≠   Æ   ∞   ≤   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ≥   ¥   ¥   ¥   ∑   ∑   ∏   π   π   ∫   º   º   º   º   º   Ω   Ω   ø   ¿   ¡   ¡   ¡   ¡   ¡   ¡   ¡   ¬   ¬   ¬   ¬   √   ƒ   «   »       À   À   Ã   Õ   Õ   Œ   Œ   —   —   ”   ’   ’   ÷   ⁄   ‹   ﬁ   ‚   ‰   ‰   ‰   ‰   ‰   ‰   Â   Â   Â   Á   Ë   Ë   È   È   È   È   È   È   Í   Ì   Ì   Ô   Ò   Ú   Ú Äv£ÂÓÆÕû98]¢∞cº[FU £—üªüÉ£‹fwKô£B¯·nMP2*Wl4ç® …n®%Sª=‹7Õ∞ºg±ªŸ±—µÎeÀñ‰x?wµ&ÓÌOé¸YWó˘v’0¶zyßç#D2U∏b^[»∏ƒTƒ®g≠ cC2}¡»N∆^≤§9FúJ‚ßR:Ÿp∞Üo~Ã≠⁄Ñ/{®ÿ–xØòö⁄h2,¢@ FÉà ™˘{ππW(wLN¸V\â1›z ™ã\®î›d…kmOOeÆ÷6£¬œG=ê“˝`?≤iMl&∆+ê7±öøÿ•[≤™,1_8¶Ø˝éÕîπ†ë∆8edJgŒü∞º≤∫Xqhmc\ÏH˙Û#yÆ”ÔbQäÁ!π≈'Í 0›ÿ+¬N{ÔBSÏsÎÕÿ˝üèÙ≈?‘	…µÍ‡]≈G±}©˚qﬂ¢¯…&˙´%”øYÑ≤ËAp˜!6JÛÊï˙Ωöµ-I∞Û∆4A´mq/Ë—*ëdO◊˜àÆÆ∑-ø¶≈® @∑o∂√¥ﬁU©‡ÈÍ$ ¡wy1ÃÒ”™ìPOM’|íâ8Î¯ñ°úõŒSˇ´çÇ@[&ldˇ˝u	•ßÏ“≤Ø>ñúo8°7kêÆÕSD^Fm∂ŒKUÿıˆÆ&˜’Ypâ(nï¬Wl?›#?kæàcÑãlÓ/gHE„\7Í]vB:î]_êª7bÔKM#µyXÿD.ˇË„∞‰gõM[Ω(ìŒâ
+;í‚˛„x˜íÿW°‰Ííf$òÂCêZˇÍ7`Å&Òºwmr¥Æu·∑xˆ˘ÈíDãﬂ f⁄…â	ôãƒÕfÒ˜kÔ"Dg¥l;K)6©≠œ/⁄øQm \Íç•õˆEÈ•
+‘§Ä2hâı¸†Î—!˘[hô¶ófº–E«˚ä≠^ Ω¯i’»ﬁiºû-iY]èÒI”!éIk√Ê”9˚÷≤œ£Á¢Ï•‰–!ÍÈ∏5√«íYÜ`NP2ã‘"aŒ©7bV±ôZ Üéÿ;∞$#“é–€¸ﬁk=ﬂ rløÒ%]∏1ØzaìƒLéí7œAˆ¬3'≥ó¶Ômë‡˚ÃØhQ R“'≈"†>OÒÕ40ÁtF[K®≠Ê	n(Ω·VLê:Ø|†:“O8∫UÚG¬*∏"Ÿ5⁄TZ∆°yF,„uó=q+∫ùO”A4‰Œàä:çôº˛-eB+@T;TJÿhó’áïöõ-†g´ÿ^x!~¥£À%ÉB‚ “ê.wÅç8§vÈ·‡Tó@=¯8//K_ZÿÆ3≥çzïÔÂ◊1•W„∂/xœ[fQO%ŸØ_=≠ÛﬁÁ™mü1ÌszLöA£æ(ÕÁÕ/Às5Ïa ê,U™ÈØ3/8yÅTy6&6%¥§2€ñ+†ÿª†BxıI≠õe6eÏ !d∞¨Ü´â√i*€3ì7W~k≈ÒKM≈W4wNZZmÿ¿9k¯‚tú¸· >œ©}¸¨°rÏ9ÎUºÎYc_˝
+M¬'V¨¿Ö<∑)—≈BMVe‹it‹ÖñpC=rn
+/ÌâdRD≠$ ˘ÇÜı>¢ÊgÒÌ¶œTFZ
+Ãœﬂıá¶cC…ÙÓƒœGˇaﬁ>qQƒ;˘Eî∂ıp.\ºÉ˛Àc-î0âEVE≥‹mrKv∑j5{m°ÎØìPˇÉF›ªùÍHº∞g’y+I„}b‹F#Èx†ç/‡◊ˇ†–Z˛H˙§Å¨≈FQúÄ°kÜ#]Xofññ¯∫FYr+¡>˚˜´¸L¨'À_s§Fi¨C«€}Vè®¸,ÚGéÛGÉ0Ë®æ‹∆6Ó˝Ï‡v$>æáHFÇ∑F)Ï!É¬ Vrkzü/HxêrH£t £“≥7
+·c·0H£Ìò •+Xå“ÃrÑíƒEó'’H∆†˜UÙç*\¨hxy	N”ê:åsI:Üñ&kñ£Å]k/øhJ@b:†,ã™√h"Ê~Â◊ƒa¶'L2 ®)™Z£Á∫Õ+R3¡≈,†|Lqí.ÕY8KHh≥œ‘Èı.àGÛLÒé·´œ™h±√µy P–±Î“M¸lˇÊÆÿãLd±Xpº=˚∑ÎNPÂá˝¨˝†∑ﬂˇÌ˛˝QY•NëË¯6™n„vkZL?ﬂ/Œs PÎ4bµÇE+E)ß`ß¸√ıPèêûóüK¥w!=w≠^—ò1wÛQ€[“ÙkD6–~Á"–%lãn©TR*Âµ^lq]…$dH*”¸®ãLSÉMùË=4æÒ¯ΩCë¥ Ö∫Ó	V/qáA†.ßËe“SœÙÏy€V;ßÉπ¨?!˜Ì^Åf¿=§a ∞W≤’a^(€î‹ÃY≠p`]Î™∂æXQÍﬂ’8ñù¿m~s*°#9ﬂRXá!îV∂‘*%Õè´´@€ãÆ¿X˙PÜõa((ãì¢ucﬂ∞©U=@YïdPË]g™k:Ÿ¨ª*É∂P;Z1âÂÚ<SU5åî+jª∂q–B \ô>9ºÌ†[ÍR%Ïw&6ˇß]òÚÂM´Ä≥ﬁ.”‡ûÒx"åK^ S˜Ÿ‹EÒK∏‚ÙxÌ„D»†◊^íKÊmnKÍÏMK›s}lŒ®_ê4ıå:≤íRGß
+!„ÒºÀSõ}`k)ÿwÛ™é#U940¨¸n◊Ôa√$˘–õÂTº≈>]Ø áb <‰í◊¯-·ñD≠]Œ·*b°ÑËmt•∆~'¸;àëV˝
+dRY9ËÓÍb‡6	‰©qÏÈ‡∆jÿôM¯ÅÛãªæç-	z'`ˇgk ÆÄo≠ø€M·πZ∂	Ÿˆ}lˆıï∂XRBM˛{Uë|<3'∑•m\[À∑¬1nj_ŒÍuƒÈŒ˘°Úgn–‰îk(Ÿ◊ía±Ô”ú@äVån€Ø+tW≈Ù22°lÅ¶´Ú˚$ioñÛÀƒ §6«A'j.˜
+ZMoõ‰:-JÙ‹k∂¯Ü~Ö3}Àî=Øp∞àríqÿ˜Ît;•I˛*å¸qA0∏Y·}ÛFæÉúiRõöòtˆ‘Ô#ﬁq‹÷xn *"≠¬tu1
+	/NˆﬁÂ[–`JÏf6ˆDÃvBïYµj(ﬂ·´E5rz◊™–ˇwRINƒôóH˘äæm†'*8πwè…ŒnhNÓr-R´õyﬂxC¢¸Áa[Ë0,P¶Ãnı@ˇ%†y”AÍ˘ê//cÜÖÎ˛„XÕ?îyzjC];ûvÈY‡t€ƒ§–Ò=wz©›0¢AÿAUù’B0@#ë@•{cvÍ≠Æ∞ñ®©›
+œ—í◊∂l& }Ÿ|oòGÙÛPˇ⁄±ËÈ˝=a~kÀÌô≥t‰|@ó$º∑1Z7˛~}˜,¸ûËq1ª8äÈÿÄ	c)ıM%{‘9˝`j˝©£ÖáÇ›s¿¿EH…"◊∫æ˝KY"Ç˚ˆÄd7ùÛ†≥KU∏∞(É¬XåıÔ"-‘/uQƒÎñG0[Ñãb∑m;µhì ˛ªÅòxŸ|QÖ–AÈÉÖi@«˜—ı%Â„ç≈ÜtÂ2PxÌ≥gëgöœh®¿#cÚÜ @@!˜∆˙$˜…ÌÉ=I∆æ˛ááÓDª6pøátgÛgí`üÔ‡pâo∆dA"Íå‹4LØˇ#Ú$’Úâ§ÿj5ÒX,ÖøÎEFoΩ#’ä†|-tF`å:ÊÏˆ]f*a"äßÄ°6o;Fº><ƒçVDä‹ı5ªÇ∫i«IÔŒx\û¸H~Öﬁã,Ù≈PÏ u+{mœ1Îq∏ÊåW#º·èöú]√„À$‚éétúÈÖÿL¡kÕ4NÙNxÏ¬6GéBÿ*µ™êƒùB%¨z	∆≈úuèeS∫î*°Ü`c…nîƒ}If√ël¸y‚Zè!v·©„Æ¨ˆ˘ëÀ.l¸È
+ík¸Au4fé‘#Æéì)cﬁ“V
+uõ}
+o?#èJïGÖÜûÜÔp¢N:Ü]å(Éï}íf6üÃ€ﬁÕY=õøÅ∞,ï‡WGòûCº»≤;“©3âàKñ‹ã‘∂ó&≤ ﬂàü9ı$˙¯òÔU¥5?óF!ÃªŸﬂâ≤'ôΩ"p \Ω	˜—s?o˙ õÂJ%Oa>B§î
+S[ »\úuÈ©u7`Ô[ˇØ\A ±4û}â¸	RÉΩõ…éŒöπEUåûÄÕ¥ÔäWÊÆâ˝çÏxU’Sfû≤µŒ"Êcç∂ÊüòçÔ@í†]uHsNÈe∞f[ºá—±†††…ÑP]sÁXXÕvÕÙL-ˆ<¢62lÛåÚ
+M0∆Î.ˇÈ>ÚÁ¢cï‚6aãÌTt•qπ¬vçÊ¢»[çc^4‚Òß»¨áNÉ’:æˇ§ëÄV∫Ëº√+I{Ê¶+÷⁄‡≈¶/kÙg¿§”mÂb´!•ÊÂTëßDO˘`=–œÃ∂L[ØYÎÉí‡±4ß]«^1Â$ Ñ…rÜ) FB©8äÖj*”b´õ°ÌÀÿø™xÙêﬂœC√&qn⁄∏D¨§Í«™pc-+îP„˘Ï´3èOKÈX‹‘´¶Uk!—kJ77¯öC¶‘b≤∂´∂DZMQ›ØÆ-Øˆæà"æÌÉn¨Œ2?n€QÃ[˙_ã¡ﬂ”¥tû2¥Ø=§ÚÏµ≠Ãçh3N¬ô&Õ∫∑¿)=úãoõÄs9ä·hG⁄¸D∞∑ﬁI§õ…›Ü1Óëﬂ£ùó¸∑ˆóΩ—k≤lÅÅ«v	* €K—E∑πg_%1\˛¢ŒÓıKhΩó	∫TØ¢7q~C1Æ¢™<ÌRìüBíºæÜâ«Éë÷Z∑⁄¬ÓÍÜàaΩ®˜®’¸⁄'Æ∂∆¬Ïy‘èÍÂ∞ΩÈça˜€>ÑW˜&å˙uD¬ΩO√JD ºπ¢_5≈Ò`´Ÿêƒù¢öÎò´A! lº¶z)œD-ƒ“”®–xÇÔÓD?3Ss≈vê≈∞®ñ%(ºæÊôD
+'9:÷∆–4L¨~√”[w∑}í∏>b˘@ÕÈ/nƒW
+œàªÈª%mË)Q:	j—Ø@ˇïΩØ˛¯∏K÷ä∫>kwC€“<®<˘©˚!#l∂)ﬂç¢«[,˜” ∆	‹aÛ€1º“!EÚ”üú‚)´§Åó¡ív„èóì;”¸PpŸk√÷"f¶¡JÚ¶ßpƒõ‚‘u§êÃ94≈•Ë•‡_r2{8’Bïûˆ
+ï)_X˙K„	3G’9Ä	F˛dó4∞‘'<·†F´o÷Ë«’ÏªÑ÷2=PØ‘õïsmJÿõ®—_%B<ú˘,Ù/Ë'ıŸ≤ë¥ŸHÿﬂøæ–ºããn∏ßÏ √¯sº€·˚¿˘L0¿Œ[*“•’‚
+â·›\n5 –ÕM…Z~Ω˜zCù›pËj´ß?èÂøõ∏aS?≥è›ùl
+9^≈Ω©·÷CMü¨˝Êƒñﬂ˛ö›] ÀT”k Èqúqëﬂ*oZ'Œ∫‘"^pQ"Ãx‡®¿+W8Ω5Ñπ},DløÜG‡∂†/ÜñÆ[≥Tdå∂¸8ﬁb‚–“@vŸÊf§5Rˇ_Ù	q.V„,ı◊‹’aÒãXyN[r4nLƒÖ„®d‡ﬂ∑}éÀıaÂ>^2WZ„´JªáÆa}©‘=DKŸÉº≤„ÕKyÒ<∫‡ﬂTÄh(akja»œ7‰kkÏ3#Á¶>ÄÀ= ñ¨Å9‰‡LÙcÑ§°§ì‰ÈèÅZ1Â(P ∞^âñ›èÌ–2Syc•ÂD∞â©®ÏM∑—‚ˆC≠c≈IÊ/“V•tX∂eÀY¡LnˆòÊ3  ÿ4È€ßS®û*ŒpDÊù‚õ≤—÷CKã)ÆwZÿ¬‰åSëÊøÿŒ§ƒ/ ≤ï"Ï˘wÌlõ∆Áˇêd649∑^8Úî!wJz@IÁi>L¨»«π#a'§G\MÌÿjÌ{DΩπ2ÑUu˙ÀnÚÀï	Ã
+·£¡2KÆs≠ñ7üùET/ßÊN
+Wåà®éûmÉ+ÒÒïè•“∞µìˆﬁÙ!Úiï”DÛËàí¡,vkXÀ$ùTD…y…˘‚Ë±'∏vÏê<Ô°SÄ`f™“˙	∆µMÄÓÙ)´ëúXióËô]˙«-úF¥R’ßÊÖ≈‘¨tâ"˙ÒıÇŸ*ùŸÜÇHWlΩ»v∫Ó¸cˇB˛ÏπTÙË„8ÜÖ¸‰Ö¬‹GzéÂ‰2éa!xì"˝áúú—Ìå}“#∑{(–kÊ©ﬂ˝√û@Ÿ8¨óqé¨Ê`îT…ËBÚ˛k˝@ç!
+Û¸hÒÌÈs—Ôlﬁ#~–˚}¸Ó¸y.'⁄íí6•ñwä]◊†Un,Ó-±ö5öwKëCΩ07ƒ9˙¿Z{ˇÑj¶3FBsZÜM¡	˜˜fv‰ ¨\GëN¬¢Îûﬁ#¸√Dá!øSv°Ó‡„oMùNÜ√V2WGur>À˛Gõ!¡
+qï
+8°$[Gåj˚∂¬@mú˘∫m‡ãÑ¶˝ÚY>Ó7≥7˚≤ÏK`¡˜«°ﬂ∫ËŸ”#ˇº¯E@….f¢èí@O`dµ¢‘-$±VscÕ…∞v≥ó;≤º¢Ω≈Êˇ√≈È≥Œj"LP∫˝î«Ip|äÿÚ¬⁄’ﬁ5a5ÙV^”Erw´!-‡lÓòLﬂUw∫î8‰‡€Ωou{[F)°›µ[‘«3óÚWΩ4=≤ëÃ ÊZ.
+ÛfJÆuáv+€hÒ∏]MRü1‚À) wOlî9’)_"◊ €ó biF)çŒ2©∂Á∑_ÏF>‘[ÿh¬+˘∂ÃMÚ<QÁÏà¥àó¸\=ù«©π†,i,ÎœÃu1s&d"?‡≥õßLûOÂÔﬂÂ[€à[TR”“µŸ˙Øm%˝œßd¡AJ‰æı3≥≈GL◊Ö@¬¸$"√∆øüﬂ48ù"~·ºò	òf’Í˙ã»WZ}^¶‡wH°~^˝
+ˆùûÕ≥Än
+dqLi@â	iÓõ Ut™≥YeÁ¥N@¨øÍÍ/-2à∞ò{∏&cƒŒ}‰G—è¿ÂeıÂÌDqoåíX{˚œs˝˜Ω;Óô=”g:"»ﬂ´woMÃÍ6@»ß¢2o‹ù[å∏+;ˇ¡`≠^ÍÖ%◊ÌsiñÚ(PÉŒW„ÇEÁ∑·Ü˛˙gu§om‡ãÑ@∏^ßw xı>≠îâXr¶ãã°0≈Slox‰:"Ó"c…l}\é±Œ?ÜlÁ”πd√ßÚÌE—ô\J}ÆÊ/¨˝∂Zû¸åo≥¶ËˆÉ≠ªÏ4]Z3Ab¶Ñ^û"›Øí»?]¶Úπ∏ÆNïX•≈F£b’3ç≈π”pû4l|fÏ∂èW≥†GÕK@‰,˜€Ä⁄€√y”˝f ;a‘%%0iGF¬èO*íi!Î3ªfÈ#∑  «°Çu»©-d˚k-›.˝®c ≥ï˜ Z^xàrú	qµ˝ä'p‹˝¶EŸ¥œÚ<À}j}w˝5CÏ`⁄nv )/x&°ø"·©^Æãæ”Í5dC“~0Ó®#>˝uzmxJÀß‰óE|W&BÍÏî¸˘ˆÏLEYÔ	r˝ÕìóW˛dŒ–  ø  
+B  (í ”å Ÿ7  ß Go §3 –∆  · ¶  ≥› ê¯  Æ —w ŒÚ €" ç «Ò åz   ◊†  !Æ ¥ ÿ¨ ç8 hf Ÿ[  ¶ —Õ ª ◊Ê ïF  cô pê  B ™’  P  i« ⁄3  ¬ √b Xj  ]ƒ V†   K ◊˛  )X  © €© ÿË  uq ; –C ≈c ÿ+  * QË   R_ »⁄  'Y J qy 9–  +n Y$ ¢Ø èv îÉ ‘M ‘j «∑ J~ ç´  WO –¯  U ÷« :À T˛ ØØ ≠ ’A ŸŒ ¥Ô ◊â  Ò   …† ôI  Uœ  $V ≥F Íö hí ´ œ— £ˆ JZ  ‚  Uó ∆%  î  ∞ IΩ åZ  . √¸  N  "ˇ  *≤ ÀI  hq êú  È  ç ◊∏  #≤ —" –S bß ÖÉ  [Í ƒ‰  r4 ©ñ X± Õ ∞Ç »c ´t  $¯  ˘ ¨¶ ° n≈ ãÁ £" ®∫ ¥j  8 ñ  &/    Ok  ^’ œe ’¸ §©  Q    J …d •U «Ä  gQ ò” ≥∏ ©j  	U ≠R åß œª ’+ Î≤  É  ? ™) €E ÿà  ? ñ©  ﬂ »Ö  '˙ ƒk   Ú  ⁄ ÿÿ Ã√ ;1 Jm Ÿ}  eT ìV  / Œì  &º √¶  Ì Bæ  %v  "Q ÿ[  t≥ ñ6 i ê` ã∫ ƒπ  ë ‘¿ ¢ ≥ ‘‚  Y  +î  ó  = ≈- ±‚ ± ≤ä Ø‹ ÀÆ  É  f‹  j! V* ÷u ®é î@  ^Ã    Ë ©” ï“ C  ±å ÖV  V–  û ’m  f ØÛ ’  É  iÔ Öˆ  ë‚“àÒ/zçæVÿ$5∫WÜ¬4Áxíd-%Áf¯Ú‘∂."=7ˇê6
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.pack pyaccumulo-new/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.pack
--- pyaccumulo/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.pack	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/objects/pack/pack-91e2d288f12f7a8dbef056d82435ba5786c23410.pack	2017-03-15 22:26:09.674584651 +0000
@@ -0,0 +1,488 @@
+PACK      Úùxú≠–MNƒ0‡}Naâı'ÕO+!ƒänê&Œ¥3MR“TbnOƒÿŸüûﬂ¬µÅê¢Á=∑^‰ùüÇÛ§ßﬁ˚ –Ì¯8Ö¿Ÿf•
+÷(Ôå"§ûìj◊8H71ht(ƒ(PÍÜ˙/ﬂeLÎs*p9IÔGeziå$eïE≠Ω2{‘9xÀsÇè^ãMWx∫¥µÑ˚¸rÏTˆ.ÂB€zÎŒKùè©s9>óZÒaêZ¿	%"kóZÈüÍÿ;ï3¡v¨+˙<hØ 4Ñí#∏K¥∑«⁄Ï¥
+ÀcÒ'nìá;√/√∑ïb˚â≠KNﬂÄ	xQüxúùè]j√0ÑﬂuäΩ@√Í◊6-%êÁBÆ∞“Æ[
+äJõ€«Ì˙63|30£ãÄq∆j´âÕ,åò8Êƒ¢eŒ'í^bŒZ›®KÄ8„»ä!IºàªÿŸ3ôà¡∆‰£ﬁ+˙◊÷·t• ´t¯†º•œçnÚÓxŸ®¨á‘∂w–;Ø√Ï¨ÖtàjO∑2Ü¸Ø≠Ü‹‰∂ÆÌª‘ÀπK.?∞Ô¿ÌOæ¬Ø/ï˜;4J´ Ω∑ÆûñÌTíõxúùç1Nƒ0 ˚º¬›UÅµ≥^€BH‘˜àÕfùƒ……1Ç˚=i¯ ÌhF”™™±âU&? ¬Ëâ¶ëD≠‡Ë˝mŒ$kwÁ™[3¸$¡+Ë`’;tQRpë@¿π‰ ÈÑÙÁÁ§N„h]yåÅT¢ô≠"Ågû\«_Ì∂WÛ~„mZµö+?Ãã|~`¯6^÷'ŸÀ´±Hﬁ!&”t'-Kk˙ø∫ªjù’T-{”æUñœeõÕXyìõπ¸≠Îz@∞¯\¯8/≥lm7Mè÷ﬂ´ÊÂß˚¡∆dóxúùÃMjƒ0@·ΩO°têlEC)-sÑ∫ˆèú	dí‚®LèﬂÈ∫züU†é)•s©\™Hß•h'ÚûYba©°Pt_yËfêzü$4m~ÃqJÖ<rlò•#áÓ√πsv˘€Æ˚Ä∑≠Ω√ßÆÎœ˘˛◊◊∫ÍCk≥.v™˚ÌàIò8JÄ'ú›„ﬁ3˝7‡.◊ºÕ⁄‡CÏ €·›∆≤Õá˚íçKLõxúùÃM¬ @·=ßòh†cÙÆÅô—&˝b™∑∑^¡’Kﬁ‚kïƒD$9Í≤÷¡îÏ¢Olº`g§Û1:≤àjMïÁ^bf¥©#LÇT|Œ^B=gmO%G¥îD•W{,Æ3Uﬁ‡∆„¯ÑS⁄~ΩîëwçÓ<¥cY¶34ˆ∫áÉvZ´˝NCk¸7†dx3AÇˆYıSHHõxúùéK√ D˜ú¬heÇ!A™™Ê]6i§|*BïÎó^°´—Ã‚Õ´Eÿ¢¶Œ[/ŸaS+Ÿ9†£(-zc®WÔPd´¿NÜ‘≥’^Rå±3íiòêô|Ù∂7é)®©ØΩ¿∏qëû≤,‹¬˘ÀGZ§—xíπ^”æﬁAìv§…ö.ÌU[◊πV˘†Ffa‡=¡QÀºMêõÕ*Mäı’˛L˘ûxúùÃMj√0@·ΩN1dﬂ†—ø!îxŸd=“åZÅcU¡=~ù+dı‡-æ—E -e„ŸÊÍß‰≤ë‰0Í⁄‡®Z	ìØîY=®À:@laó„T—ñL¢πzótH&9P¿íJµQ—s¸lÊïªÏpìe˘ÖÌØ^À"á∆ﬂ“∆πl˜O@á¡!¶h‡C{≠’qÔmyPßôY⁄⁄F£]j˚ÉmÖæÌ_|RˇÇNqúxúïè¡J¿0DÔ˘äΩ+%I€¥O<˙≤ŸllînJö"˙ıÊ¢ûù”0ÃòVô¡.aÙ:N:∏ËÎàå’+&„‹:¬ŸF´¨,º°`ŸQ"ˆΩu!—dñyúzôMàìëWVxµ≠Tx*õ¿Û èÂÓﬁjzà9%.ï˝Ã4Œæ≥´á›•z∫Á÷¯ˇ§∫éà-À+ú‹Æc8>°ê“@ò#◊ÀO~[¶Ú	(î˚-Ö!>ˇ˙ù◊ŸmÿK‰*øÀÍAÓc£îxúïã;
+√0{ùb˚ÄY˝,	BHï"en∞˙9J∞dÑ|ˇË
+y0ÕoÙî *£I9A:©xö#Èd'àAg#§0^ZvPOu zü„¨⁄{AÑV…uññV 3§ùÚéê—9ﬁ≠√≥Ω+ºxt™_∏~zæ«ísjKh˚∏í⁄I±¢ÅŒ±i˜2F˙ˇ…Œ#“(uÉe+£lµıƒ~4ØD/òxúïèΩNƒ0Ñ˚<≈vW ˛˜!DEÅD√¨Ì›KÄƒ'„º=¶∏`™—Ëõë¶7fp¡Xû#í¬bÑUâ"§äÚ$ÏPàj ŸOWjºw ì—',¡z∂éçhä)ctå∂xKâUπÒlsq)Œ¢mN4ˆ≈;TR††3f±q¢£/µ¡k]vx?√K£˝?ö<óUÑÎ9◊Ì	¥3—h3ªwjhÈ∂ˆŒˇoNo‹.i‡yÅ”FﬂcÂU‡≤ˆÂHµáq˝ÿéØz˝πŸÈT†_ÚïxúùãKNƒ0D˜9EK¨	›éøB∞Eb«:v{»(±«◊'≥· ¨JØÍUo" vöââ&?iÚHßôùôÿQ≈°÷√çõî!:C,Ö√©8ãí	Õú3g5EF5”ÙÁgéN•µ%3k£íaGZ¨7—†K˙úµJ|ÙØ⁄‡ù˜Z‡≥’Ω√Ûıcø√Îe„ec›^Ä4Z;˘Äè®á≥›ñﬁÂü˜·C⁄E‡v¨+4˘>‰<?PÄ‹ÍΩ-{óry⁄¯Ã6o)IÇ•¿^7Å"?êè˚RÀ>é„/VhÏìxú•éAn√ E˜>≈†± å•™™îE∑]§√ÄQjàXmo_¢Ê]Œ{_ˇW"X<⁄0°ı:8èjBZå3Nëõf?⁄ gB“ãËnX)3(I(Õã¥ZHÈYj°¨1b$AZ .~Ï‡µT∏‘¥3ex£Rc*<ÛÈ„Éº∆”gÔ ˆr∆HiÑÜìòÑË›3˝ª®˚∏ydÚßòK%ÌΩ˜üÛäu{Ùæ…îa/A¶/GvúJﬁÅWdXKπ6œ•ùÙ›∂SépYk
+|T:jMŸ√ÒªGèúòvﬁ˚Óp€{öxúùç=N1Ñ{ü‚I‘$œˇk	!$§\¿?œ…¢uºxΩà‹ß‡4#ÕhfæﬁàÄíJÖúì“⁄jû≤«É!≥à¡iLËÿÍ]; zâ“Êƒ]Ê2Ñ°aí#ã)c≠
+Œy©ƒ_‹í» é4	-ë"°–&NÅéwZ1ø˜KmÊ∑zÖèV∑OüwsËwÛr.~^±ñg‡
+µô&ÕQ!≤ëñπw˙ÁúΩS;¨˚≤@£Øù∆¯ÅOê[-êÊú©ãﬂ∆?cß◊ìRy˛°zÖıÊc‹Àæ‘„7µm¿ıˆ±kÓöxúùãKNƒ0D˜9EK¨⁄[Bà$v\†ÌtåQ‚é√∑'≥‡¨JØ™^oÃ 8x6Z44ML YÙB⁄Iƒ‰úùåöÿô·Lçk4&‹é—($Î»r~îJkd%çâﬁ øøL9DØLR…iÇ0(Ωµ®Ÿ†í>éz†Ω¨^i[+º∑uÎ¯yÉSø¡s^®Ãß¥.O 4´ÑÓQ#Gªîﬁ˘ü˙∆-3ú˜yÜ∆_;Úù∞0µuÅﬁ ÷πÊáÖél√RÆ<A‹3\>∏15Õ˚Væ’Ã\nm‰R3dÆ‹®F©imçSü~YvúxúïéAé√ ÔºbÓë"l¿∆RÂ¥á=Ê3ìêÿ8V⁄Áá<!}Í.©§nÖh±û<âd“=zú}ò9jç¯Ÿ`TØP87p°C≈Nh≠ôHœÃÛ8í›‘›°ªaqVÖøvﬂ¸Ó˜◊#¸îêüpzπP·˝˜ÌÉú—∆.∫Gu∫•÷¯{SI˙O˘käú+CmÂ3•üXSmüæÖúÑk´ÍDN6ö"xúïëΩé‹ Ö{û‚v)≤Ax3c)ä“$E™Uî∏¿≈f«áüôı>}d7Rî*à8Áq(âŒNı˝Q„ à›Y)°éfP4H#OV89t'•Ãë≠ò(P∫”Åt °’Œji©”CèZâ^vp™˘√Z¶ò‡[ú|Á5a∏¿«ß‰>[ÔEn‚Ú	:)z%’Aú‡ΩhÉµ›≈óBˇÔdŒ?˚0¬ïRˆ1u◊  D‡j∏Ï´ö>X?˙Ú¶ÅPMiwï	‹à’LP"\àVp>Â“NˆûÓæ—¡∫°1u©s|óˇ=Û≠„€Åø ˝¨8≥ÒØä¸ò|Ü6óòÀº¡„óGêR@{—:{Â4ºCLƒ^‡äs%©]ÌÉI¥Ï†©‹àÛ=≥°˚¸J˙ª¡ËˆëΩ!6ıH0C«{.∏ÇõüÁ=˚ﬁ—ﬂïºjN‹“ı»~µ∞êxúïÀÕJ1@·}û‚ÓÖ!…‰§¥
+∫–ÓKrs”â∂âd2ÔÔºÇg˘¡ùº∂…Kcfc≥œà)&
+ìˆ\œ…«òùà\"˚ùÍ -ÖÂB“Qk2hÖNË•2J9“ú18≤∞ç•uxkKÖœ	Œ=‘x˛Ó˘òJŒ‘&lèàŸ;°úÁû¯€ıQ∆†ˇü¨6∏∑z€◊RÒæ•Ro–∑z¥éuZóù·˝ÙÒz~˘∫L•≤?ÌMJìxúïèAn1E˜9Ö˜H£&ŒDBUW]tŸê86§d“
+nœ\°˘§˜§?î˜Rˆb=&o}ò˝í=eÉêõ	Y0.Œô[Rnä∏$S)æP¢lãüÉîfk9)∏ —ôÙ;.]·≥_|M°©˝¿Ò[ÂΩTÓıÎ∏√üƒ ;ªÕlÙZ«‡ˇõFÍ£∂3¸±ﬁko”Ì	£uU¶±>Å“∫¬È\∑|'≠ôOÊX¯O”üxúùÃ=Nƒ0Ü·>ßp∑’¬¯gfl	!:*:.0q∆I¥ryù˚ì.@˜È”´ß7Uc5E≈‡†î¢‚ô ZG≈éôô&vcei∫uC@£KSd.^(™Ûà>˘‡A≤M%ìN¨ÂØƒÑú∏§√´!N¬qr>PÔ«Hnê≥/{3ﬂm}v›ÃßÓm^˜”ºı˘w~ã÷ı%Ôı›ÿ HÇπ◊[◊ﬁıˇ¬•mV”¥Ó]ÔΩI~¨€l∆&[^ÃÌ<ûΩ©‘◊*ﬂn√∫˙bõxúùêÕN√0ÑÔyä}*€‘N*ÇHúyÅç≥N¨:vdØ˚Ûˆ∏Ç;∑’Ï73“p&ÇΩ—Ú`Å“åBF=ÍI∆s0RåFî{aª3EÜ…)4N£ÍÖíŒí“é8Ìïí§©Z*em?tXyIæ≤/L>(ÂŸß
+œ<ˇúØ€B´ﬂŸ¥æ@´–F…^xΩ]SWœLˇOËﬁ˝Ö&@ÎÁÖ2]l®≈ü2∆ô
+úoÍH>Œ0S§å‹>⁄î3Y◊'¿i∫K-«•“˘∆È
+ÆFÀ>E‡¸∫Z€@ä_}¿¸`|N$¯ƒ˛¡x˚Ô‡-îuõÓÌôù∞-]£g`*\v›7 õè^ïxúùå¡NÖ0E˜|≈◊>ßZ⁄ƒ◊&Ó¸ÅigQ†Xä—ø˛ÄÀssŒ≠Eåz&¢∫ﬁJ ãƒ=ıçÈÆŒ˚†V°ƒf£"k=}6W£¡FÁC Á–«ƒÿ[åi–Ëâÿ üœjHœcfÀâRD∂˝†‹πà(a0!f–`:Ík.D{^·•‰Ω¬˝€/\Í/<éMÛ%ÂÂL:–‡n—"6Á∫Lµ ?ÛÊY (∞ÛE>9„cAK^Ä'U…wÌÁ”ËÙ5≠#ÏRèÌ≤}CÕ0≠i>X†]rzoÅVÜ6ÂO)4J˚}4pöëxúïÀ=Nƒ0@·ﬁß•EäÏ¯'éÑ%7œåwÕnÏ»8nœ^ÅW~“]–m∆P‘>$îòàÏí‹∂&„$`XF—‰’Å]ÍÄ∏°„–˙l|\(˙î%9oÿ¨.Ñúx±F≥WxékÎﬁÆ>fxÎXo¸ŸÛ+óú•Õ‘ˆ0v≥1Æ&hx“è‘C˜2Ü¸ˇTπ¸îzÅ/Á1ø0îJ˜ì¶Ω—m¨µoÈxëI˝qaM|òxúùåKNƒ0˜>EK¨3ÿq:±%ÑX#±„˛t≈qpúë∏=û`YOUØU"∞¥Dc9Hã£åF˚h}∞ÜYß¢∑"*6AÏÆ“÷ ∆EíôùÛnQìbÕÜ	=[Ôçä≥B≠Ÿk√æ±nä›◊»
+ÕLw…O®¢Z¶yfG≠dD·ŒˆU*ºª£lYÀ—‡ÂˆÄK{¿€5ª¥^B…Ø†¥’„(%•}Õ©5˙g.>®^	ˆs]°“˜I=~R∏ñ11SyŒÓËˇB§º◊rO€ÓTè‘ˇ˜»•‘‚œ£˝÷/leïxúïÀA¬ @—=ßòΩI¥ê„ ÖK/``f–j⁄*•˜∑W/_Ú[Å`	}§•x)à»Ï∞ﬁ8o»IéΩ¨ˆY}RïπAvS±ú\A°ÏÓÉµNcƒû8'T⁄⁄s©p]û3‹:∏‘4ø·¯™ÂÃc)≤t¥L'06Zµ”zOÌ:ç≠…ˇßJÃ„¸Ä&k[ÔUæ€XE˝ lÓD§öxúïå±nƒ D{≈ˆë,÷`HQî*≈ï˜∑¿b;πØÁÎCÚç¶ò—<©Ã`BBe-3"íâh≤Éˆ„≈jTQydán£ Y`û\4)jÉÕFMl„≈ZKöp≤—πÜ·éYJÖkY2‹z¯®îø‡ı≥¶˜∏¶ƒ•Â˘®ùFßp‘¢ö∫÷>W˛ˇ≥´\ÍLy˝^Û¬ªÏ∞êÖ§üPèGéΩùø3Pé0≥@†«É#¯ÓmYJÜùÂÿ˙Ì¸√‹ª¨|^9îxúïÃ=n!@·ûSLy≈œ.R•J·27`àâµ∞cKæ}|Ö¥O˙ﬁf®TM›–ñh)ñ—ÎÄv≈-¯úäY3üàY$‹'hÔ¨Õ&ë]µ÷´Gßb&¢CJ1≈-XA—}^Ü¿y\:|/%‘Ø˛+ı≥¥Zy,yÏ`\t∆96x{˝¥z’ΩÕ…ˇó™ÌáåGÎ?`πµ—ó„	ßÏCd§˚m™? BHµîxúùéKNƒ0D˜>EK¨⁄Ì_,!ƒâh€Ì!(â«◊'≥‡¨JØTO™—E@0yF]®N>zóíq÷€)'èR≥ôäxBØn‹e Ac≠Z"zkº±&¶‡ƒLï¢%ÇÂ¿m¸€óJÏ´c
+H∫f©®s‚bâ¥8	Ë4QŒaR|åœ÷·ç˜∂¡Go˚ÄÁØ;\∆^Ø+œÀ%∑ı¥â⁄ªÛàÖGtàÍl◊y˘ßÆﬁ•_n«≤@óÔCN˘A‘ﬁV}ﬁál◊ßïœÏJq)R`ﬁ†»"C†∑üÍ±Â1∑ÌG∂iÑûxúùÃAn!@—=ßZê™®ª^†Ä¡$HààGπ~∫Ë	∫˚zãØKg¥’µ»â≥l•¯çò‚^•Ì>VaálÓy…Pê`±5+	ô<{Ú©ÑM|l.ë≥!Pôêí…ßﬁÊÇÔ’*ædÆkü'|Ëı/?Ô79˙˚>èXü,o.0¡FDÛ´GWïˇLÆU*ÙU~D÷|>†ùc◊>áy%õNøïxúùèKNƒ0D˜>EK¨:˛[Bà-HÏ∏Ä„t2F;¯É4∑«YpñU’ıJ›
+ê‡aUãY¬¢–ËiùÏ¨¨qí‘l∏êöd“*v¯B©Åñä+'Z$≤D‰5'IÔÃDÅa–˜®Áaö=óà(µ(¨ﬁ˚’ôyv≥SÜ[còÔÌöº˚ö|ñ\<ù‚“NÒ∫Ì>ﬁ.!Ô/0	£ùê÷
+xDÉ»Üª«÷ËüuˆAe#8˙ÌÖæ;çÚÉÅµ‰ñ∏Æîüv_û±∑4pK1mC•∆1p‹¡ßz=Õÿ &®‘˙q-√F⁄u‡Ô„¡Ù_∞ubò xúïëÀn‹ Ü˜~ä≥œ»Ú¯n)™íM§TÍ¶O?Êt0XÄ3ö∑/û$U∑ay‡ø|ú BSK›©AI’UC÷ÁqÓ∆aj—ÕC›¥=Z)€±+6‡ımWwS3Ucå D_£j˙jB+¶·â	ïÏ±'„˝Ù∆—Ôí^Çpz¸Ùìb≠·KÈ◊tnÜ~jÍfjË° ß»”ïS¬˜ï≈´K¡´]≤[Ë!≤wÂv#·ÌÒr"vëˆÌ∏Hû$J¥›rYóÂE,¯Rì€◊97—¡ØÙ∂dπBîÅgºù(z∫Ç§pdƒ;»kÕíÖµ∑"âeÅ˙2âß{É IqLπÃŒ—‰GÛç>à≥K4eQ<€lÃˇë¸h∂8—’∞4d`∑òÌ^è}Dø·Eƒ?∂˚7Êÿœ+[KZH∂úDÂ›xJ∏)ãø‘˚ÆúxúùåKNƒ0˜>Ö%÷›˛µ#!êÿ .–é;ôåíxpq}2.¿≤JØ^´"⁄Eäêqë-πûŸfì¨%`¡`1b¥†Æ\emö AåË»tÜ<‰íDŒ&ˆÆƒpÏá˛oè}«…#òÏ∫ÉÌÉu9Åô–3ÇUº∑s©˙ù∑≤ÍØZ∂¶/78µ<èOÛ©/ÀìFK!DãÄ˙@vôZìÊÍCÍ(˙∫œ≥ÆÚΩÀﬂ=‘≤ËƒªTº<,ºˇJΩ‰¨?Àœ´Ã“¶u|;$∑RñteHûxúùèKj1D˜:EÔF?Ok òƒdìmB–µb¡X2övLn|Ç‘¶†xUP“ô¡≥FÎ9ÙëK6:áö5±ôú	fb„¥∫PÁ*Ä:ÍåG;[4zØS
+9¢wëˆ~Œl),yQtïSÎ)¸√étÂœÒn/©‰Ãm∑¥Ûå√iBÏOzHçÙ\D¯Uıö|¥€Ø,•~øèí÷ï˙⁄Z9ï #ÆWﬁÄs.KÁ÷_Hè*ÙvhπS;ı˙<^eìxúùÀÕm√0@·ª¶‡5®?Kä†Áû≥ EQç€(
+zˇ$+Ù¯>‡ÈÅZƒ∂¬ÿ∂¿Y–∆‚®:ä5ä{ÂM¨π”îõB¬Ç9€ê‹Êí≈àµÊñ§§‡≈∞5qîπ±°C/c¬7=∆Œs<>ﬂ±Ë;æ~:Ì◊ÖG?ÅıÎäﬁáuÖàÊ•}WïÓ¶ˇ›«T©†óπ7U†Õ—Åòè~\ÿ%ò'{ PˆöxúùéAnƒ E˜ú¬Ë‘Là4™∫Ó∫p¿t®íÅÁ˛Õ\°À˜•˜ı¥ã@§åﬁ ŒëÏèi.s∂Ö&B+$.ÊDÊ‰.áÇ-~ùx±3Œ©L◊ÃË◊B6‰ƒ)	~Í£u¯‚—¯Óm(‹_p”|˛Ï\∑[j˚X\DnÇ7ÙàÊZ˜™*ˇ‘Õhª@⁄ÑèÁ	Â™–á@=ÜÚ∂±÷Îq§^OÔ•n2ÃÉTûxúùÀMÉ @·=ßò‘Úk“4]w› ÃXxˇÍ∫¸^ÚZ!&;rB≠—ß^b`≈—zñîhp*Ib•L$ˆPhk`®G£ÿ•!EmXÍqÙ‘≥v˛<î÷—DìúG˚‰ØPÛÔíkÉ˚˜B◊.<ß5ÃKÛ˙ ©¨ÚV©¡√5¢8Î:∑FÓ¢Êï†.ÛÙi
+€±ã~JJpìxúùéIj1E˜:E 1ö0!Åx»&‰%©‰Ó‡êd»Ò£^¯Ÿº_¸«Ôï,∫í}:ÔEQ>
+å1íœ2Û‡P:ÀK±éÌXiÌ`ER‹H]¬xG2BÕÌË§dôå%£wÔ}⁄*|`€V¯Æ[Îp˛9‡‘xΩ.8ﬂNi[^@(´ºê"hxÊös6“eÓù˛Yg˜=cßòÛ∏ç∆ˆ¡0ØW\èkö†•:ÔΩAK˚Dèò~qŸo‘û‡a˙∫ºΩ^ÿk)brôxúùãK
+¬0 ˜9E.`…Ø/)à(ÿç‡Fº¿KÚ¢€î4ΩøÌ‹Ã¿‘Bƒ—{0¶E[#&$µ1Å'ÁíP EßÅÿåÖ¶ ;)ÑÿéTã.Iß§IbG	CÇ‘1\Î;~√%O¸YÚR˘Ò≥KSw9øFæM»„âK⁄ZgµÂaÑ`[áZÈœù≠sƒJë?˙Àıﬁ≥t‰HRõxúùç¡¬0 ˇô¬PπIÍ$Bºy≥Ä”∏PDîö˝iW‡y'ùNõî¡•àò<MB%Á3o7JœËâ3MÊ√MVÖq»»1;ÿò«,BHÿß‰=≤.9.Ñ÷Wüµ¡ç∑∫¬Ω’M·¸:†”ÆèÖÁw7÷ÂΩ#ˆ°ãpBèhvªÃ™Úgn∏)∞‘&†≤Èf~˘¶FÂìxúùéKn!D˜ú¢/ÜèAä,ØΩŒö¶±'ÚÙ¯¸¡W»≤™TıJ:3–íã´d:ßµ	ôr¬≈WÎ5ëØ&hÃ%%≠^ÿy0c∞´é.Ê@ÃK5≈§pv—y∂ûÏô—xÖá<Záé∂√OoC‡˚˜#NÚ◊˚ÜÎÛDmªÄ±¡Üd'æÙ|°¶ª≠"¸œ∫¬R∏ ¬†ææ§A?vêÉ"<‡ÿÀP{s«˚LZ{™?VCïxúùÀKn!E—9´®ÿ‚S]›HVîq∆Ÿ@èƒñ1ê˝«ﬁBÜÁJwÄ"íw5mﬁC$ÿ|î$«±∫è£†≤çﬁ¸Ë¿cëﬂÛÊΩ⁄ Æ’Â8XÏ;≥lâìZ 6
+å˛ÆÔ>ËCg–ÁËs—Âˆ¬yΩ˛’Ùz?Áﬁﬁ»	=oëNñ≠5œ⁄Æk·üª—RPhˆj}Äû{÷âi˛ ©KîôxúùéK!D˜ú¢/†Åi` 1∆≠ÆΩ@›~‚àºø£GpS…´JUj4fòcAkò$F=…$Ééì±¬å.‰ÇÌ’ã?P6!3N(ûKr&góÑúÑîMëÇ…Œ6Æπ¢˜∏÷'Íı	ÁV˚Ä›˝€ÒÖ√e°€cõÎ≤ÉΩûç5∞—Vkµ∫Àm˛≥Æ®.ê©ÛO:»˙‰∏Ó—®≠´|wMÓñxúùãMj√0F˜:≈Ï≤ä—Ô(ÇR∫Ó∫…„ƒ%äå<Ü¯ˆu⁄æ≈{>ÈÃ»/â√d]	.ªî‰mF 9c4£ˆ÷jµPÁáÄ¡q hbqŸè%÷úò¨∑Zè≈ƒì3ä6πµü¥∂|ı∂
+º}ødêó|\+Õ˜°¥˙∆°àË=úµ◊ZµŒ"¸œª™ÛµìrcXz{Ó ˚¬+LΩU8˝ñH;pßR∂∫›€W’LnVÂìxúùÀM¬ @·=ßòh†–&∆∏vÌfú¡üHi(M<æzóﬂK^o™‡8Hä8XÙ4aêê'ÀÏS4#£ûCö\45ù;à£å6Á)∞PŒöGë%Zâ…k‰î–⁄˙Ω68”Zg∏¥∫v8<ÿ˜N∑Bè◊˛ZÀúè}å¡¡Œ¢µÊ[À£w˝s7$¢k-
+˙¶≤º∂ïnj>ãíK∆ëxúùéKÉ0D˜ú¬(JHL@™™ÆªÓLbS*~"Æ‘„7\°ãYº—iÙ`œhª âbâ±b¸íX·$,	-ˆÑ’NØ
+mîV∞«°≈N6æÒ≈
+boCt—π&°¯Ù—◊v¿ÉÚ∂¬Ûÿ≤¬ı}B≠'‹«Ö¶πé€rÎZÁÜ·bº1UióIïˇúWî' »¨:≠côf)wÙ≈¿_Zˆôsı=PÎüxúùÀKj√@Ä·˝úBàôá<„Å∫k]ïÊ ÚHé‚∂LËÌõ\°ÀÔá_Wê±µ.4ô25Rê]l;Ò]ƒ@C©1€÷,¥ §ê∞ãå“˘¿íúu\rLMo=yOØø¯ÑÜvÌÁ.¥Õ¸¨Û¶pºøQÈ∑ëÜGUÊÒ.ƒ2f‡`—ZÛ™„†*ˇ‹Õæ0©0l¢˚R-ø¥Ì&y¬ÁÆﬂ_Ê}WNLüxúùãA
+¬0 Ôy≈~¿í&Ÿ¥{ºàÿd∑Z±ç§Òˇ∂_4Ã¿î,¶,5z;mâÜ&“Jÿ∏¡∂Å„öh‘á≤Ã∞	ÜQãØQLÀ°scƒé∏—^#K 
+>à¢oy¶Z“˜úñ˚◊&UŸ‰¯òh|W1M®≠∑∂s-ZÿißµZÎ4ñ"ÓäòÖaJY†$∏ıßÛµW?ùÔI°ôxúùÀM¬ @·=ß‡60–â1öÿçâ„Ü–˚JÔØ^¡Â˜íWKJí¡zC9h¿ê#h0≈gœ‰⁄îùX∞§©JÃŒê"•—∂÷S–¿.bLô5ÿÿ ónı9y¡uû‰ΩÃkï˚◊M˝·¯qx74è©MgL∞ù◊rß¨R‚[«°÷ÙÁ.∂Ö±&ñ∑˛tæˆ‚•‰G8ôxúùåK¬  ˜ú‚]¿ÊQ~%1∆µk/††òR˙º€xó3…˜î@:}àIíQ9SòÊi‘h¬hm¥:Á<;#zA_~∑⁄⁄
+œﬁ6ÜÎÁÑÅO∏ø*ïeà≠ﬁ@*´î◊ 9∏†Fá≠Ö9˝ôã≤.¥¿Ô#vQ: xúåÀn√ D˜|≈Ï+!cú»HUïU]Ê¬„Çù&`·Î˘˙íŒb4“—ú‚Ó‰nFu∞S…ªìﬁœ·<k=ëçœ>8´f¡m#¯Ú|Æ,ÿ&(yíÉ‘Ôù®‚ß,WâÔjÛ/>Ô5^¬#Ÿ?_P⁄hee4>Ü!*ïöl^_kN`⁄y«^¿ãÂ^‘Pèå#áÆﬁ⁄√ÊÄDo
+p∑Nñí±õ‹⁄øÊ&˛ \ËGQ≈	xúÀ±¬ Ä·ùß∏›Ñp*MåqrpÙÙéJõÇR|{Î?}À_¬Ãc7xCÆ˜⁄F¥ÆùëÉ±Hx4}uY—æ/Ü±¨kj¢˘	PZ©§˘{‚
+∑ÚÃpóp≠>/pökºPäëã‹ü3†4 `µ'Ñ'JyÇ∆[€ïﬂüTY¸ Ò¶,…¡xúå±¬  wæ‚•´	Å Rcú˝ { ≠Ö©±oΩÈñª2å‰`ê.êuàΩÛÉ@}4’iÇ¨ë÷iÇï¨mÅ/Ûúk.Ç‰öÆˇ©¬Ω<3<8‹™Àú«ÆòB†¬˜ÊRY’˜˚J¡AÏ0“7ÂojÎ¬óZÅî˝kEÇn.~Í¿eÑŒóU©c?ü6Ë√xúé±¬ Ewæ‚Ì&§P†41∆…¡—/(Ö¢-4î˚˜‚ùŒrNnû_h+HŒÜéqÉrñïòtv‰B	°πqΩ∑FÎYXRè¡ÊuçïTÄQI;™˛∞¿=?<(‹äIo8øäø∫Ë=f⁄ú∞~‘Lh5p8umÑ¯¯ç)¿Às¢€5∑~)Ì’rÄ5ÀSàÓ∂ƒ'Ú—:7∏Õ
+xúã±!{æb{BaåïÖ•∞¿rrz` ç˛ΩwØöô‰U?SÄ˚‡åwÒ†)M˚$—á¡YMNE£–ì)±Ò{Ñ∫,y∞ÅHn∏‡v„â\ÎΩ¿ç√•ay¿qnÈsJT˘˙9Å‘“(°Ö∞ÎK˘õÀœ®tÇ>⁄™∞D¯PÎπ(Ô≈”ñŸ,6Æ∆xúé¡Nƒ ÑÔ}äπ´∂Hbå{1∆É◊†ÙáewPìæΩ]Á¯eæ…‰·LÆÅ¥‡ﬁ2ºW≤óJöAÔI>˙ùQ;°µ≤⁄*ÆL◊÷ô‡Ú4≈÷5 ÿûÒá„«·Î¯ˆ˘√ƒ*xœßÑoÜ◊b”OÁ‚_∆Ë=e∂…œR˜Fı\
+‹Ò-›øSÄ[J°‘PËJ∂≤«ºZÁñiπÊ{‘åv≤€·K•∆újga§FeäâF+Bº-Ã[ŸÜ ∫?ÈƒHiÕxú=å¡n!E˜|≈ã¶F$iånåqaMÌ }Ã†¬õ0h‚ﬂw‹ÙÆnrÓπtπ¢ØÄFä$Z±‘j©¥≤”¢ZÖ∆ÍF£ùqZhÀÍk@îR¨¨∫$oπ‡ÕªwX‡@}Üoª‚Ú>Ø%l~cH|r÷ ïYY)•ja!¶0V0—3ÊfÁ„ˆtﬁ˝Ã JP{Á˝#=ÓO,c§É+(L0é0ºjOôŒﬂ\áÛÒ5÷2]rˆ?!DÌÃ
+xúã¡¬ DÔ|≈ﬁM–¢41∆ìè˛¡Bw+’Ç˙˜“9Ωyì…~•–@yœ≥CkΩ7à ô0hÀÉ√#r(Ã”Ë'T¢˝>!o[l¢·ZZ©§€y°˜¸Lêp+ò^p^_Á»LYˆœÙhNF;c'8®!8~cZ‡•JP[Ÿ+Á“Um;oò"SmU¸E6ßÃxúEå±Nƒ0D{≈Ùú,«±ìãÑ≈ï¸ ÚŸõƒw :J6B«◊c
+`™ß—º)◊EAË}äΩ'CmCﬁ:kŒ.Ω=w&kk\WÀN…c%ƒ≤,YîÑ	çˆ⁄Ë·á'⁄p)3„]„m|«Ûm_SG*∫:/h\Îá÷ıÆ√ì©QÍXSêÃvíc’ÎR¿E¿D	ÙıÒ€ü9Á8#Ô3±®¿	©–˛øØÓïpÏ3c)â6˛{Vﬂö˝JÄæxú”“+®LÊ“KŒ/K-JLOÂ (…ÕrÙπÙ2SRö–
+*Ω”xúÌ}is€H≤‡wˇäZElå8—vﬂ›ﬁÿXä¢mˆH§Iµ∆;1@î–@JÊ¸˙óg ®√Óô~1—é>,ä®  Ã ;/ÃczõxqõòÛtë‰UÚ‚Åo˛íîUZ‰Ê´Ó´»¸Áª∏‹õØ^Ω˙Ê‡C∑€ÌÊßó/ÔÔÔª1m”- õóoUΩ|ÅŒìã©ÈçŒL<:ŒÜ„—‘ºOÃ’tô…‡r2>ªÍ„«}Îl8ùMÜßW¯	-∫kŒíUöß[ ÆÍæhé‰DG¶∫ç≥Ã¨ì87[8È6)◊ïâÛ•Y˘íü2´¢4ª*âLôl bπ[‡«ë,Öﬂ]¶’∂LÁ;¸‹ƒïY‚ñ…“Ã˜fö,xë◊∞~YÏnnÕè¶X¡)|ØXÏ÷Iæ≠√Uî¿≈f_¶7∑[S‹ÁIi $x0›ÓMº€ﬁe˙O⁄O÷i{b{olzS∆`~C_<x $7qf¥tà]é$Ë/hÖ– ﬂïe
+¯Ç ò&o›ñEô∏LÙáåÄé4¯È._¬cãbΩ.rYIæhÓ”Ì-Ø√vÕ€¢$86ªrS «8¨ZÇ+çédï#:Jeé”?Z‹'e‰+ÅJDöÛﬂ#≥-Ã"¢„˜d˛a†4Î8èo$Ó[Ì∑XdÓo:>Püˆçim3˜)r¨rú$DûÍ6›‡J´tÿ‹$Âó>˛ˆ’ˇÓ–v†áØÌ∂’∞é4 2ïI•+¬íÛ$$,R e∞∫ß#˘ábwdé·Y¸[y‘Ò©ˇ NÓ“Â◊*çœ≤@Ú	†M+‡^ßUEO|∆óÄ»“`µ)Ï∂Ä+◊k]Á¥Mô¨í≤Ñ«È∑+¬¯G‹b],S8ZL∑J	úÊãlG®ÄKhÚbk≤tù‚Ó@«™XmÔëΩ*⁄à≤ÏÎ›£Öd˛B§˜ïﬁÏJ˙=ê%K<Ò1ûˇ
+¨–=Œ˜¸êcó—˝Xï≈~π∏çsÄZ/pE^·7ce(˙$ìW&6åZ.
+(k‘é	◊fì‚Ö*89Êpú>ÏK/8ÈKÔ
+◊·ªªNñil∂˚çÏÎ¢¸ÿ
+˜!ALr9Õ]Å4◊cÿ¿®ìc≠„%íª8Õ‚y¶˜ﬂìKJSd¿E,¨[π†“– _∂‚ç1_N	≠Òvã∫Ö0§– «pÄ‰Sºﬁ¿Œ àv`s~øŸ€lÿ˘\¶¨∏Ô8,ú%ezXºK"§:™s Ó—é9Ω¨ƒ8P¿ÁqÖƒÀÈ*.q‰~‡ñU∏ëÔ¬˝m∫∏ıÑk: nfô‹•DJ‰b@ç‹ì ÜãRÇ%ÑÃ˛mí≈PÀ%p
+a?ÜÕäå.<ñﬁ§9Ï“§yS´úZ◊?2uÙ	ˆêõÖv¥ºhç2Y«©Ωü…&.âS/tåuR&ŸÓA˛ë7nA>…„u“Q¢ß à Uº %y:“"µb')VéÍ}Â¢„[)^øˆ z˚Y ÖS]j·¿≈ö/≈—ï
+∆=ø?|‰]ä-J˝∂ŒTlWª9»jww‰û\⁄à‰x√¨P*ì∫{P[¯Ü
+Je⁄˘}û 2WÄä√∆À”¥Ω9≤g:íµXﬂ[±%\¿≤ a!ÊqF|t_‚s9ª\∞o¯HO¢O€ ]¬=®ä¨ÏÚ˜ÄL ”Œ¿§Ñ’<ïeM°j_mìuÂãp–πªU»Çt§|É…èöè≠kk˘Hè<1pÅámƒÿ∏ã]EZûv\ìº3Úö$ûSM…'EBxVÂG8JµIªbW¡Â]«ÂG}•≥é‘‰J™Ù&'Ÿ¨à4"ƒ∂r"
+´£‡;6˛]Ì5ØpÕæ∂«÷¯®…„#Â„∫∂©π`Ê	òå	Ir ⁄ﬂ«]¬*˘«¯'√m‡õ’5ºﬁıcAÙU◊ºC≥
+∑Ì€„´ee¶;VÆ¬´≠ŒåwÕ|©úÄñ4ÇäÄô¨8≤¿8ÑSÇÖ∑I∂Äe?}ŸÚ>E[#/Ú¢|'∆O¿Í)o–q*ˆq∂›ü¨ ~J¡∞ª+(»⁄\¸?‹PΩ-xÓÿ˘∏!Èú8ﬂÏÊ,`uì≈¿ËˆÄôUmEüàa·˚mæôoe1Àç[‘9…&–◊Å.c∫ˇ‘9Ü«íÕ/∏[5ë ¿ä¢éŸY=ÍÅπã›∆w	Yy
+˘—≈jÖv(Å$ÒÀˇâRî[&åïb(ãUHbFOÜ(`ÈÆÒfì°ªY‰@t¬2 .më≈)‡õøÎ∞Hã¯ÿµr3á€[Uqô“Ì\ï }‘£IR’}˛≈?Æ:‡y"ƒX$÷™ß«ÍËÅÿ√m‡≥ë'[‹#)T◊uÕpÖÙ∑æPí
+y⁄eõﬁ0ÒMåø&!'é˚±SX÷∂.ã™:!Ñ·1≈Ì'˛(õ,æØvÈèö%7¨ c
+º≥	jRÒ!G:ÅØƒ’vÎ,qˆz,•«ö,UXÜM±ê’dRgTnä:Óéâ S´äµ^Q§ûÚJ\©¡∂Ñï˘,va5Ùó,
+æÈöI‚GÜ∫¥ı:ﬁ;…VóB SµmyÙÄïG$A≥6€Åê#>Bã˛_Xç∫Õ¨¬H≤»πBÑ«ZÎ$a*Øä|"÷Ô*ª~R={w¯§;‡¥Ñ¡c»ö¬Qh˘¶ØıÒO„†1Èá∫'ÒÜ‘®Ó9˜ˆ‰¿ç3•—èBˇùÉ:%≤∏ié|¬ﬁcÂmè"Œ≤4ÆâÆ˚!#·u¬ùﬁŒe≤Ö©›Ïπ‰ Dı√y€CDx√úvåÑª#ãÀÌ¶»3&àE∑Ó∫…Ÿ8—O]§‚gπ±Ù‘5∏eA-h<&¢ìo\πuäãO“T’!“ñZñ˛‚¯!©èF„Ÿ∞?8ÇÀ˜iK¯∆k'{†…ÌÌ„ﬂ.O¥‹îfâ^ﬁRÍz∆@√xI>¶c∫§≠(îbåÛzÀàP#…¿°#DO¡´∑L;Ü[ÒJÃkdI\°;ÂGÈÂw[¡0ÇMR0cÖ—·⁄a(‡™ÍAﬁ¯¬<`2ˇ^á(ìÆúúAïy„4`s˝¢åöXé’÷Û¢\‚¥`iUª)d@Ä»ƒÇÀÂ	roiìc|f4,íú–Ÿ-{a(øöhˆËM∆ª“6»>Ñs^—B	¡ëªEkƒÊ≠⁄àóK¸{â˛éœëﬁ*
+∫`Ë)7!bÏW@ˇL‰OaxcπLÚÂn≠fk¿1*XÿˇSr÷e!XÉÄÜ÷ÀD—*ôÿ(wu˛cƒ [¥¢»yd∂R∞ûÄZ‡À#."ÁA∆ê\äVk`Â∂X.¥◊í2‚eº\Q±jÅ&r◊fEŒ‚˛Ä+‚GÁÏU¢ıpk/öÁ hd´-l≠nå%ì)ç|Ñe¨ßRÛÇ|KŒédÿWuV`’5W9h—äàñ|Çç)∫ø¥¢ó ±Òç}›äÙÇY^Î`Ë Y˙∏c=ê√¶ﬁ‹è>?«53ã¿ÙÜó`”u©ŸG~~TlÒ!õΩ!˝2/ÿ)√k{CÓ™≠⁄Å:®íe¬â ºId#∂.8@
+X¥.—¯tƒ¯{π!‰ë%üíÖ'‚IZÑî…M\r^©Ó{H.‡;ÖjÄT(=;zYê‰‹≤…ÌeÑÒíPcÛE”Ò„f÷¢¡®WRﬁaL_~òÑá˘À ¥
+±räsSÀ‰ªT≤G®–+†	™t")(˛bçÈiÑ∞v«(§∞NFjÒYΩMJ7—-*Ä1ı}◊ú•πNò¥]ôk∞?/{{	,®Û=;∞‰y£ãÂƒ Qëúã¡‰ÓW‘cÑÉu’ˇ6Ü/‚v0Æ"ˇ®75√Èë9ÌMáSEÓıpˆ~|53◊Ω…§7öS3û¯i˘Ò[”}0éŒ¿‹I9¸	££ï;IJreÈÖI›¢8i¨rjN.°ä¢≤)bô≥·Ï|÷G'√—€…pÙnp1Õ"s1òÙﬂîΩ”·˘pˆÅXËÌp6Lπ|†'k\ˆ&@∞´Ûﬁƒ\^M.«”k[ŒfòY ¯7∞iJY Ã∞W≤PÆ,6eäÊ9x‹Ö_!˛s◊ãór¥±™¿&¬„™∏N+íÏU±H≠õÃB]Ú¨çı≠MgñyÔá.¸¨(≈áŒ”xûfî<¢Ê5`˛‰[ÇÉ◊Äè2
+vå‡i{°Õdm˝êAû‹d)X_ã§ŸlwÑrm‰ÁQ~?fCc˙Y:'ÉéÄª¡xÑÕ[Ëñ[¨@®(;ﬁ~?XzÍÉ2J≤,•ç%"@§ç◊ÒM√«ßµ$¿TõsÎ^ˆ.∂úJ@Üc∫òêìEUBcÃ‡∆pu…9s‘‚VWc÷∏ÓË6wV∆Ï¯ì4bzr’è?òW®ÿY¡{SÀ˚4ÛcáA)õMåQB¥	v¯*N≥]…⁄(ŒVª‹7§[*A0ÄÃÎ„É7N*`‰C4–ÎÅ8Y√”„Â]JI“ïîo¿$hqÉ,œ7‡«ÆÈ-P' TÚ‚Œ=ß®ΩKq}ã¶{x]Î…¬”mjÖ.nãÇ£†ÈíÌsªmïê<QG∆˘"·Cl8*“oO|ó¨s,-q1Fk¶∞õbûIäÏñó(v–ÚÂTúÔã¯W©JPÎ`º/Ó—bW“"åÈ-ÏŒG-yÊeC¨Õ-i
+‚ «(Hù%x…“qY'—]§»câ	£œîÆX>„ÖÁ˚N∏YY‹,ì∏+¸X∆Àñ–y\ÆI©qm±ËÆÛÆ,]∂L"« ì¡+GgïÉ®Q3n<ﬂã±·¥G8úZc˛ﬁ„Fœl¥∞0Fg®W€ ‡Ë˜ΩÀK¯ Ø?!	)Z u/Â~È˛é@π∑π$¯3{‚ëîQÑ—5´∏5%∏·[çjDŒì_•I∂¨(∏Ï,ÙÁò•LÄ3è˛ˆ˜#+¯(2!⁄nØÃDRUº>œìÓö„≥"ˇì≠Ó®.˛ø:ÜºurS+0/Ä¿ƒ∑pàw‡©m/7ãw•⁄É<ˇd°‰‘3  '‡¡¨¬[‚§*≈ÈªÃ7¿eh±≤€EfÊFï±¶VÁâ+Y°©BR·ÉG ÆQ°Æ3üR¸Ç`„•6/ò”º´œ∏ G\.n1cÕÃ‡íâ€√üøõø‹ g-À˙w˙∫0…“ÛôBˆâ¸ÇPså_∞5óù7∏Ñ˙#(X}I¯\Õ¯47îD£Â(k‚Áısäñ≈A»N9ﬁ*ª?Vrz∂˚h:8êÈëßXËál©9√eºêZ≥¬	ì˛Y‡_h~´·Mhõ&I Ç29ô5¿3p¥¸f&®Öº^Ÿ'—gØWÕs[ΩË]ˆ˙Ô¶◊Ô_]\ùèÕÙÍ¥?æ∏è¿Fü˛Ù‚≈Ã±®È›zóËùHıW)ÕÖlP‰î4 6∞^ÆÂÕF¬ãÑg∫6 ¢|·óTË…·ﬂ*ynï“ﬁO»ÿ÷§¢≤S◊ºx°U+¿f q±ú¥ª( §;œäb\KwˇÃ#—L
+¢Átzf´ØÈCwQ1Ò’´WﬂFf∞!ÜÖ}G‚l+«yrœme-Ë¥“´Øø˘·ıèÊÿªpÚì,û„≠‡¨dh±#∞ •º™e∂ÿÖ`oZ–ãü`Ê≥‰ õ Â•Ëyı˘¸¿W£Q<'ÃBÖÅÏ,´-®»%Ÿ˛ƒ7˝§Q…ßªó¨q·O‘©¿P}F¬	KrX"∫mÛe∞•ıˆªá`Å==Ã(,ö|ú õ®Àè‰≤„É*¥ÒÔWyJUf Î˚1`;K¡'-dŒã›¸ƒ\ıœ›I›
+ïdZ¸¥kEÇvNÓI;P{ib)
+0´V`ﬁôÉ5UP≈(Zã´`e(:o)-«rbáœãˇôΩNÕt¸v≤p b“\N∆øœgÊÙ¸r RÒÚ√d¯Ó˝Ãºüü&÷t‚ﬁÄ1|ÄÎ®ê≈_¢Ë¸ırÇê´√ãÀÛ!,Ë§mdÜ£˛˘’ŸpÙ.2∞ÜzhïÛ·≈p_ùç#⁄º˘(äÊZ@Çˆ‘ÄÆBAâñpÑ¡#ûß˝Ûﬁbpé˚v6É_@ÑöÈ˚ﬁ˘9mJ*‹ûz|=LD=∏#ü ÷ﬁÈ˘Ä7Éü'É˛O¶√u‡úÄL ı<2”ÀAà¸u ÁÍM>D≤Ót_W%¯•9Î]Ùﬁ¡1è=·Bä%C@™˛’Ñ¢4à–”Ÿpv5òw„Ò·~:ò¸äx˙Ü—;û©·„¨7Î ∞`æ?Ωö	è√ÿ…ì´K‘á ˝5`i¬®È¡„gÑÙÒàéHO>‡¬à	]ø¿Áƒ1aÆá(¡Üíæí⁄~ˆ§Œº3õ—‡›˘›`‘‡o«∏“ıp:Ë 	áS¸,K6;l›ÉΩØH>ÄéˇÍ1vDD6CPÎgø|˘2Æ¨1
++˚ÔÖ]ßtH^ó/´rÒkh_Ç'XΩºOÊ/WY±}˘ÁÓØltUëö]ø8øã+¯çßáÄÇèË°Ä˝o—+;€ÕÕUè´jŸ‚ÁÀ›új AÔ≠;|ëõã¸hN¡+ZÇFÈ≈%ñBÀ
+s˛4∆ªy≤Ì¥>˛˙÷¯›œã=XN <zŸ:ŒkﬂÑoΩéÃœ≈mrπJoZç'>+~-Ã€ßÎh¿˚˝	=ü˜Hå¡.<èw s+ÆÃ•ÅÉÙ+∑0äEW§U§KSæ ∫eW∂n…{!¨0ïH¢Üõ≠\˛¿f¯Tû:Í–fÀ‹Nõ∫•ÛˆÕPÈHå«ïöQ[ZB¨éIE¢¶7‡Hs‚"¬Çm<&ÁU∑Qêà¨’Áak√tWc!eGvc≥A–Vq˘''Èi{2t2v`“V“∞ƒ˛ê®nÈÖ>n£∆e÷¢£≈cã €	’ÂWöh¢%¸6©Òê@7ñÑncb(»∑2ı‚¡£8hUÑ¢⁄¢∫€!phç¶÷ÛT]ãßMùr£5ö
+.
+√Ì≠ömtFè∆#?xH≈ıÆ‡$ÒzD”—Û™„õ˙çîfdıìJeOé”ûÿÔ¡?‘NàGr:ÄDΩ/‘#Í¥¿€…∂y>V˝1JHÇêR®<TÍOÅ¿Ÿ†wk¢&xûL˜8›{ègkÌúŸ˜Í;ÛÆ(n@àÛÖÿo‡Íˇ&æ˛sù˝g˙˙øï≥ˇ€x˚ø©ªˇ[˘˚è:¸ §øfié)h–⁄Â˛YŒÏW®OøãÃE\.Ãeπ[˛È#lÒÓì˘?Î˚ÕÎˇNs°Êƒˇ=Ï°~°ã˙[x®‘ÿûÎûæ`áÌK\”V(ûÌò~1 ¢
+π§÷∑ZT˝Kóò5ÿ›Ê5ÈŸ¬z4ãY´¥x≈?ü#_>ÍÈ“ÛáΩ›«Ω\Z‡1O∑Õ√•˛≈Ó-≠ÛŸÓ-=›Êº=ŸΩÂõÈπ∏œsoŸ.©Èˇ'ª∑¨í∫∏è∏∑¨éü‚‚∂`àÕ˝Á∏∏æ{KOéãÀÓ≠E˙g∫∏¨Ìø»≈•%Ü£œvq’òƒû‰‚¬‹Û›Íy ΩUﬂ–˘◊hë¿â˙‹8g®Ax)´Eœü]rî'*Î%˙û‘Ô°P¨ªÿh•∂iüë⁄tãZOâ§>®[D›=!äz z˙?CΩ®‡yÛ•—”∑‚B}AÙ4Ù'??zÍ©∂ª?7zzCøójÒ‘ä∆û=m™ZÁô—”vµ‚î∆S¢ßOR+7t•O8†F∆˜4Ã√ŒÙq_öˇ!ıÓÙÔÊN'˘}˙1=¡–Ù´_Ω>yıÍu˜”:cz‚^»ìÍ%~ØJ∞≤„%vFV[
+mÒ/6PD€∑=Òè]RÓ[Xæ_&\˜÷ßMïÈπNéì)!K*˝òòØÅqÉãAA√Ò‰/Êàs6x2Œ‡||›	t–’4}õkûÙ^˜'Éﬁl¯_ˆ˛¯‚âvyu
+|gÑ˜ÃÒQøy~Ñî=íœé:]∑5Ô3QM NñRe"Ó•çˆ.AıI‹ü˜Æªƒ÷ÇïÂ¯õ≥˜3dï»! ·ˇ˜Œ{*x~‡WxﬁÉ4Ä\zı0(åIüÂnMœLmw∑ @⁄}_aù≈‡r∆
+˘›d¿∏Çg@uùé U!fºÆÆ>¯Î’K ˙Eè±u: Â˚N8Ù¸8È˚Å<á}á7mJê·Á|A:ËH‚ ^≠⁄”ÿ+<5ëıH'à®∂ïp∫ê\`}·»7˜˘Q_ƒπ‘mÍ0∞XJ‹¥¯ò∫Ë”ge<Xìò@/nˆJÚ≈~ëÃhQŸ§ù»£çV¿",∞Ω±yÆ∏ÎF≈.[Z«k|ì¶qûÙ%U≥^q~‰§©8Sk`Tö`%$,¢BOùT À¨´$£¡$î(™™d=œ(ÌÄâ&≥p8°F¢ÆÿRT˚´c€l[6∂s84X/lº∆-0•Q⁄s)\≠P÷˚£Òh®R}–àÎh*°_]˙¿ˇ7	*;œOijãÄd‚˙ÿ÷◊fYë'ŒU§“vQUnºÜ+B∆ö¡;7mØ}ëF„UÅg{Éz.Œ§-h!ÚÚA§ˇ∞î–`á¡€πÁâŒ°ãmÁŸO4¡ŒñHq]~Åá>§ê–CÃFÑùﬁí¨VòÌírBUdÉåZÖl´S£€:‚Åu^œ{±ºL)£∂^ai9Ä(À|y`Ëó;û◊—‡[L4ÛêUs‹ƒ˙.«dY‚ ø
+ˇkbùÒW›ïiµ‰î¶˝∫µëkî™Bx|ﬁ¨±z([d¥◊nSx„∞A0¯@/2ﬂ}0=NíO¿¥îkÂV'°ºaq∫’$´®¢XÊ!0ˆÀfˇ)ﬂ[Òâ„Ã~æ&’ä¡/∞†_ÜR—‘!K\KaÀr[o&úóÈÚÜÁ/†éÉ5ÇV >
+J;ıÀkbR<aÿ%Æ∏´ùß‚abú
+£„%…≈™ı lˇ%™eÏQ åÏ™¯ÆHóR≤œ®.vÛm$CIú@àî<TZX•:ÔèpÏ„Wc’>_‹‚0®˙cC¨ZŸ¶Äù∏kÆ≤7·YL)6?∞kuDÎ¿áGFBO8|C¯_ø! ÚadÊú°ì,πK2◊í(6#íKBÂ4ˇ™9#…õ¸'!†s÷ ˝y¶(∏ùhãí)⁄á?9P›®ß»˚;ñ√xî¢6∆îØ(vuxÌvıŒ—îÿX'¿ıh⁄gÇ¬W‡∂0§¡d6èâr[˘Ç(®'±€Y««Ú˝,fÄ«éDÛCu–ZmvñÄÓçï0k≥iÕû	5-çô¿YÜ<!˛üŸs∂ƒªLtpåîrpk:ÕL‰•ÌD.ıÔºJ€–nŸPÜ∂ŸﬁªÉ‡c}ˇ&EÉÃ.`≈ã8¬ÎmúñÊ
+ô–b]ÏæÂzZ˜ñöùóÏ$mpñs#n/‰˙í∏ûˆñ—yV∏5£Ø“≤⁄ÇÇ„˛íŒOTTíù•Kä™]#D‘∏‚›≥ÙΩ˛ √ƒ◊]ã;öôı‘	Y-÷ì%W8ãáby3∞¬IW·D,Z»–2«*ó:VGÅ∏Ÿ#wº…W!øx5Q˛∞#7Jã·üV¸¡gSåƒNOÚ5vô9◊Aù@	V∂J™π2Xı∆2•Æ•æÃõ J=AWtÀÄ∂0π°ÌOm⁄∑ﬁvÈƒ≠ç8⁄∆EzΩ›`ﬂoxƒOñƒ%Œç∑ë°ÆÚç∫RmoëìÍ<Áß2˜I…3ÀîÌ‘Ní∞dH %
+m1ïï±·4Ot¨·—Ã_Çƒ.éÔ“«4q<»o∞ ˜únb,Pãé‘€åÉ¸Ôbïc€÷YQó≥{ØeÊÿú∑E^∞EBìıÏxù§È(=æ+ˆS‰˘çõ∫7ﬂãR†i∆K oãF*∏‡√ã–+#ò$}±u∆|ò!ˇßù©~<—◊fG>”ÜÙD∆%ÉIÎLH¬··ØHEùfq˛1±S´Æìï˜1˘ez€küGJæ˝Y∆™‹3¥GÏ†+n$∑7…n¡¿'Î9?à£™àE,[≈…q“ΩÈöﬁ¥ﬂªåÃÈ≈Pr(ÉiØﬂâ@ï∆,B‰Î*ÀSibfÀ…ÏÅ@üJ0ô	ÊÉ∑ΩOÊËÇt|k€£◊Öùﬂ-:õÿc
+úG“Y¨∑¢◊°ñe÷S—Ká‚[ÕéÕˆ6ÂÕGç©%ûOÛûÜúΩ->ô}ΩS«Uªõa”"”Éπ>‡J,0é≠Ó!¯·‘:øz÷^fÍœ*Dé™FµU·Ω˛ﬁ\M˚˙rÛ˙ı∑∂keÍí(l◊√∫«	wAúÕA8Ûù˘™„—ÏöIä¢‰1ö=p≈*m^…Üˇˆ ·ç;–”	Ô±ÈIxYÿ≈#ZOé¡'V^B{◊‚ ÛÛ[.@£,˙1¢rÊ' Ï7mÑ}å®¥ŒA¬∫ÍkAäD‘Ê≤5’<√^f¶Øcl|Á≈=-ı1«6c±„N7X&4c†€‹FGƒYìN«ú≤ã¡ô⁄T).˚€Ç Ÿ¥’Å¢4µ°≈H‘8â?Ñﬂ;@◊ØTAI|òlÔønA9ëmÄ@¨‚∞Öè˛CC*m}≈ßV⁄Íí8(R˙µ†ÆÄ›ö"{…cnƒ‰y2ìÕEºñÇ ”cöêÙEÀS∆˙Z!/∞ßªØxQ7"àªŒ∫_ß^R—äõ(9R⁄tÀ]v¥√D“ef(ù◊¯äöQLrTq‹¬^åî ‹S‘X(ODH]w4… Û8^Ns29S0„π,2é_úM{ç8ë"'v√9b7˙38¢ÏJˆ yc[e{]£ïÜ·Ãº‡åÆµƒÈw7∑Ûcíl–ï¬¡Ú27ùë^E‚B
+ﬁ1≈´íTo ì]ÑSEí‹ÇÛ¨Ì(©ûj¿⁄n:ΩI¡ß$àL^ë˘Êkµ+ì ü5pÄºO†
+<T-t{ÂKüI∆  Œ„≈T }É”eu–≥‚is‚6/ñ∆‘y˝íå*ì*Z¨@éq\-ZEÈ∂J≤Ç0O“Ôp(–Wuk´¥é83†≥p[$§50îm#ﬂ‡J>—åóˆwsxáÆQX[¿g√ÅD8Ôf´°Xø^√°|—ât™ZRyß›	Íæ<-ˆÙS:Å¿û¢∏Nq¯¨˝S¸;4O3ŒÓT–OˆETØ¯‹ˇÜ3n8r{ÎLˆ‡g=yEÎ‘X¡¬òÀsççî⁄Òï‰‘:%lI¨=úT;∂Àß¸&^àŒ¢ﬂë3ul6GíöœI≈©ÛX/Gq’(Ó,<˙]ÁPr∞ôT&n«ä+_Å‘© ÇL«Ôä¯≥‰5¨d±ÑªG\¬E”™±NkÔHX”™.-˙8û“·rè ’ëÏn°/„ ≥ûw˙?z 	Ë˜|¿ó<±7„1∏ﬁº 7™áT0◊dËÕÿm19ŸsÏ±6ò\?…Éñì™£¸_b•ìáù@8=…Tkù¯+b¥≈t;ÑéNyÃà{ä⁄gÌ–n¡5Å!T¯‡Yk,‘[-6U+-ßkµ€Ùé8€MkÜøt–sÃÉìSŸ7—°Ù£úd·∞‚,y–ò”C∂tç|∞≥Ìz™œ∂œõƒËäOÿxÛÜç◊P˙ˇ>sØæıs,?váNMˇSÍ_ËÙ˙uWû/ˇö}˘éTk¥∆¨üÚl=*èœHtÚ‡sëg˛…`–X-3/{°SÇ7ª≤⁄≈\;Â{Q√s´∑ë∏0òùMë}NKE~I®«I&~∑Ü˙u,òY˙OPMd∂Yª€πSKÓSàkS%ªeëÔ◊<ÇﬁrB~î¿—Ff‚Jã
+i·¥}E˘ä5¢m XN&≈C4·≠‡ø‡%bÛ(64ÉëÜáJ…åƒ‡^Â 
+ÏW–û∞/WË˘€èè<+À\ÚG$≤BıßÍPë^Ã3ı’ ñÑ¯(@ØÕ÷œˆÜØú+—[∫≤ò}za‚p∫LèÿÚÅ}‘íÏê˙oñYÛ§1ƒ◊…y·x
+^MÜ$ôQ°ÚjÃó(‘pÆÕDÿ¸çÚy‘ˇiy(c%{≥àŸco∫q"S≈ªÚ«1‚sﬁP5[ù‘"/â˘ò´éﬁñIé`·ÀNÌ
+¿5éß$®9öIé≤ê≥´˙ÆÃ 5€Ú8Äﬂ&zﬂ9¥>ÑÔ%j,˛…›’íÔ˛ås∞^ﬂÿ‰6ÓVß®rÕÈ#∏mëú\˙…a+.ˇd‡©äã_E¡l®ø†+J≤OÎÖ•ˇ\j{i¯&≤|•/S·◊~xﬁC•®¨ÙB±`√ΩÉ$Æº˜ÎËƒJ~à´≈€ÜEŒòÛeÄÃ»®ïƒPë3-Ü…"[®pÛ•õPMéT%[öºÃ1o∫OÛ†òâfzˆP≥,®a‘iÂ,ÿüx∏¨∂öÏÂ˛“§sÅØo§úÎµJÌ§ë•fØ_†PHâië·¸∂W75í∑Sé’P	ëÔG2«j"πÎRìπ“™Ìà~®∑ÔS`ıÃßo1É·ﬁ¡IïÚ◊nr<Ω‹5¥Ò9K5:ßnEm43W≥´ﬁ˘˘Óù‡ÓÓó†æ¬Meπûg‘°ß]¥÷¯Ì[lì¥ΩΩÈ…p*=s∞`ÿX!ùF““Ò~p~&„^òN‹qq∆	 ∫Y7l∞∏Ë˝†çÕdÄ≠óÿx(ÕLVÿC©ÌMÿ4—LFÿ[¢G⁄Ωπ@SX[πÛ#~„µ*jgµ)“˛Qmc“œiÙﬁ‰/7"H€:áOùƒ´‘E:Oßw:HØ»yèq=±ìuﬁ˙38Œ"ùÙ˙‘á»éò∞«Ozã&ìÒdÍa5Ï˜«~“Ò/É	vuÕt|¡î˚˘ÙlÿgúçÈª¿P„k°>†l*›-m≤”1u∏p–Œ~˘¢˜Å∫ºdN˙0æÚòˇªpƒÓO3áE∞(‰æ…‡øÆÜnˆuMNÃzΩÎ(hêΩûü;ns∞Öé8ºÎùkG®m∆Ö_ÿÓW‚B–˚]GClÎB‹⁄&YmâÂï§˝”ˆ|ÜU¡hÀÃ“˙ia/Zß¯≈ìB˝¶¢Ô·Ó…À µº«˘≠AX°˛¿Ï++“‡·KA„h¡qzò"Ê(˜Á%Öö‰ï5"q®ƒ∫z·†dôã^ÔWı⁄|Ö™oÿ|PÂ¸ˇ6•fm[_Ø]'©çÏV∏ê„zÉ»™IÄÃo¸FMº⁄ŸŸoıVVTﬂ∫MW|e^GÊ´»|ôÔ"Û=Áq ≈”Ø„ŒÕÇs∂÷6◊
+RŸh+Kç¸–j@y#VÊgVñ˙U£RÒ¿˚É¨ÍîTÂ¯ëÀ?—BsØä"∆áﬁnU{Z∑≈∆äº≈dkçlMåbeî~ÚÀÆŸ†÷!P5óÖG[ñÒ}ò‡8:J\ ‹kÃ¢êHZKcë'YÇ<í˘ÔDv~_-e/÷uöÔÂL4'e˛á¥Sâ[Áqº68p©/…„Æ∫ÊLì$À‚<)v^Ø‚ÄÜÌ:Îo-|Z$Ò)}=khˇ∑á{h-∫qâv¨®ï^æ!. Ëµ‡yYZØ‹ìí;≠%ﬁ‚3‘oS„›≠Aö¯ãëÁ{hˆvDüq––'˝wúx»/Œ∞)ìF~ê	Ó‚,•∑¨Ô¿3#Êu˝w|áÉR}1∑2≥/iÃ<é`“B∂#EV“DÅ=-ÀÒ%DºrëÕˇ†±⁄ït¡c«v‚’h$KK0ÏãÕ§-Œù›æœ≠L∏ïÃœí´_-πÊ†KπÍã1Œ¥5œCõá˝QAGì˘-(`°Z"ÿK.§ïª|PV˘Ùˆ •æ(¢'J˚Ç°|Î÷t”lÄ√ÇÆÙäÉfñ‚A≥ìj_9(∂Û·∑⁄Q<ç⁄õΩóÃÕìÌ=n}äŸÃö4ÁÚ ”a®*)TSÚÀ3ÛÇSµ\%˘{›™‚÷ó¿ÒzÄÇmHÀHxéI…˚πÿùÂs¿–úJ;qbE¯N?óídÕ£Aöhúõâwπ÷Í´U{Kû0É %˙V˚©;Ωﬁëπ†ﬁ≥√rÌıwZÆ&##d‡»ªJkƒg∑Oò¸˘Õó¯OôVÚ«ºíﬂi^…ª]|?ùÌ^øB∂˚Í∂˚ÉÌæàÌ~∆Íùòj™ûŒ{_ô~≤,ê”ﬂ˛ﬂ˝¡wœ‡ªˇ≤/„µxuéA
+¬0E˜û¢k°πÉhÇ∫–îê:êƒ13SZOoj% ‚rﬁ˚ü˘ò|–ö≥›Ïé÷ƒ~Öí5u,l¯V!É¶+ö*ÀPÃ!ï¨åR≈aøµßã≠7<ª“W˙*Sl1±∏ZˆIÊwºf∆ä[ˆΩó4Îπ˙+atë?OìÛ^£Ü˚íxM	Z1‚Äxú˚ ∏ÄI;3/9ß4%U!»’«’1ÿU7Ã5(ÿ”ﬂè&^ñZTúôüßWP…5·+ ≤W÷≤xúuê1o√ ÖÁ‹Ø∏-R%•#R˜Nm÷N¡gåÇP…R|1â”¡ Ç‡Ó{Ôé⁄ëÚv<°‡/≈∫{õ2&÷áóéå÷· –ùﬁ??æPﬁ hßƒf ª8Á1xLîKÏ‚|gn–w5I´lK.”d•£“WehU4ı3«	¿˙îïsO'¥Qà lõw1@¶îÂ£œ≈/Ö¥ 5	 &SÀ≠Ejy=˛Å%∫†˙ö'∆9Z =íæ6ù≥>£∞8◊mB…±d1ûT~ãä©ã£ñ˚ŸÿåLS»Ñ‚—0Elçıı5“b¨7]™_øó{æ˛∫V8û˛ X∑£ñ‡	Åxú{ƒ<ì9T/¿√ﬂ/R¡J!9'51O!©43'E!3Ø∏$1'G°$µ∏D°(5=≥∏$µH!9#59õã¨–äã≥†≤$#?O°8µ§¥@Ø†jÄÆ.P„Dv’â÷™ Pc¨ ¶ud¿ç÷„‚ô>—AíDO÷`‹ ¯81	∂´x’Vmo€6˛Æ_qpPD\ŸN∑a `n⁄!⁄Ÿ∞CQ4E€\%R!©ÿ⁄Øﬂ›È%^óu÷/3ÇÄèwœ=˜∆≤RVEï€(ÌQ4É≤k@ÊZô πﬁ:·jÿY≥R»ÉÇYw/zß•2^ePôL9tÿ»\%hO£h}–œùÁ ‡h›g–Jg˜Nyü ,*<qÍ°R>xN¡QÂ“*â¢ãX‚âv™@D>ä¶	Ã¿U∆h≥Ô— ‡ Â¢´÷ƒ®„”Ÿ˙‡Ù.¿¬ŸSÒ!Ñ“_è«⁄{¥óÜúX∑ˇÆùoù=z5û›‹‹øø7˘›èW√ŒB])ùÜΩájõ –q«Ê∏Ïâıg}∂πÆÇuZ‰Ã¶W°*!SAË‹'—+ÇÕ(€  ÛHí"œU∆,‹5;¥5Q¯+uŸ… ˚tõ?#,§√∏˙˘	‰ı3 <fÌØÖ◊ÓΩÿ+⁄_¿çSh
+) ≠1J>Ÿ›9[`¢tÍ@•u°Á{Ô´¿0G∞XRi/¨È†®ÃÉSù–÷àBF@ “Ô'ìü~AÂïKŒ⁄@¬{Ãû,x%ù
+Éaµ¡æ€\¡ºTémc¶êŸ¿_S@KºWΩcë%ƒîÁç:iÃΩò7√kÍP'hKµ·≥V¢1¸¡i¶®Û◊√S{-Ç<–)÷EÃ,a2∞e–Ö˛wTR4[Ìe–2wtH£jmnI—Ê»ö:”$H∑MUP9¢8ûå`:ôLŒ†®™#Ö«Õãl/{ÔäM«ró‰näÀ\=–ÍQ‰È‡´ÚWΩ<≠ûó?∫DdŸ¶h”!nM„gÃOØ‚6~+L {È!÷E°2çå3cæ6“Yc+ﬂrÙˇpùÉ»5a:œÖµí¢È]÷îú˛wœ∏ëb´√é◊d/üë◊¯{1ÜúïìÏﬂÚµt€6&ÚQªîª~ı–ØªU›
+√ÿ$b%rö$d{ÿ
+±q9É9N’öv1ù›AÃÊ»êDïìZTÿÜ≠uŒöº∆ÀT„ÿ«Ë"Õ.≠ısƒ¸pæß‹XbèF”K ÌÈ%˙–ÔÆ.áà¡Ê>˝¯ës˚”ß≥ ¯$Qãº˜M‰é+N†ØÖ≤È”	UæôˇóœgfFTÎÌïtz^‰ﬂ¿j'<e€ëJÒx{TíÿCó'§WHgQ`Û`çT∞Uòë™åò&uK’ﬁ≈aŸp!≥≥a¡?j¿˘G≠”'e ‘ƒ(–Pw¡BA˝j[9z/‡¯æùØ÷„≈|πÊÃº_Ω]é≥’Í√|˘ÜU´œ¢≈oÎ€˘ØãŸ˙6$MœèZßßo:¿G”f⁄™l ∑C∏se‹»V"ãˇu⁄pBë∆[lµQŒ7o%#Ú:hÈü‰iı•Z—âuö{å§ıŒ‡¯¿I«#Ê◊ﬂÌ„A8yhp<ß{@sCCàn¢çË/˙ﬂX|b´¯Ü2+7^“ŒŒ~¡ÀRÌ’	~—9¢`Ïé?l=õ´ÖÁYg—3˝—üqïrµÂRàxú≈R;é‘@MgçDFi¯ûúvÉ’
+»≠⁄ÓÚ∫Eè€€]ﬁYG>ÑoÄ8 ' E‹Ä≥P›ˆ0≥Ã0¨¥¸©zı™ﬂÛ˚:ˇÒ‰À∑ŸÎ<π“Ì)òZ”†µ¿Ai,©•è¶C•⁄Ukh„I±Û]öz6|üΩËó¶æ§¿y”Å1Eú,°WºL®7ûêåñ^˝Jê¥<BbËWçÏ_bç∂c£Çpˇ7| ıGHÇâœcJe“Öv™0LE„VWöÃÛ<õºzÁ÷0Iå˛,Ã˚[í£R(ùüå‰
+î´≈“Ü@û%fÀ µaô¿ZoßW-⁄∞ÆfÛ·Álﬁ/G÷˛Ó¡.E:-ãÑ∞TŒSë^7r∆˙FÎ∂óùéû@NújáŸÛ>¯Pô0⁄óhdåA÷\Vl;âGYíßöaçópg”ƒ≠Øßaa^E‡5⁄ñ‰ÿ‡ö∆“¿*ºNyqPãN”≥¯›†–êÌÓ[iqÂÍª˛~–ΩS±|ápÎ}‰ΩNa¯ú=¸œ◊o˜ï˝+ËÜ öã)›„å$ÕØ∆t˜O¥M˚/a¢Ñ]≤t‚„2ìÓbG∞ ÇdC|ÿ¢áÛÏ„/∫˛œ:°xú340031QàèœÃÀ,âè◊+®dx6˜—ÏMØ9{wkÆ+è∫qËIODCà≤ƒºƒú íÃ‰bê∫'ŸŸoåïü/≥l8Õh+Ã0mM£•â(dÊ•§V§¶ƒß‰'«gñ§%ñ‰1Ë.H_}#ÆB±nÀ‚”™ÕNrèN]ö STSúö\íôóéPø+d˝">Û¬:g√uãVŸºö<ﬂi‘E©È©Ò≈©âE… óv=W‹)vT˝ïø¡›⁄á¸™°Jã3srRAäˆ˛»ºzÇıûhÊûy∫ôë±˝=/CïñdÊÄî,ì‘œ˛í~`…Â‹ßÇI´ó>{2 §πuí0xú    Ωüxú}VQs£6~ÁWl…§Åñb'◊æ§ÁÃ∏ódŒswˆçqzìISè2®âìDàˇ}W`˚“´_`≈Ó∑ﬂÆæï|Ú√®Qr¥a|D˘3‘;]Óù¿GñRÆhZÄ.(Lkí‚#[›I·V4<#ö	¡4πM*Ap
+BB%$EêTp-Ÿ¶—∏T:@ π§¥¢\´ °‘¢œ´Ÿªÿ≤íB∆î¬‰-”‚ËÇ)hÖ|Ç-"ë,c&1)Åq\®Is"3∆sL[Ô$À¢ÂT™Ç’1¢¨L…mœD9XõãºMW√Aπ]"¯aLíãxåHÅqÒªè~¯;Ï0∏";‡BC£Ë2}Ii≠ë(≤™Ííû“}YCÏ≈}á!6ö†;±eÄÿ∫—ﬁ	Fö_°u}9µmÀ62ı≈ç>bCÁ…Õ/ñ1Ü‹Òí*Ö]˙⁄0â≠›ÏÄ‘H(%§Yí÷Ïõ›ªÁ»†ïÿfûG†∫MGî√ÕŸw´gáE:`øö¿,Ò·èi2K"ƒ¯2[Ω_‹≠‡ÀtπúŒW≥õKx∑ò_œV≥≈≠[òŒÔ·√l~≈^a˙RK√I2”Göô-Ìı”0Ú0∂™i ∂,≈∫xﬁêúB.û©‰F5ïSf7“À•d”VDÍuQ±Ám•®p2Hö6US
+C@H”Œé‡S„¬#Xb>˙m@Ã4ïá@ı°?Ωçk)^v±÷ªön≥..°⁄Ìƒ∞Ä⁄Ë“4öïΩATëäåzv…6Ózø§îÏ›*îÁÕÔ>≠ì˜”Âu2˘’Û2∫E9c˚ÇJÂì9wxÈÌ’íq˛ù˘v	ß
+ﬁj#£+xõ1y~Êy·Ã7W«Ò£ä©b"ÛÁáÒ£16}a:8]™úÍu”∞,0ìÛôË¢À&©n$Ô´â´Ï∑ΩG\–óåÂTÈ ¥Œí*8ﬁ1åØN«ô
+A–˜Ày¡è0~oª_x∫Ô≈?-ûP¡ˆª<‡.WVÅ™Ÿî8fÜ$ç Ugˇ’>˛|°‹8çK—RÑ°0+∆{˚hMÑÊÄ≥ÖíÚ¿,ápo;>f@È∫ÍƒßkKúWSy¶®ûIŸ‡Êxw¨+òöuµªÂ∏ntên'>ı#HøN|ﬂ∆O,ÜÛq9b<ÉáƒAÖ|^¡Z.∆N•x2%9é≈>%Æ⁄|cÃ>]˘U‹‘x„Pezp>è˜(ˇCÏ–Âø¯yﬂÀp ˇΩöµ‹9'+~~ÓŒ8V∑∆Pá/.=w-∏h7aàá◊%G«˛\	
+°Ù§ÿ¯˝"YE`&uøˆy±ƒ5ºq‰~Ì.πY¢Q
+oÃÏ¿wö$_ÀkLÑıöõ ‰ã-˜5Œ°“*∞∆Òåøìî W§vˇ‘æZ'ë∫∂´ÑÁµK9¸º!:-÷ÆóÉóï;«qÏ€u9ËF
+°#3	∑¢ƒìYEˆZU∆]®∏%ÂS`„√˝vô0„ƒIÂ¶ ã•?>ê"¢‘¯ˇ#\∂>¯X=]?06˚aØw”çÏ»€H—_i«¢≈À(Á¡@)Ç3y!¸qLzê‚—»Gﬂv˝‡ÔèŒ≠w&NK°PrˇÔc@º„.àDxú}Q1k‹0“&AKáL°î
+/ëà1π(L[BÜÉ§C3t∏∫FëﬂÂ‘˙$Wí1ônOFˇë˛´ÃÌZ
+yí}πB5ÿOﬂ˚ﬁ˚æ˜ÙgÔÓŸè’V≥Uˆ∑;_˜º∏¨ÅÊ4q ¨\$DÕ˚ﬂ;/˜•—:´†e‰∞¯Â§ª˚nU+	⁄A9WCÒŸÙ‰Ù√≈iBj•A∑KƒéÈî_–@aÛ9é*¬7Ñ‚ôKCÇˇ‡·¨˚Êt≤è;è…Ãy´∆ím´*Ã!Ã∆bNb≤ˇ˘Ùyøª˝‚uÄ7¸Œf¢™ eÎÖWF≥5=ú0«˘:—ˇz¬ﬂÛMeÌÕ∑`€ÅgΩ4µÚÏ`ˆ˘Sqxê˛j”ÅeúÛa®æ€NWèh"$k„ '!aá“≥Çç∏ò¯ó¬ÀEÈ§–√k§4ƒVË+p˘Ïc¯3gMó'Ó(I)·$·EJï+º±H\M5^HØÙ’tƒYcï± _ÁØ&)EpâÃƒôπÔÑÏÜqkeå§© )x1Œ˝f¢i@W2˘g∆+#µ˛ÂøﬁC∑—{y‹s|UÏ•÷∫ËX˚†BH‘x‹WÎÏË3Ç;xúçëœJ√@∆Ùñï‚.,!i’V!ÒÏI°Ÿn”v%Ÿm7MO9˙ }Ôﬁ} _√…hRrhNì˘~|3;ﬂﬂ≈Ô˘œˆ‰Jh•PÄÑH„4“Ñ:éÂ≥(ÑÊäG[+EÇù›kÔ%O“8ñj	“sU=Íx&Uh»⁄Hm§›æGùs˘|˛&tî∆ä`Ë·nEËTŸ¶f-+RÏ≈Pπ
+¨"7π·€˝Ïø¯¥¢AmÕY…ƒj‹ªÅ≥–1LyíÍ–<˜≠ëñ7¥^ËÙÂYÌÀ≥é•á¥&⁄∂<√{¡û5|wﬂ=7_hÉT#©ê·jè!ﬂÛ<zÔ ¯ q©ÂVj03˙Ã æªN-ã†LÖ!±	∞ÿ@Ò¡£ ˜Á∏¶áhSŒk⁄?dãsi[<ÒH¥
+∞èJöa˜]KE–$±ÜdW…äõL|6`CvÕnÿ-±1ªõN)d±˚:ΩTXP≈=›DpE™¨™€A4 ¢∞¨ùëNBBˇÜƒ˝ÏÇxú€Õ∑êCs}fnA~QâBqjIIf^z1Wr~^ûÇ≠ÇcrriniNæFF~qâ-LZœ√?8DG§!‡+-N-BàÖª’%óÁ• ©u˜r—‰‚*IL I›<ëy3 !◊2gÈÜ8xúç–1Kƒ0°ﬁ)AËÊª¥)%–v:ÍÊ"Ç√Qéÿ{ÙmRíÙ∏[,˝˝~WøÉì±ßpÇ¬e	ºº¸yy˜Gˇe–éUUﬂˆç§ˆ…c>o;©÷`µ∂oû>UP√¥}8˘∞„Ï‚\5\ÄË[büg·uﬁEƒés2L›).‘◊€ﬁPQß∏T‹Ïä,MÜ5À©´h¨3∞¢qê‡ñôjΩ‘˝„Wú®ã{’CÇk°¬“Ä†Èzˆ2LJv®Ñ4Ó"Lx¥ë˝˘øÉ‰øà5€Ä_=…b_Áó∑ïlt±XîeÇπ;bF*W⁄ˇeÇ˜„~ÔyIÆvÀΩEURZ5RCD–'Ew£¿Í&Å xú}êÕJ√@Ö-‚NP7ó@úB»ÿ]!;7.‹\âîi2m#…L;?ñÆäœêµØ æÜè‰Œõÿ¨∂YwÓú{œ…˜zˆv˙Ò–9'ñèJ)x≥•ù*iÖ±©ø:œµÎˆÎ˜Óe˝ŸΩ^Õt!-xwrÇÔÖúÄQïÄú[q{d¨4HWA!As,ñ$aü ~%â=®üÙrÍ£∞mWŒbÛﬁYn%™áæ°~+7ÇxÊlê≠∆)Õ∆ªÁ≤9vÊåF¬Àî‚·ƒ¡Ò”7Gß:Êy>¨öx´&V!¡nV*#Çê≤¶2PI¬¿Nµrì)÷Ω!≠^6`2%el2.ÉñyM›“J-3£’"E
+∏
+ìâÌ≠GoCÃ¨Jì>>≠ë˛X∑ªˇÊ‡2áÑ±Ωı≈…ïﬁz‚Æ„Æå¢ÈûÑ˝í‡-¸7O˚ßLﬂå∞æ ÏÅVxúõÀªñwC(3fnA~QâBqjIIf^zÒÊfOf î|	˛ßxú340031QàèœÃÀ,âè◊+®d®‚gœréµûWˆ2ÚA…Ì#K.|¥- ˝\ŒæÂxΩY[o€8~˜Ø‡™/6‡U“≈b2É'çg=;uÄ83Eë	E¶Œ»íK…uå≈¸˜˝ŒIëí”6E›<$y.ﬂπÚíWˇ8€ï˙ÏAÂg2ˇ(∂áÍ±»{ØƒØ*ïy)ó¢*Dı(≈xõ§¯3/V’>—RLä]æL*U‰¢?ûOüRã"ó¢–bSh	!iëWZ=Ï*Leµ@ë¨µîôWe,ƒ\Jñ>ªæù^^âï §X™≤fÇÚΩ™!ßzT•ÿ˙/±Ç§dπT§8…Ñ 1±©ahπNÙRÂk®›¥Z?V¢ÿÁRóèjC -ô1üX$e-ñu¬»˜≈Œÿ‡ôkº0øCŸ˙Ø¯í˙Dô≈h£8ÄyìD^TbWíM ÃíÂS*∑Ä’fõ©$Oecñ¥~Ü/ …(™‰	õ!ä;»ËI’{ ÙÛXU€ã≥≥˝~'ú∏–Î3„ÊÚÏW8t6ø˙'#Àoy&ÀRh˘aß4\˚p…Ä“‰Nœí=≈çÉ√1ÇΩÜõÛıPî&Ëê‚ßé8π¬¢É—>¸ï‰"œ≈tâü∆ÛÈ|Ô¶∑ˇπ˛ÌVºﬂ‹åg∑”´π∏æó◊≥7”€Èı_1ûΩˇùŒﬁÖD
+ ±‰”V~ÄT‰Gπ§ê⁄¸± (=Pπï©Z©vÂÎ]≤ñb]|î:ßÏÿJΩQ%E≥º%§dj£*N¢“K#3ÓıV∫ÿ†2í4›mvYouÒtà´Í∞ï%°)t%¶ï‘	Ú|.´⁄inŸ({Ω4KÄ˛ß§îv°_<¸)”jp—£hFQ¥,R |@$3|R,2—RÆƒb°rU-˝Rf´°»ìçä≠V¢u
+÷CìF.….w∞πÔDL¡=àù∞Àgb,ƒ$@åXx∏`a—Cßn‹sË◊≤Z(„™EY˚ä-Ò‡*∞Z'wˆ|
+ÓØçY·æeÒÛ2Ÿ‚-YÌó#¢AJ.†RÉ¿ÈJ!∆Üj†o÷=tZV;ù’X¸,G†>)4úˇ˚ªaM™
+M◊Ω4ää™—£§*Gp`ˇŒπäÊ‚˘Âx6l‹«soß≥ÀŒ‹¯óÀ˚ÅÁuíß(¨ºäk≈Vpüó≤b≠< ‰¯¿6òãn‡'˝e±¡” ¬O•æe¯ö‘GŸnìó£ª{≥ÍEíe;´w¢Ã”Ç6åUÚ(öﬂﬁLg?GûOö¬±p:ÖÛ|˝πú„,4ö©*jl·r D¡wùúï+ë…aÛb4ÁM
+ÖQ÷1ôwfôïÚãMP{i∫\«∫T•ŒêF3|áR⁄	–’B…˙Q+Ê?
+âm«û∑ï˘≤5FŸ}”$û5ßÀ.ˆ˜÷ £Ω¶Vù˚rDY]p ÇC2‰at!–ÈŸ[«º1à≥bèZ¥8Mÿ¡£¯œBÂ˝ª:‡V(m@8‡M:zËπ…Î5-	ƒ¡!ÙÇg:dﬁùﬂSÑL*ræ‰s]`°g;¿|∑Ÿ†ŒlÒVd?ûk-ûœÙTo®#j6≈—ÎÛo‹Z∫é6ÖQÿFv◊⁄yhu·ƒfoÓtë‚Ï€]™åqú‘qK!åÉπ√ôø4—©Ó—ëπv◊2’µl£o¨ur∞ÅzI‘∆/]»Ù‚(¸nA¥û<íoìß–£ˇl‹|⁄SÜÀ”s˙(y Nïø,8˝ÁÉ„—û48çûÔúFŸ…ÉÛ≥ñ[wˆ/OœÌX>√'¬É€œ˜6ºVTrƒßûVxÍ≠!êÊÌ¬ıô‘_=Ω€}mQs ‚côÉ„˝qÁ^®-ƒR=pã<¯ß-(§sù(Ÿ•N∆j•˛A´ûqg+GéCÔ»‚FÆØû&*É¥‡≤¸\º=˙OÑ[˚û¶‰üÖ±OØ¬œ¡Á«$æΩX)ô-Kõ)xÏJÂÓ°~*∞”ˆt¡gù:Å|xù¸ÒOü>û≤vˆ8Ô O‹ÿÖÜÉk
+;lÅÜŒ©†p„êƒ˘$ní¥<¬÷å#Á¡K2únÙ `/ˇî¡8_≥˘Œ+xqŸ]ÑxT>E˜`	iÀm=Êòq^\µ∏-MóŸx”g˛–fn{‹jvév‹òŸ…ª£jÓ∏∆ BO8Òk+Ìm…≈¶[«ÜèÉ2∑ır∑÷»p¶õ;Àr◊óiéñP‚≠wòÌ«?—*®çïÿäj± íui:∆ë⁄>*∏S‰«®N_Ì«¥∂Àû-EˆÚ_Á|Œeg=ñ›ÿë‡´JÀâ‡Ì°æ6Míç¬ãWi˜ë\÷t∆ÿlz;A6” µ¬‰#V'fS¨Vâc´’∏œFUòåÑõ-Ó˙5Hæñ^÷»=¿‡∏fÏGxÖ˛·ﬂQDÄıR‹bM˚ /öçßç>–ºÚpäz*·û
+Ω–"Ó8»x®»Ò_Áyüÿj04¢4mƒŒ˜›£àúò™¡Ë"ıCñﬂÖ~‰9Õ¬ˇ„º~Åß »ÃòJÙØèõ˚«˘˘kü£˝∫¶Ö◊í+˛Á˛—èTéV®ñå’bé$S¸SÌI.ﬂ©Î;« ÀòÇ÷˛°À˛ç∫O„ä†“‘j)|â˘í›'’.∞ˆ%. ˇˆ¶À—¶à8ﬂæ‚…•±â'ÀlFßj>\ä2ëıHÏ–4˙Öœé‹Q ©æt:>'ØÒäiNõª‡°iPGl1‰0°M‹± TsÙ˛É•F·WèxúùTÕä‘@>¨xXEê=ÏA≈zq!O‚FqAa"RìT&-˝ìÌÓLúS|áy¡|ﬂ¡7∞∫”Ûø $›UﬂWﬂW]˝ÎÂœ7ﬂÓû‹6›ò$-≥”G˝1s°Ax≤ËçÖäﬂíwΩ–3Ëj#	¨È\áÄ#w|-‹&©mB^ƒZò÷Ç«©§º†0ÄÄ–é¨O?ù5Ù§øÄ¬»Vi®P	π» .F¥¥q›¢ï õˆVÎs·ƒTH·9	u…»sî-Å©`¸ÍÌß´wì∆¥Ò≠u¥ìÔ†rQ/Xã"…]Mö#DÊ0YÔD¥]|M MÅ°òY√ñF{z@ä6&;ãóPv=.L)‚Y¬2á˜≈π¡≤/≈`2nùÏO XÀ8˙	j®qŒ≠‚√†,<ò™!À.)‘Âö•“TütÆUj≤¸√ØÔÃ^Ì.cJ≠\´êhgƒ,8ÎŸã–8⁄p
+Yè"è%zúö÷GÌ!áE¿Àj«“PÄ–1 °:0›@æCl/Ü^D@'föO;·ŸR'∏È48^ T¯ôı&˙#åòË#µ—úìN«É6
+vãâ]∂ƒÆˆ<%<1–ôVñ–1sö&©=òÉ‘Ì$sOa,%ôËvË˘0eƒ2M(Xπ7wπV<"\Ç¯˝ 'µ(Íê<%7LUIÈí£ı0¸ë1Ó,ØO,›z2:ªÓúpw\¶ë9À†±¬X={z˛"¶Ñ¨ﬂ˜üÁ7≈Ø¿µ|&oÖ,ø>LWŸø=k˛’Gˆ Ö‰A–xO—(}*:?˛~tÚ·Œıy—ò†x340075UpLN.Õ-Õ…( Ø®‘-JÕÕ/Ie–„/oÏµXRˆÚ·ÉêÈ∂?,ƒıÃLLP’ÎT2¸y“ {ËéªPGﬂ”'F}âäìï†j„„3Û2K‚„A ûÌøqn…y˝Sõ¶*Ω˘Y˛6g6€1®≤‰¸º‚íƒºíbê∫EfF9ü{>q˘p{≠˜ü˚•›ßÁPu%%ï©`E≤7\>Ë˝¡¸x√ìÙŸæ—r{5& ?≤Ut¥Ω	xµú_o€8¿ﬂ˝)∏(vÆ©7IˇÏ5∏‹!m”›¢›$hú+ÅTô±Ö íOíìx?˝á…G±ËÏΩ4∂<3˙Õp8§H™œ~˙e]ø|O≤_dv'VõjëgÉgÉg‚t]Âsô…"™‰L|ﬂà…¢Hn+Ò>_ÆíTbt0~;>ÿC·‚¸b"Œ>|öàÎÛ/gWW‚?◊‚ÙÎô∏∫Ü&øüN ÁÛão‚[ÛM˝˛·‚”˘ohD‰´*…≥RîUëdÛc†ÅÎÉdπ ãJîõ≤˘∏Z¡Ô’‡∂»ób]§´®(•®≈öÔ˙◊
+ô«Ue%Z©•&ìÊ π´<˛!Î[u˚Ω™VÔ”D6Lµ‡™»´<Œ”mÚ.…¢bsY_6ûù∆ÒzπNs¯·aSÛTõï,≈øÅË≠He6Ç å£b~∑'˛q"E^®∞‡ïõ√©89√/2]èB`îƒph?^ó—\ã°xnı¶m(n^,ƒ"/´õcßÈ.¨Up’á€õ"Z \º]g±j#qá¯Ô—x<ûNùõ8?÷‚Â±sQ‘Ì+“|ûÄKÿÿ'´(›˙à∆JU"À=¢úº<—lˆöÚ†±ÄÊˆ„UÙ=ïÁÄmÆƒF„}ï•˙çZæÀìô2}µJì™‹jVî(«Ÿ®™(^|™Tﬂ…ã≠Ü¡+YUê˜¢‘!e1h˘èîÒB∆?=≈möƒ=êçê;•2*æ‰±Ú‰=x%∑∏√Ñ#NÛLNT{l—5Mï…{î◊Ì˜=á>tõÆÀÑ:Uùì‹h]9{à”ıåk◊ VWAe’◊¸ﬁp…lÜ_ER∑mπ/\:¸|%Ö(ãe™™'`@⁄ŒB!°˜Û IÓdQ¬ù ßT√ÔãI≤î(,BUÊ3ô ~7ËTÜlÔ9uóÔ/c[>®¢‘œÛ⁄∏V˘êå9Ã• k®uÎ˚-.Ê≤Rù
+…Ê∑"_Ø∂ÖR∂˚)Xk]⁄í=&cõD’=…QuEWz„:xpø?¢hÀ≠∑—∫Z@/ö√ˆ)É>Y&w∂7›e‡ãë†0*àÿJv(ÿ¬„Î˜¨ÂjPYFZöZ¡z´ßêM2Ü:∏ŸÇa¬a‘Ãï€(I◊ÖKuÓ@±W›≤ÛûAijÓGÕâ4)u$i2RMÜPAÉ_5£*£jG‰0eRs]⁄zc^≤5}À3ECÎ˘-ê˝∆ N;{Çr!ó˘ù¥±Ÿö:*ÌTÖ¡—õÜ⁄jØéç*∫tœ*¥e∑ÀıŒÙzXﬁ∞ºLµ…„<ù·ØØÊuß åQË6AıÊ	s¨√º≠'˘lz«]îÆ[=YOøFŸ\æ€‡]z‰7äxBôCÕ|§4a˝¨Tó<{Ä÷Ì*~ö˝≠H1Z¡B≥_…&Dﬁx_ï¯#’W5¸Ê;wÚ*Üg∞ù4Ìú)Tˇ
+≤^Õéì˘¶‚ÌIóOzµ)+π—p√BÈ®u,C∫’£YG◊z§#AŒ˜”5M¬$§ŒYV¯Ù%èf|õƒÕ3í1ïjÓ®:)u-™i <ˇ&ú Ø!x£k¯ÖÃÿ©%RºPyØl¿
+ƒ"/í?±ÂhpTmQ›ﬁävZ≈í°L_¬‡}^t¯Æç÷ÖhUãrFqBnå>ÊÛvc3x∞Èaäb®Ó*™çÒûCù©t‚_ bôîÍë·1W⁄≤û«ñ]Ü±Ù≥[áÀ<´®≤fôõ`ﬁ-¢≤ÕÛDˆ∆l‡1´°‰83mM3õ	d!ÔÚÚ/v≥.H Úˇ—”:21vîwQ/‘0 ãä|8±Ìı4¿_‘ãÇı‚ ç±ﬂ◊¥í{‘jìÁÚ¡¨.ïöõﬁ˛≥‹¸[ç˘ßŸÏR "Ö≥¨≤¨ñ∫ˇWYÆ”
+>7±®ÖıêˇÉﬁIó∆4/qu»ﬁ•◊´c@˚®ñNöõtÆí	XùH[kM$ºﬂ
+5á‹jGã9ÒmŸtÿ[˜h≈ÒÅùJwÖáRjÀTVœÆ†p¬Û-~n˘=ïÑÊUˆcû¶˘=ÃÅFÍ¬πŸó∞0îD©˙´œdπG-Vñ∞(+íjÀ„É’JúΩd=æ,`mVÄaŸBôd33·◊£ΩÅZ{ÖO√T≠®/√.Xüà∑oÎ"Qøay‡|˛••,`ÈŸ|Å5Y%uàÀ≈äA-´ï⁄§^^Ëua .AéH<?úéqAs4<ÓÅ5êrØº9ò¬ïzØÏâäCµ»+rju˛D®ïX-|8U˙Û|Î§Y#¨1Év≥loV∏†î)4´Ö`ô˚Ø≈îE‚«ﬂ‡é:‹ usT{Æ>øöjIı+x6¸◊œÂP¸¨ÿ·'–™cR¨eØ ‹…
+æ”P∫ï1>¶¡[f°ï„•J“å”Xa˜xäÕ†ïvC‰ˆfÃˆ≈ÿ˘<R	∞è≠ªØ‚±7hBU‚û‹y¢wG∆ı_GCµ§ãf◊A#∑4€/„…GLhsa§≠+Õ˝Z∏Ft<y∑æΩïÖúôKF¶—zÔ(È∂hëmòQ ‹⁄ƒ∏âûë-ô±ﬁ€56˜FeÎhŸ:98ã≠Å=∂5∞ÈÍ£ZdO¸]°N4’˝UO9Q»ˇÆaY©∞´r™z8ı„”5÷Âc§˘∆z„DâC«‹ó0À·Ë-˚{ #SáÏï∞X/	ë∑x/˚„ö0kB˝˜h ÇÍı∑~êZvW@≠Ì¡ŸX±±$;,Á+L¢`a_DìòÿBl˘_r¸¸∂Q?x≈ù¸·M=—Øˆ&ÎÌ~q[«z–=+û#^á¥€a,Âí@Vÿ‚ΩÈü<V›„¬˛˝ê¶å˝ˆ
+»~{Õ¶ì≥ß∆˙Ú+ı≈∑ﬁ¸‡çc†”ÙÎ•ÎóÔâıÎÎWk´éı≠ïM-Î_H2µåx>˙πd∑YHZçÙc>ÓYæÄR‰Ë{h6§™r⁄olr6Yl[G⁄bÑ’—˜∞Ωàjaµç…í—ÄZaO´Óq5Ω≥…fè”ŸeAÈ†ÓH[“Ä!›—ÔDıÌ6+K¯ö+l_˜/VΩìØ	•ÕMU<jx‡√•≥sÀ¬”ıt¨yÍYÒ\·`õç 8°Nè∞¥4k·>-%ãêΩæè∑…br∂Ä%Ω›Ã¬”Aƒ»ZÊÄƒh{®Q’/>WÍkwhaá∏â^R3GUXøºj)Y√r®e∆ÛîK¢ﬁoÌ	o£ÌA—{àfc[Ôø≥Ò§ı§•aÉPTZ6<Ë&Ω˘lÈpõáuÄñl}sî∂%€—Ô˜ÌAñ∞YÒ©`Õ©xÿød€{>ñß©U¸ÄL{ë≤i‰-U@"∂!Û–™ƒÌÊ~_DGcgH«∆vL˜x€≤tÑp≈-`¿ÿ‡Ë⁄›∆ku˜∏KK›∑¥mÓh}:{§úïﬁçÕÍoGk6a˘hôi´X»ÄZ”6‚ën)ÔZøÈ∏,5MP™`ôRîöàõ$µ‰Ï‘E[qá‹ãœùhYÇ„NÏt:‚Âq!Õπú^»FzGT£ﬂ—;Â”‘”Ÿ	◊≥‚A€ƒ`ó
+¡ iñú&u[≈Ç§u€à«›$6˛Öu//Ju¨7∆Ãâ•>æ÷n¸æœz˚çÌ°ï=≈∫A«G⁄‚%éæáÌEÖÒKFg[VÿÇÃ∂¨∫·Úx⁄ÁºX*Ø∂äeZ€à!ƒÂ¶] ·ú*Î¡Iv¢§&ùÛk!§é⁄”xCΩ®ΩSs,5ÕNıdó¥€YÍÄ<Âj/cï¥fØ'ØØ∏3±oÍQÊâ™I’ûó‰üºËï]9âënB=©iŒ≤—§UÄ*X∫Ä@M∂Œ
+ „‹£Ät¬ÂH[∫Äâñ£Ô°5™óúï{ íç"Ö$Ú;a˝A€á7{∞∂Uv¬mÒàÌ–ŒŒ±∫éäˆ‡ÔR›…è.cª˘c6áT{ª„i>¡œñÁLgﬁÎm"c†>=Hª6µ—óºeai±#Ú5†÷®WG`êÛœ¯ˆ eıvf-ı áì5ﬁ—búBˆH≤®€¨%|KôA#8t⁄Û»¨ÙqéS≥N<“qÜ<öﬁh}aüÜòÛ“¨+¥A-ÎI@s0v<G¨lÕ·M·+Y¸ÄÜÕxÙ=õA-õŸgH,}¿Ãöö0‰^π·èõ˜»^—≤$
+o 0cî·πpKÆh+·È¬ÍY?2Üµ‰π—3i¸SÙ=≈W≤é4ào∆ÛbKchÍÏ;ú^Ô^À?Åπ∂ä}]ˇgAÈ√Y-i˙d≠k‡ºŒhﬁ(ËbdwB1⁄è√|fAËIô˙l!fF®i lF±'[·põyÇ•¢Ì‰ä[∏Ä∆rFØ≈Ëk,\©Ç%Ëù‘ÑaÎY&uœ‘/NÙ‡u≈w¢uÑ≤jOYJöÉZ–Ú$°V5d[≤O±@4˝PŒÚ‰j/·0-i=ä·HÔ„Ëw#¡ÛBÛrMè»8“;!9˙è"ô˜xX&ö>`”à[®Ä$rål
+ê√ë∂¨ÈóPÍˇ±È:Éˇg"üg…ü¶œR¬´≠3°_5Åw‡ı∆æ^Ø8Ô"`”¿ÀˇGU$zΩ⁄ˆxÏΩmè€8≤6¸=øBò¡†;z˝ûŒΩ»á$õ›L&	“=ÿ˚∆``xlu¢∑Ìµ‘yô≈˛˜ßX|+æIî,∑Ì6{N‹Iï®bÒ‚U≈‚èè~ÃûﬂU≥è˘4_´|ú˝˘=ª˛¥(n™ÏÂÏv^LÚE∂t¯ÙËÒ£°ﬂﬂeoﬂ]gØ˛˛˙:˚ÌÌõWWWŸˇ{˜[ˆ¸√´ÏÍ7¯◊ˇÛ¸Ø¸Úˆ›ø≤…øÿ˝øø{˝ˆüÿH6õW≈lZfeµ(¶ˇO6ˇ◊›,f∑YÖ?2∑ÛŸ¢ ÆØøœÛÉÏ˙◊º,ásÒ◊´o£Ç;œÁÛI1≤f’e—`uÀL¥Ùˇ’=Â˝b6Ç'ÃF°j1úñ(ÜíF^1 Õ≥j6öM‰£Æ_”·‚;4äóAH˘ÛQµ¯˛e}aªˆÕ∞¨˛ƒÂ¯ûXA]Ãûeog”¸—£G£…∞,≥◊7√QŒäåÛõl2˚XL˜À|rsêÕ°áG≈|89‡óAÜyæ®äº|ÃägŸ?¸Äˇæ.Ü∑yï/J~=˚Y◊≈p÷-ıÁ ∆#∏¬é«/·˚Bœ”JÇu≤j¯Á$O:»F™»KˆÏb≥LÿåîG5&/xö¨Ú
+î¶*Éñx{Yôx+a1™j8˙Ù:~XÕaYÚ™Ç±rêï#¯ÄØæ£JﬁúÏ7ﬁhP∆—ß|ÙYä_ˆ∆Z]ø≠U÷I>\ºôÅ-ò-^BœÊÅ.]Í≥ ACï~4ÅyÕ‘;ƒÉlö≈\ˇo&wÂ'6BÂàºû]ÂïyåŸ‰nºÙ∏†ñﬂ/ˇ∞Ñ]¢ÑïÊã·®™ÔÅ≤.™≥ØY>„øÖ–¸Ú ÚuXTK}∞TÚ9ÚE¯”‰_ÍôÚÇ—Ï˘·∑NG˘ÑÕçÆ0€æıRÚ{µkë√¸\ﬂπ_¿xÉH`&ÿX[3ﬂRÇ@Göm ˛b-ªhúO`©u)°|Ω√	˙TcÃ-Õ[JÜzÛIòc¢ÆS`H`ôøãeeSø*|Ω4rÈ°∫˙ÅY;Ù>Ê≥Î0eˇÁbv7}Î•zœ˜Ì‡¡rÚÕ¶·¿®?»§e·ß’•ƒE£M Òá?.»˚ÎåÜ†ò√ªÍ\˝âÒ◊Î)L6eÒ∞ô¥ŒØ∫∫Ïã‡C’à·h¸≠%Øöfõ
+S˜Ú®◊¶za©◊	®I†º~„%ñz6ËÑj(ÿ|≠∂$˙ËPX\aA9ò~á≈‰në„o¿á◊≈Úx\µ.?®~Üº"û‘"ı¶J=fŸ~U≈ô%∑‚ÜıiÛ\üÍ∞V•â1&¶6œ ©‰B´ˆUÙ2Ìﬁ{õ/`	œ§´[B¨w∂û›¿ßÕ˜˛9f”{‰"øù}…µ≠Ñ^W/ı⁄†ñ∫•†^r©‰p ƒÊE2Õ.Ω$ñÌ°\ i√öòKIßö∞ë´´ÔÀvûlß¶Î¶¿¢xåÂl2∆´º√Ër∞•L¥!ŸS¥π†h`Á£–€Aˆ¡]Kπ*√‹¡Á„≠‘â”Ó€d_Üìª•◊S∆'1±—∞îåÅ˙0ú~Ã_|GqkL&êíπ)h∞lb{Ú´VÉ¢‚xı&≤{õIëØ«øÁ‘H¥yoﬂ\<|œ˚˙*_¿Úó∂”qâ€<æ≤®Ï<@ÏœÅN¯í_çÄlæ◊'j*„æû{ñÊúõ‚„pûá“¶c}_zÚÍ{YÂ∑´|U£◊ñïûO*bÈbÕ'“r¥y®û¨‘=0ÃıÏf˘åÁ6∫*/+Ùºô«¶˛£ÉÉœ[√íπ~ÿÔñù†⁄êˆL∑Ï∂\ÕßÛ*Âø¡®7•∫É+î™m)´.e=.ô†,£OÃ∏3)ûÉT≥EÒC˜2.ì[óXB.≥°ŸpngæWŒ◊Ÿ¬˙à\4Fó≥{K%õãÉD©«˚’ÓAå1∞˙5BtÌÅÄ…ã—å^	‡@ÿŸ˜˘‚∂(ÔÏÌj∏€ı¡ÃxAı‡ó˛»Ñ@S\/¬´ÀâÇ≠†,Mr}ñ|
+™kIyXı`◊Äÿ1åÂPc¬∞]mTƒ7˘óŸÁ|›ΩŒ•ÿ¿é°M|1¨Fü¿ÑXs¨¢nÛ)VÑf¥˘ 0TrÄàfÇ
+ %⁄a`¥ºÕø…@Öí˜PsàÇ¡wúBõØ¶Î!:ª◊Ü1=»>∑>⁄Á†‰‡ .q)¢5•7·ÔÊc Tœß„0˜wP¡…:Yö“¡F¬oâ£‚_F¸Â E^Z÷FP
+ﬁ‚˘_Qçâ{{^õÜÔYˇ∂ËÒ3”¨0§}ü’E51˙èWX∫aXƒÅ˜Í√ºB‚≈Ïks´P(ÿÕ–‰?fì…Ï´ˆﬁ}Œø*ÄxÑÊñ°®ÏeV¡ÛáırR¿öa√±∞Y5”¢ƒª ¯!Ãc∆˛y∆¢∏ƒÛY¿÷· ÔBxˇ¡_x[‹öYQf”YÖa`"bÀ™Éu±o´Ãˇ]å°≠#¶Ö!BB®{ãCYJpÂ¯„kå≤/ÚÍn1ÂØŒ¨/¢⁄c˘§)÷4[ì5Dºëû=DÖaÖ/r6∑ábÌô—Üá/üøy˛R¸BÿèèQ∏·‚c	=äUÏè}}˝P	%‘oUÌ+ΩW¡?≤}EE)ÒC´ÚßÑ^‰’t,‰†%0éÒêõ’{§GYŸÉLË‚˛ÕcÙnY§«A∂‡Ô2ÚQ¡~éçæ„bÅÜbµÏŸ3#dÛ’ˇ}˘Í˝ıÎwo•æ~ÉΩ°õB¸,˚ÜØéOÂœ»BÇËwœ2?,ÛÏõP£ÚnR…N,rˆßxˇ#§¿ÎÁ¿Îä ªãıçL°≈fALWü›ç>ùx+„{à∫Xäø^ˆ˜ü˜Í·ØØØÆ w·’’ooÆ≤P—ÒõèˇOv7˝<ù}ùä◊˘·Òﬂ‰€ÿxN¸8hLÒΩàÔ‘l*√≤/fKj§xû¬GL‹≥∏ se¬!Ï3=∆£€ô £™cä¯wÜ
+_õ´C€a\®ﬂ˙∂ˆ’© ](Ëπ™´¨ÿRo)fÆo±åóﬁXÀueπéQU∫€<≥Êi‘3OÒô|2⁄≈}ÔU◊Z" j6ƒÒ–p°¿a{Òq¯‚[¯÷⁄ºº-€0Ï¢¬µS‚ÒXk Ä∑5€'ÆáÏûh/÷‘Ò÷Zõ9^≠'«E´∆`W†i\Ω!„Ô±CFL|8éczÜ^mº¬ïå¬T∫ÔÉòSBè˝∞ˆyÿÜƒ¨oYÛf–§Xèà≥-F€-åQ∑/+√ﬂÇô˛K€eƒÓ‡æ}c’»xœù±B∆[ØKmü)⁄ÙÌ]⁄$$mmöÌò&*P®WSÂF;ìÂo„·ö.ˇ˚Óä	Ûø˝∂õ2ŒèIl4∫œ=úƒ∫8èµ·]q≠‰
+jôßEøı0< Az»yZK;a”ìâX1RqﬁzgF∫ÛΩ6bÈd’›€ıL-Üz{€T,≥€€ZHëùÂ∂yQè˜€ïeÑàZji—⁄⁄")yOFàÓAÄ’˝SØ©–˘wÒ_}±M≈rb‡|(`]Ò‚≠‚tõ¸}0I˙Ïé]T∫≥—‰§€xÃömÿl≥ÊY~ÜjlôÔõ¥Åi˙éÆô÷õ†!(¬NÙ&n+%v6À±m÷≤ÀÙV»2G?7ŒìG∂4≈§fO∆XæòF˘SõPﬁÀpãˇ–7XÀ⁄¬"*‘o};`ºY  ®†2‹ãÕ%]∂3VóºÛ∂Ø6MÎŸ∆ÓZ÷Ûì¡{f?’∂iŒ*’Æ`Y+˚∂ﬂbEÆQ≠∆Z⁄"´vOˆh’+TKÍù1	÷{'≥¿”ﬂÒ‡ˆÎ⁄T`f^•{Õ’D,	F@sAm#ª˛|È§lDZ∞¨
+π„7(Å'ƒ¡›zK£+ˆd\Ãn(b^– ÜÖR¬mï;Î^êä~›ù±J˙ïìA‚Èû2≤i√Bhù–≤¶	°w¸&$ìêv⁄R±'c±b$Bﬁï·N^9w:‹Å 0ˆX·–rY.3Ω-Éh•s#k{7&ë2îœ64'o√o.∞≤œZtyk¥[|cÖ/*[ã€≈z0Åz2Ú£àê?5∫“*˜brH∑Uz∏;H¥>$É√Œ$7’ÿÉ
+„öï’∂+¥öiXË?qS∑6ò“d;õB*ˆdTxãêÙ¨ä˙≠Õ ä≠yü],‰ïì˝‡ˆ©˝zæDNx∞ „øBÿ;-îO¡Ö0Db◊∆dµ®“Ñio»çêπ	<!ä:—Õ∑3=∫^OñGæDK8≥è~ı]1R˙ç∑›FôHÄhÓ%á∏∆$Ócm´¡·ñÔmF'≥[—¥Ó}ø…à#Jú÷⁄YßzOÜb≈ƒ{WπÛ‚´Î=lãøü≠]=lu∫¥yõ(Ty-"Æ¯Ó °∂â–Å)<UÓZ…@÷$¿=ÿ0˛·è¥qrb{>˚føºc‡Ï~W◊;hà√è˚N≠Ìû%cOÜè~@IÙOÏNÙ ·◊bäm ”óWo4≠wﬁ!´iΩ˘éõÕ%¢iñœ`‚é›(ã˚ÎNùèb QÒÍÆ’f˘^€
+¥Î‚9é9_a◊7€y˛÷ÊùWÎ…™c?É¡∆µ¡Æ]„Mu<é\1´∫ï† n®‚Pü˛©kØ~“0æ˛ÉwÄu™≥íHı≠A÷Îû"¯GàöêÜ‘IÿX|)ÿÌE’ˆsm˚&Ïöé≈µ¯t4E`5◊⁄òZı{≤™´7]ñ‹;Ñw≠7ﬂqº€M`ıiîm2RŸ¢«£_nÂ9uàºÊJàR'Vˆ≠¯E]«Nµ|Ωf¥«lm†xµûÏíÍK ]Í˜}".£Wwqâœ˜W?¶ÜwH≥ÖQßn„ôëzçkøÜk£T	ˇ°ó8:±=Ù¡®“¢[LªeﬂıÉ´»É6Löı¨vÜÕ™‹ìyS≠ÇySøµy”Á}¬}˝á. 	±ÿA£pW¸“∑VåËî¥Ü∂?xiΩˆj∞‹r9∞⁄l»3Wñ›7BÛnAPXÚë!º‘Í,Í†≤ª¯ä
+ScΩÏ6ZÕg§⁄Ω]î-¬&ªÿ!¨x?6Ë^ÏÌ€±!¸Æf-g?Ó'ÉX“ﬂπ–8Ó¯©˙¨i¥
+à<⁄ı‰A%B;Ü∑Æ€ntÎz±É{≈√S¥+Ñç~„’LÓùXÁV2˙Ωöó2¨¨Ù“Üv¡,5ãªì∂˘H{⁄ÆªZNw¯Í{dìù<ÒÉYµ‘~<´™±C∫íá1¨WøÔÿõÇ˜€Éüíçóﬁ†qo‚Û˚â„2üŸf5—ìïR&ŒP¡Q≈%úŒSLW{t6Œ¯
+X–á∂0V¥ökÆË›ei´Ω…"ï∑«h°w	´ê◊ﬁq√’ì˘!⁄lÄnÛ≈«órAÎ„ŸîÀwöH‘˛»í6€Ö	mSÂëÅ;§oçÍ¶…2n˘Ìïß˝®]6¥ÈvÊã÷Ï…v’Ü#ÜVº0£Ôπ+ÊéæÛjl›ˆ1'≥õõI1Â&(@ΩˆºR3ûhõT5
+õÊ√∏Â7qÎ3⁄P;cAkˆd,V<Ï©ƒª2ÏÈ;ßaœ˜¸Œ¶˜=Í…=)kçyrg©!Ø€i9‚u≈-Z‡ùÔ˙ï”pÁ√}ëﬂŒæ‰zeòÈÈA≠KÕ˙‡e)Z%‡fud≤ÕÇ!çµ¨p*õv¬πÌ7∆¢v√Ì¨á]ª'¢ª_˝«ΩQæˆkÌä°±ﬂ{€≠çÈSÂo'…‘†≈(`˜,Ÿ[.k7d{®Ωr;lYkCîåÆë≠ëÄ'¸ŸÎÎ%}VDµ≤!Œ3ZXŸx;"ÎˆdE‰kÄë?µ·Ω«‚ƒÓ˜†DÎ˚O TÏ·Ê83ﬂz€Õ !„ÃVﬁ+HñäBﬂÉVI!Û}Yk$€©µ?¶HÆíç¯çèY€gÅÃ!3§û“¬¸-w±AF="˘"`m‰OmàVÃèÑulGåé˘A∑<ºÃ4SH≥Å/h⁄çŸdåW9å°áWµ4¥!TY¿/¥π†—Ç	ÎA[2èsçàÆl}«05çG⁄’p[õ°*∆⁄
+*+˙ß6
+¥è°˝SZπÂPÔ∂;Îı ªãQLt”=6`DÂF;»>.fwÛ•◊YºïÄErÖqQç[`ÊÂ˝ΩnM”(π˜”T…ÿ5Î5Ò·BN´ÌÏíS=÷:)q¡Í®ﬂ⁄‰.Ç{§≥Ô„‹	Á}v≈"9/æªv…ƒ>–1qﬁÛ√6õNp<Ãpró∑@Ê Ùc x¯SF◊Ê»Ê§tÆÒ1[plèy;dzÏ«D°"ªã[õ C∂û,ê|∞AÚß6O¯1‡é˛(˜dúå7›!€dº˜∂õ&À¿Ã'Eıa8˝òø¯éØYœ∂`≈zLòÄÌ°ZÉÖ1w˘À9ƒ}[zuç#"6œ_ô$àı5fŸœ„Bf«yhú›qü–“Ù∏Ùd}Ö¿¿ËÑF}"∏•~k≥¥‚ÖöÔõÒ/Ú‡)œ´Ø∆
+u⁄§dÆ§v`≥ÇÁs4GWlÖÙÍÏ∞∫ßùUÙÅ∂°‰dîci”“;~3(!ÏÇè¥”Œÿëä=πõ+"Æ %Ú dûzÿ@^,r†øˇ:úãÔéÉØÕÇÃ?( oì∑Êá5§òg¯Üdä≤X∑√à≈z±ˆ>F$ÌÑè¥><¿Òà_≤y8ŒãÈ«k6˜VW˘ô•É∂óx±ÕËÑµä®ÖÉ–¨ŒÂÏ+ûÖ’p–!ÛÍ7áÆs€ú~˘F≤›TªÒl◊é’¢≥`Õ@ªÌ>[‚]ôáÌ˜^Õ‡øø=3&cŸÅüè™‚K~5Nm,m947⁄ÒZÅ·l=œ7ò m’1G¥u≥˚x6j7öÕ∫õ?ñMywe$õoΩöqº5k˛ÄºŸüÕ‡Aï9ªù¡Í@p¸ÍÑ˜©ÌÏï7`}hëliÆ£%"-lë="RÔúU"ÔûlSôg◊œÁ¿…èÜÃNº˙6 ÁÏ«æ˜Í·ØØØÆ^ø˝Á‡√´´ﬂﬁ\d?¯F}îÖ∫Ç∞oÿ"tS|º[‡£©Öj≥≤ëx	óËtô‹÷Îo« πm$$F!¬D¢ÔA≠Ìé#G¨›Y1S·{π2.ÓgYI<ÎéßW„åÀ˜≤ oWh^<Ì7O◊ƒx
+u22n;ÌÕå€∆W∏]25Ó€'$”íπr˚5 ‹P¶÷Xi-çcÃñLåYÿ1.ÊÌ.f≈h°µA1joé)1ƒ⁄!#bº˜ôè~„Ìö1ﬂâıﬁØ*C€f;’]§XODâzñÂn±Jõc€∫IFˆÅä√å[üò-µ·f›ÿÒ-_-Ú'æ˙}xZLâweËõoΩöÅø./DEøØ√2îõ«: QŸ‰j14≥9Æ\â`j˘pklS°ÕÅMÔxGµl1.tSwNªëMƒËeXØ-\}ﬁô¬&>‹ù˝Ù√≠ÑåX◊8ØÚ≤z9ñÂõŸp,∑l#v˘-lΩ=»ÜÂı˜yŒ~∑ú∫U8Ra¿Îñä¥Lçër4™[p|Øf¶0ÔÜ@IÍy[î.ÃE≠∂3F’Xì†DÖ©^˝∆Œ¿π^w1‹◊Ë+f/çw⁄,`ºÙj†¿.ÒïFw6/:ÿ°‡˘¥bÆó¸7àÊ0Ÿ\Q¯Ω»€n¡e’qË•4ÇW\ÛÂH",ò#÷wåóS›¥_Œm√Ñ9œà3võÌò];÷Ü1Y¡<©æEÀ%–!ÙÆ^ƒ»Ææèeå˝2ªbºÏ˜NˆkY
+‘Ó—f6˙ƒv◊˝√‚9≥Ÿ¢¯}π	zÄ„ äQ¢%$SCé°1£°ÄIJfò6≥);€I∞”æãyÏúı¿([jøùÕµ≤îÌ3_á!7˜€‹áΩ‹Æÿ¬–˚Ø∆&ÆkŸ«ﬂó0ìÛVz_gk»,‡&qo	3#õ®50Æ0Ü}ëm¯-ã[ŸgX‹Rª¢‘¬¢8w1(N#KŸ˘Iâ/à›6ƒyü›2!ŒÎ?0≤»a±•^“ª‚ZΩÂ∞Ñà≥V%ÀRXwó∑fÉ--ÉYy{-Ç˘;c	Ã◊~X`˛°öÒﬂ/∏úä˘ 2∆m,`4«µyœ’BZv˝0ÃÙç¥…F’•∆ÒäÈ[C–]®∆K?¨a
+¡ƒ1¨B√’ˇ@gÿ:‹ßøû9ä˝e:éfocÌFµ∑âM›^Åweî{_~5£}óú5ﬁnmf<?Bz©ääæœ∑EY≤›2ŒXÓv5OÃg’ÃÉ_b™ƒ√±:b‹≤ÔØfY™o◊Ä>ºèmiØ|R-eØXÔ2éAvÚ}ﬁéÿ#Ê˝Ñ*(ø/∆ùæµ
+ÜäÂıX⁄>`+8¬#åÖ-ïa+®<>ìaWˆXªà«“ßDqîæÓÏ`6,—ñ≤¯`6_Ï*¥k3&÷ªÌî-±ﬁ}5xh]ééO√rΩ√'Äa4òŒÚÒ˘Íö6√W¬c2Q∂¬”`;S·i`)K±ì‡yá]±ûW_çAÿ•íßSõóGP…≤ÃæµN†˜Å<2∂åJÉ≥∫CÚxZp,Zß◊nX;πœmm÷,±ñ≤jÿQõÅ‹ûŸ![g”ï,£vÃ‘Y}⁄lÈ&êY9íåÄ∑6¨èÎ7≤⁄EK@ZVQ”$Y7	æäÛôı€Ÿ≥n¨ÕY±ã»jWÃÖ˘÷	-#kˆg≥ôX‰_füÛıÆÊ2 H/Ëì c®g⁄ô@!bod p¸zŒﬂf;‰o#÷±(B@:Ïüı=˛◊ÿÎÂ˚’X±uë=¸-¸±˛Uì_,√f‡z¿ÔlÚ◊ˆYéN/ﬁ∞nÚ>Ωã˘∞Ñ[ z`om∆Í…€?ªeSÏ/ªí5‘∫L #¯^´—'ñozjÔ-DU‰õ§gòÓ±ÌÓB’ Né‡ÅÕ‡üÓö∆#è0$™°ŸD`≠„i¬¥&ûÒ<)ä[v€mgH‹˙±VDI,ç˚bçà.áõ¥ÛÔ√ìÌæ“Æÿ˜ÕWÉEvâ|q˚¥yU≈Îlêmì¢t3k≤∂œ¢…{=3—d;&™>fˆ≠‡≈n>c‘$√µ,dtg≥Õó≈€¸[%¶ í„≤fÆX +’®hã˘¸W¯h”æ®∫∞}‡ 3jX`â™Ì,à®‰ÿÒd 2Ù]Ô»ò=‡«ø¸ +YÎ‹3dÈ!M§ËéÊë;Öa˚jZ-‰AÊÊPëÀO9™œ≤é,LEö≠Ω∫ú9~ıuéL±F∞™‹n´j4äïLª≤
+Q/º„s∏yÜÔiVîŸtVeog”ú/Ì38∫ÄiûºCF«úÚ/{œ∏à=˘B}Ñ8˚Òã9Ôdü€M˝¿±|` &	4œmkÿx1◊Ñ%ã∞ ø¥∑ø¥±ü◊æ8 :·–É¯≤…ÄP”pˇ‰óf„1öÃJ<5P≥∏ÊD/ÅEk¸a∂L!é|teL€a‹ÍÄ@h˝vfÑ÷lcMV`B≈⁄(Bﬂy5∆§≠Ö/~¡8Œo≤ª˘~<üéˇ1π+?âØ‚ít£|2Y⁄ÇçÊhKéêX[è>´ñ9˛¨õ|Üéruò-∂ìf]gT¢\0ô„ø¯ñ8°7∏8∞G°ñÓŸ˚ÄÊ´Ï H6ﬂzUc<í«”,+ÜZbB¸ìà™£O'X”¥ú´˚◊Nù≥Ú¨*D‰“F |q°,´ÜÓ@e5–›®iZ„V»`”Q&Ä6◊Œ –ö=&6å~’•˜1¯ÈkÏ –ßÔºöÅø49xèvcyjÄˆg3¿ÁÜWËBT»_	Hxq¥w@ËiRÆ	J Ÿ(ûb∂/Q-¡màY. t'¥3ºéc.¯”aËì˜√¡ÄÄ√«Çπ,Õ¨ëŸ˝ºA—~7¸D∏÷‚˜LÛ ´Ös>aΩvﬂ´ƒ
+|‘Zëzäœ]!π^M«˚nâ
+“îá÷ãìŒ‡ ¯‡πﬁı+qÀ¥]>ı∏mÒ/ä∑Ñ“s["GÜá¥‡Âpl»R®Th§pΩ)öZ£àñ0«Ω√À)§π/Úè≈tè‘n7ÆH≈ç]D¶ù9Z!WÉq÷5“ ë—áŸ◊,ª¯ñãŸ◊Êi
+
+∆mê5Ö≈úòZ gÙgZ†ÜAF™∂d§¢3»‡È %‰˚ﬁ«"ÇH≥+√ãºÚjÜWß%DQ‰≈ö±<˛«l2ô}-¶≈óˇúá-√E’<$°(é5ñ—*Ñáß~Ün=8JuagòÍ[|úÍ÷¢?}€÷√U=€Ø åWŸ8^Yw¿5’+˜4àïå;4ä’;?∏a¨ﬁ¨n?¬≥…28*pîóÂl±ˇ˙f8Çt]◊Í
+écÊ[äiQB9‡(îÒ$_àaŒ':qTW¸¬Q Ô¡πAÏøÁp˚?ˇıﬁ˘˝‰	¯ä(EÕÅ&”Ìˇa8øúMKX`”*Pﬂ(x>îπöOä™∑¡ÔáÍW’pÙÈ5–Æ√j∂5b
+¥4˙îè>ÀÜ‡›n&≈((ñøp®ÂI>\∞Ω¸ ·Kê6à9≤À€ÉîkñÊ-ÿê,jav;é™⁄6HëP+√)&/yAHSí∆*j7’ä§K⁄Áìº™ÌR¢∂ç≥Ø!ï‰M∞ÅÚoÛŸ¢∂sIâ@∏dØÎ] –Ãûò?¢®æˇs1ªõá^«)nOéé´º™ Åæ74h∑¯Îtd∏!~?\{,Ï˝Æ‡P¥pCV¡pãµ÷^≠÷∑ÏÀˇΩ ä	∆˙˜Ä8V©Ä,ºTù
+êÅ6X6l!‘3∫@MÚk÷5¢ ‘¥£'å∫ñH©@[∑˘‚#‰A˚LãZô›ÄÖØ∑£¥H®ïic#∫D†~d∂~ÔÄ⁄ÿ≈j[ìﬂ£∂-Y®∂%:rBÕE3J€ú¬.√:≠^‰™D†8w8 ≤9Â¬Ì¢˙ö3äÖZcpÈíﬂ±|PIK∑d†ÕäMˆØæ¡hçR¢Æç◊c¿ÉÅ˜√&∞@†Ö9ÿ|˛FW˘‚KB[v±@k`Küè™‚üÖ^À,‘‘íÜ"çÌë¢·VØä*gH∞¯x2åpÿ¥`≠iı{YÂ∑±Ì∫Ö√-”èS”F±@k|Dãôµ~ÿÀBÅñ`ÿ»≈#%m'ﬂZ1 ⁄a«“#qMŸ≈≠ÖN≈¥*^€∫Jˆ^úU€∏S:‘∂yO®M≥T†-„îê@KFô@;0à‹#9ÌyÀÜ⁄ı•µÎ+[◊.•˜*w]≥V—@´∞i»NÊh‘S2‹¶ıpìV¡@ãfñ™@kf°@K<UH‰+˚◊∂lΩO@To¬í@ª<˙Ç&ø4Í¨mÒäGH◊6& ⁄Œ-àªÅ∫,\˜†j´˚5ı©©˚K†z
+^ùD®Z·q27 ÜY(–ç≠	¥CãZ·è
+‘Á75qY®à˜ıà«5Põî¥V„]mê·6nDëBsNV
+™≥Ä?+/	ˇæsü-
+≤Í˚˛ôˇª?Œ¬45˛®Œ·«ú;”πKBX%‹≥UL°;≈L<P0wAd¢çÚs1ﬂøæÜÊØÆ?¸ˆÚö∑!oìGËHì,˚2¥ŸÂı€€_ﬁæ˚◊€¡ØØÆˇÁ›ﬂ≤Ωﬂ¶üß≥Ø”ÏÊn
+Xx6Õ~*˜≤ü2|€«RÏáC&0^ìw…µ∏Ü≤ø˙ø/_Ωø~˝Ó≠Ï$¸L (ØæœªT\t€•Ô∆Ôö4˛'B_ŸÔ|R™ΩpvˇŒ‰˚C|R¸dº≥ÂóE1Ñ„˜zqó[ ¿˘Áö˙¸2_|$´_˚n˚®%B'òJQÖ—oÃ√cTKF¥ÏÕïÍ"6ÙHw!l*GΩ¸˚!ä±œùJãb:*Ê√	úM2Ú[ÔW≈ øçÚyï=çÓnÔ&≥´|tA-ﬂ_·e¶√2cûˇÎ˘xÑ≈±#›Ø…É†¯¡≈@Â√´˜o˛ü°$‚≈PÕ®û∏ÌÍ>ÛÈ√ºb†'@Ï«4*ıÚQÕ;~\£˛ëÒ{ã\±U˙[¥S¯¡G AÚrËù›Ò~tÁc{>ˆ±¯ÿ<nΩ?µ-!Nz;˜Ú›tÏtÍËTƒwº∫Z"¥œË≥÷®Öú∏m°ÅºB_⁄'ZiûiE†”Ñ∏⁄rî¨DÔô°Wıﬂ≤µr9⁄–lãb’s9Ω‚]¥>ù2ºä—äe‘ÍGªÃ&#UÃ®‘lÃÄ§a>°ÖÂ\.b;IÏ«æG≈´Àhù—kkS=ø˚9V˝µ{Q≈@”q*ÈØ‹£j:ñ,Z%Î™Ÿ ßGˇ;ØO±ÏÑhù≤+ˆ£NN´ëöd◊´Q¢^ßŒw∂%Z„'ñ¡!ÒﬂV÷ËÈ£™Êbø¶¨PÛ≈ƒ4ÕøÚ±™a8“&‚6¨JD®¿5¨µÄc+5}lƒ‰n¸pÅ∫ò≠±ì∏G—±äg¥&–˛Y˝ZH&ÈR_‘ë¿•h'u˙—q⁄`§ñì*Õz^V≤
+lù–‡|:÷Ä+£·JqìÄØ√¢2,^#Ûpos§–L)ê£ñK¿6™Î3ºV\¥rZı˙QPª—H%µ™’(Íjô’9Î”4t‹¢âèV2]•˝"ÌE™ñÆQ£U¬§AÙ	;§,ÜI\dŒØ÷9¶$⁄¶Ic¥/+ÃZ›Ñªåe”Ω∂6u#1µ±ÍF™Ù¢n¥Ω8u#5j‘m≥’i|-Èó5+ yÓùœ{ƒA*√Ô Mπ‘¨FèÍÑÕµ—&î∏ô±ıA∑]U4÷ek”3Ük∏Hï^4ç∂ßj§Fç·íÎ‹ä ÈÜ~Òr»Ÿ”zrt¶◊f>LLäç”Î3#Èßµ)ÆºZ·0]£ı"Õ≈ióÆ–¨\uk–‡:”Qñ÷Í∂“s˙µ◊¶+[cFµ«ö$ßb/ö„∂R ~˝0·4T£XÜïí∆°ª∆‘€πf+TÁù÷©5lƒ∂ü…<t-‘∆™ŸóﬁÿÕvW´•ÕÛ]!˙ÇDa†´“´XAC“⁄$9*⁄¨[b¨W—%¶?PQ´˜÷©£|_’‰˙“H—ZwEÚ7b{∂s@“Æ÷ÙàæûÇw°ÑM/üQﬁH\uﬂPÿz%πGmï&98rñSXﬁÀÎ‘SÏi£◊Ba≠ö}iÆ›lw∂Z™±•ÜÓ…OÓò∏hµ√©äfKY7[/µN’[,êKƒUZ·ÆaÊôWËKQDk›ıC»ﬂh‚náﬂxQCMÍ?r≥Æ‘}d˛∏µ}[kªv¨M∞™ıÚùÌ6C_€å&¥j’å|â¢‰6vÒ˜Õ∞ò‹-r†ƒª.¨h÷e5@ ¢†ΩiûZ¨Çì‘˛m´+◊¨ìÿÂÌÙ´Ù®ãºΩ6z»Ön43™ß]3[h62ñÇ8SZÛ\dµT±fe<˛‚ÿKkS/ù"Vªtç^îã4gËˇ#»5Ëjƒ»q
+ˆ∑Æ≥÷Óñãµhóì[UÍ≠”uãFø∑ÿ C≈"_AÃï‹#akiÙÉ„È«6éº \]b`l≠∫¶Sç¥“6R≠7}£m.°q§ô∂:ÁÃ—∫VØ)ÕìI≠I"o¥6]°Ytb'Zß-1©à	xiïuê`6˘c!ı¥”÷¶q4„R¨∆—:Ωhú—`ú∆—*5∑{ìÌòıiïN¡≠T∫J?:E⁄ãT)]#iîﬁ€ˇ√L˜À⁄ N≈´UvΩ^TÀi4NøÏj5J&& ë⁄œÏµc›ÅT#¸_KŸØπfùëÎ´v#kı®/™…6⁄"+5ÎJéX€	ªÉ˚Eπˆ…n[≥Ó·zE8∑‘YÛ,ïJù£ÇøÅQµG-4€m£äFÕf}øæoùÂ2ﬁsç
+4Öu(KºÂRUzR›^¨¢®ÆÇÃ&c|ù∑z£ ›;Ë’ìÂÈ)˛»P‰eÛ4gÒœŒî€LOâPê ëæÑÑ$o]õÆÇs™[ ùS±Ωu[ç”^ßû´√ï$S@˚àyæΩ™ÎhJ4À’8£:∑
+f’È™uÍé¨∂≥,ºÅQØ/Õ3çV<£Z≥ﬁ……U®·ó·‰n7bÈVªÛ◊ß=nBËÿŸ∂t´ˆ£CûvCjƒØùsõU≤~î¡r˛»iü∂Ös?√⁄¥¥“…»cµìTÈE+i{Ü66® ©W£z|ö“»zøÊjoı	∞F_Ä7◊˙pπuHLcùµu∑ù“>∂”ÌzΩtΩ”®ÒàßﬁtäŸ’<†ƒ¥˛õáÉC—~ßµ)Ñsí√b’√¨’ãrXMÜT£¡Nö≠<M1ﬂh˝zBŒüh≠-§nø:C^VsH[J»{≠SãúÛFZhëS∑/-rÓÆEN[Dã∂hÜª„º…Zı∆=O¶çÊ∏µ{”O”Khè€⁄ˆÍè˚.Î‘†k∂¸´¯	P—·É0åz}içŸ®°/¸è aK‰®Gt⁄5◊ˆ1∏kÆ-’h÷ÍÂCXMü!∏1+ëÓ,¢$∑»ÿõØ¥6Ω >≥≠Rê*Ωhm/NHç∞.l/¡,?»⁄î¬8-v 7*ı¢fã!’h∞›F#Æ∂‡€ƒØ;,ŸŸ(Ï¬Ÿ„◊¶5ˆIx±äc◊ÎEwúF;™è›é´Aw¿Ñô”.ºE cø·⁄Ù'tÊa¨ÖÍ˜¢O¡∆Cze™°ÍµÍƒæÃlQ¸Ö«ânìJÖﬁvÕ™ÂúxŸN≥úÍ=*ñ€vΩrj◊™’\ú∫E6ä+îÛöÎ”'Ã§™‰â÷#≥Z?˙cµ©7f≠ß/ÊÎ≠MOå≥lcµƒ®‘ãéò-∆iàQ«Ø[d@å∑Yõ: ‰[´ﬁ Ω®áøÂêöÎu\ôÁµ_@eÜö∑Hº]¥>=Ú=≠Gæ ˝Ëë∑Âêô ˘£ØÆﬂÏ»≈ú§ΩM‰{¡ıj‚˙@ÚV
+d’ÌOÏÜ[®èUµV{*ÊôÿbM≤ﬁumä‰9Y>Vè<U{Q#_ª!-jòÃ<M’júµM6…ÛzÎT$Kß[ËëU≥/5≤õÌÆEVKµJTmØiÖ≤ﬁtm˙ƒ2Ë®z¥ÔŸ¨’ãYMv‘!≥¢?[ÅÃwXõf,Ú/≥œ˘FJ¥G?˛⁄ΩhJ†Èê∆ò ⁄_ô(
+Yxm'ÓÒø·ö’»2w±s´rèJd∑‹Fá¨∫µ*TmÔ\Â˝k”¶2ñ/Ü’Ë”’h8ùÊãXUrkˆ¢GûfCJƒØ!∑%W•Pèà~6Ø‡»∂≠Úy9pÕ∫‘IçD•5H∂∏îÚ»wqhƒá¢7‚◊¶2 ‹ﬂÊﬂ™Xõ#ä˜¢&≤≠é
+"%G’(πÈ40Òo”œ”Ÿ◊©Ë·lXf≥ª—ßÊ-Ì¡òNÒƒµ}´)|®WSàïå˝Z™B/ﬂK∑÷Òã©¯4‡˚fogøŒ9{Ià•ÈæY◊ˇÈ[gŒ¶ÚhŒ†T"’	kU£_⁄®–/Ω©œ/É%TÁCmƒRÊ≥1‰wC}~YõÍ¿…Ìe.j¨—:Ω(í—`HüÃ52≠bhë°=~´±ƒÑAª∂ov7´¸˘t¸8TËSÏW3kıÚ›¨&„æúY©y˝0 'ì®’¨∑‹/À.¬A±≥;ˆ„Qˇâ¨42DpFhû[Ç3Ç˘äk”æZ˚◊Ç%Âã’Zß1iøﬁ∞Ï/≥pÿ2}°}¥6m·J´'ºÙ2b⁄sÒt¸∏_Qc √ëWwãÈ#≈„¸&ÉçB£º,xÜg¨ÿXx©π¶ÇE·-Ö⁄|9."y7ﬂ$≈’;~QsvÂ^õB‚\€“z14√´ÙÚëâAúk~jRÉOm\ô∑‰ÉÈ◊ˆŸ!>Nˇ¿@≈éjR•óœN€3Fx√<EÍÒèøò}Â_>Hïuˆ¯?fì…ÏkªcdUùæ˙\7ÿ≤”UEﬁÎüÛÔ“-6\TÕ@Uø«/Ë«Ï^ΩyˇÍCˆèﬂﬁæº~˝ÓÌUˆ¸Ìﬂ≥´ÎøΩº˛Ì√´´GèpC[6ô},¶ÿ≈Ï$¡~¯˛ˇÛ
+Ëî?Ô`≥û.¯3LÜ≈tTÃáqÊuƒﬁC†]D=¯ß˙¥(n™A9œG0áÌ≥“Ÿ€Ÿ¬ß~ÃéØ˝„ÉÏömú;Q^ø˝ÁA∂ßﬂ;Öyï«¨’˚'≤÷ØœﬂCZ ˜çF±Á
+4HZ>yÀŸ~0(¶E5ì†Dz∆+Xœ„WÛ£—@´
+⁄Í7æ0ﬁ∂ÍC!Îäî\c!C§œ(n2¸Ûp0¿Ø6dœûe◊/äÈpÒ˙°öçfìCÎoXÇ‰vàs>ŒÜ”qVî≈éãùéÚ}ﬁXÅÜp¨Ïı5˚w>[Tá/?¿Ûô£N]zåUÒ%Ë«- l:´∞;±¿Õ∞¨˛Di‡1ÍÔ†,”w«˘h6Œº,}”C!^”Ô…Ωú‹íg?Ê#.À^c:∆ﬂáuﬁUµ∏U/rPÍ}^Îßbíg◊ãª\ä≥3≈Ùº7Ë·AvSå√—m¸£»'c⁄<‡&√“ÿÌB}ﬂΩófŸüÏœ¯ΩyŸbÃJ™ı¢ø¶ˇ∫âåø©“C$x-f=ˇM<÷ôìRΩêÓÇÚs1ﬂGIe/Â&;óG≠9}Ú¿»rÑ±¥D˙œïY∂?¯Ã∫¯ı‡ˇ	#uP¡≈£ÃÏ÷_ás—©i„f∂»≈Ò—YVL≥o†â0/ÀÑˆ≥◊cˇ¿Úù7tñÑd°«G%}√ÛwÒ†?†˛Ä∑D÷z/Ùj:j∆ˇMË∑„∫_N?R?Jﬂ‡⁄ŒÔÄàl›ÇÄP,Ñ⁄Ñpî∞å	±«"ÏvÄÄ˝êÀI,C>u-CÑ1êzN¨AC‘Yß∫=^Fæës„EZ#Ü¡òµåô&;ñ"ëöb¸öOÛî≥ø¥–áÒbZ5a¶‰¬‚<z‚ë@çRÛ•Ãø&˘î´yeõŸ®˛Ãà°„£'_¯èK6¬}„ÌÓﬂñ˚d¥ª='ìgô[F>Gñ!%¨°JÓX=nﬂπ™fs1¬…-œ∏;Q0ﬁ˚Eºädƒ–¿"oæ Cy6Ê˜Ωü g?-ˆ≤ü≤}ó$’1Lû¨+‰ƒ´™Éq1ƒ¬:è¨ˇ@3≈üöA£˚?ïè±UÏu5ave‡` H
+˛w¯ø3ò,ﬂ¿∑SrÊˇVPhV}Ç˝7|f- Åw≈≠⁄'òAJ…fC,œÊrÎáMAi∞‹á1òÅwU 'ÖÆÃ3‡µº T2î
+–ïytÚce·Ç+‡Cp¿∫$âÇ®¢	@ı¿Z@ÿ–≠¯$ÜLÉTAºe ∂2@Læî[Öò¥¢ .TÖ‡uI«qâ5‡Ô$xõP$Â¶N©˜VC“#çÒ|ò÷Iµ∆»£@⁄êa$iy@ñJ;ê—*á®»¯rÇHàmL÷fÃ…^Ásﬁö∑fìJÖDÅ§u?íÍ`Ní≠ín#O);H8…54^0,O≈¬	D¡Húº±å Õ(g≥8‰uP–e\t±)Pf8Î£yõÿ8›0;úQQç¸O}ñﬁÀ	‰Ó`a≤p£Îpz´Üú√g˘pèMÃ…—¥ßDÚ’b–xÉSay$˜’?Ö˙!ÙÉ¢
+Ï£Ñ{öwë6 Gı/GE™-∏•~„{‡»Ù4=W%‚MÄÍ!™&„„¯§¢ıßj˘=>@ÂƒŒÜ!™Ø“hP⁄æÂQQè>æ1 èg‡Ù&Yb›÷¿∫πSõÖ‰¯hàáKXû¬%t#)∏D`e›∞V3híNãx¡TG8—FÖS5„ÙçìxQ=µ°O=¬P°=mxjXô|ùJ'7ú€L~ÕπÌy6ÑàörÏÉp5àT≥oØO¡ó¥ßWm´n-ıv˙¨®7µ1@SnÍR=’`U˘ûa∆Z)µÁ«˙yßÏ}Æôo÷9Î¿¥˜z¯ÕÍ`¥ËpúŸ∫Ûò¸>!øO]-WÂrë«  PYΩ∞Ö∏U≥?O≈Â”Ñú¢wºñäÑ¡Ô@U≠\®BπeΩ‚M>DB2eñ$§≤&~ÚÒxIÚëQµ.|n†ú~√°EÑub“˝BüÙ&t”: ‘√Ã ¯Mõ_‚”%%NÎÉµØVƒı"ñΩÃ~‡<$åK3Çï+ú√ú9ˆ$B\ÙÇ˛@Jî'ÁvµlQì·q;ñóäs“RúGµPQ‚útÁ¥•8‚òΩ£ñ Jú”v‚§Â∆M6lá;ñWÏ@⁄≤;ˇçá3OÕcÌî˜+¿%EL/¬	1ñ	gÜ©÷Au‰4 WÇ¯õ?¿EËúmiKrÛ÷`:=]úbXl¢≤!“ÙB#rA≠2T5@´!∞yÍ!Ï+7LAèòº2–Í˛ «HŸc)˚‘îΩ ç fF’Û00àì=ÜI’éì}*Ë#^‚d!Ï˚ˆ¯¯¨°XqúWπ®á`A6^U¬ VÜ|⁄“I§Ä◊¯¿w?÷>aŒ®âvgqíî¡VC™ªµ∂Kò-Üu<”Œ+hdÀfk…Û‘†W›*“ñ∑cÿ≤»œ„„s ãËÂ?mùÔ5<Øè◊/k◊&kdı¯o$Ôq5ÀË◊∂|}ú÷‰ı1]/I›ûºˆDûË'±%Ìí¥3/Y?áH”ÓÁV72?ã@ÙH„ëﬂ˙ùsúLÁ›§Œ'Ä∞Öƒ±ª˚L8ƒŸ¡h!Êïq€mò◊Õ"∏ÿ¯Õ ∂ÉFƒX-®Òõ∏mæ≠ò ØÕﬂqfO¿ÁÊöºëƒnπ%
+ŸŸN\”;âBﬁÈa√™é>ΩÜu—∞ö-ñ‡ëÛ™Ç¯éáÀ—lætí¥∆·2ˇˇﬁú€ÜX-N—:µÇºfí3,ªñvÏ“Af]®G§¯r¶‹1ú≤∆~`-Û%*Û©1¡Læ˙:≠KÑ∂\≤◊¯¨ﬁÿkﬁÄiƒS4Êó›·_Ó$b;€7á“OBÿœ’Á`ÿ8b#ﬁ$*ad0'å’x≤Lä]≈Ä[20C«øúiaÿE∆§ìú>«5˙Üxäá*3V_ƒÛ'G’µp¨Ø8ô~¬÷RZã¨Ä%›ß('!·OTh +£ sNô∫¥áq√˜0z0âµ‡¶&~ ±Ñ…+u!òí›XÀ√¸Z¸Æ$∫¸hƒ°Í H0ÖSq%·TÕxÖei!û®AÖC‚P—Ò‘∏µã3ëΩ&‡D¸∑‰¥Hiùy:F=è#“ÿ+”æ¥Æo‡ÇD ˛mü»w`©`ÆÑÔW2Õ©g)é}'m7›‡Ì¶Ê:iºA:¨ßæ~¡uOﬁé∫¯‰èàG†!8?y [ûoæ Y®R~: ˛eDZùw 8^ê≠ËÎ‰ ,W¸´+6LS‰{TJKT/ö√â Ø-¯fakmê\:ê^/{%‹ÊCÖ|t	pm0Jbìã`ß]£O˘Ë≥§≠^Œ¶7H£∑L»9Á¬í´@†Ü‰*‡6LÁÏTﬁ8‰)S f8b√"4∑=esrtÓæÂÇdÈûŸﬁGwô än∞´‡‰B∫
+NN[∏
+û8Æ®.ë
+ UpŸ—Up)C÷VrêS6‹¸A6±ñ…epò\qıÁ2x⁄ŒeTZ≤‚_Ö^™•Ω#Ÿv¿6uqt€úãÆ:µã~…ˇfˇ@_¸=ã‘
+≈C!π„Ú˜hÓPE‡¨.Îà~∏ûÇñv-h…á∂9[∏eii¸#Õ]∞ó[6t?exYCÜó⁄©√∂\É	jóÎ$Ç/v/$ﬁ~˘[±π±£I>\ºôçX˙KàFœ;Ü°wCI∏iòütAEN‹∏˜j5Â´Uáap%*0åjd…¿ÌÑgvp+"Ë°¥ıå≈Bò˚∞ô’F÷FºÊŸB!â^kCØ%t≤=I÷\tÕ‡t$m„_ÏuKA´Ñ©îÑ1vc‘q&~ÕÙ”ÀF3¶ô#f~n˙¨πCà4©n”§
+€†—~t\ÎC÷•i˛ï[ ~f\πô‹ïüÂˇ3)[–Uëó◊3Æπ!„…‰nº-á}—wıÒlœ›˛‚›ª7∞#;ƒWûÌ9áÚÁr◊n'4ù≈∆u±≈…ÎŒhw7˚9o‚>à≥’hYÙº∑usg¸¥Ç,5,ä°Çh¡ûø≠◊Ù\".I ∞.∆E9˝z‡ô¢boa!îÓ*%Êu-a°ÄuE∑@oà7∞äK•á:…˝µkÓØ›£ãÿ~D}2⁄kÔ!ætò¬8"AbΩ§5®›óœÏ∑√ÌI°%y1õMñ=Ã„\?«›pÛÇæ-¨530µB◊¸ÁøhÑòΩÉIe≥ıûCËﬂ˛S%Ó== Ã0@8fûÔ4xúë6ÿ	Óê∫˜ÙÃâ<=≤„ ·§˜„”ÛÜƒ¿q«ß%—[Ø˘˚Ä?Ë®/Z"ÎO/DCy⁄$–Íz°;›˝&WûúTXm˙!>‘Xç…gp^˚†,˛ èOüòüæß¯‰Âƒ◊8;vø∆˚k`6‰3h°ªƒÕoÕ>á”…Bní–·LmØfHÉf∏Tõ>NÎ»µ¨#¥o-u‹Ü:{‡b xÔ?ù‘ Å`ﬁüeôOvŒ3=QåVz))ü∂‚EƒÚJ6æíÒEk‚‰áraçxÅ®±dXºhVM%$.üŒ=®ÈÕÏhÛ/ïï¬jﬁHOÒNúù|·?pjtl(ºŒ!‹ø-˜âa&ƒà0≈≤1)±r* »Á»2§ké#w*@_LNO›z]‘V=ì·Av·ëQÕd}-5˙õ˜≤NÓy=IìΩ'™˚£ ÅTµ:œæìBX69ÑEÕp—ﬁ!‚pqï4Ω∏èd÷–Ò|^≥©Œ¢.ÖÛz¢_¥{ »Ó§Ô÷œqnÖüÃ“»8ÊﬁÙ§åP\˙ÕŒ¿æ£C_}+ ™T=%‹n÷’˚‘ÂvD⁄\êOÏ∑'	1üπ4g‹bú»∆æDéˇ"Æ«yÉ˝…N<¡”Å°Ò¿–tPß±˛UjølP¥^©7K!ˇÈ}ß+—◊ÚN‹
+j`#ñÈ“T†ø≈2~˛>[rSjZßØwùæ…é^π∞dZôÃ≠eÌX$ñmí¡3‹£÷Ká‘¬[ŸŒ≥vy”*fãºÚ≥€˘pT-Èó/´·¢˙0˚ êÊœY>´ﬂlQÃÇ¸Ÿy£pi˛ÛÎ∞`>˙n+èè4"Ëoè¸∞>8%Ç?GæûÔQ∂^¯Õ≥=ﬁæ*∂'˛ÕÎ+`4ˆTWAÌÑgC≤]ñz”°n;Áõ¬ò:·âÏQû}-ﬂª<Å‚]¸ı≤K≈bàwñ¯CuÑ¯ïF¸frü4jëÛ…≠œkZ")æ<⁄=.‹“⁄ÃYX%‹Søu=n)MÁµò‹pï
+'W|r≈ßÙ˘2Ö¶/LAéH6 Äà≠pq·∫Û	]6Hèa˘πòÔcﬁ{…∆Êì¯ÂêOe˙¶÷œfge¶åtÕÔ†Âa&õπ·˘°πg*Yˇôï¨ˇ0[AgÔπõ≠Í”«À<Á,[ˇk1≥ÎŒNN1÷Ñ∫†wM»ÑE#´^Âp8üCã£uœUövVR˜8ˇU«≥uıÁØı¥ﬂc∆›µL86°Oi !&›!›ÉAË®·ÌπcF?«^o–y7ﬂDLk|À>ÔAÜ+°Bé|a∞LÆ7‘ö≠Õe:≤¡vrã˜q⁄∞ÑqÒ_9π ¢Uk_Ñ˙Íî≤Üì™û¨(ßRÃ#¬i/&éxŸxG2µ*'è§íÒjÒr)”€Ç/Puît|È‚sÉÎ©Fı0≤ Û≠s}∞Á˙HUäKv√˘I'aœ§€_ä#˜¯ÖÂUOuíœ-›9hÕ}º<¨∏%Œè>hqXO´{ÏéK>ÈˆI”	fIØt7b«∏õÄ Òwr7ª¶˘ÓêYıèŸ›tlªpﬂ⁄◊√N‹fßÙrNˆt`≈ııb8-Á≥Eu¯ÚC>≥ì@‘•«òÜrI∞ó¨»‹uEç∑è-Í§V;„’Xﬁ·áaÆòe∑xÍEŸ	ôﬂù≈Pç–,Ïÿ?Ë˝oÜXv≥≤P~a”q÷[xúµ±»K>’|d3Œ[†Ï iãE	≥CÈ∏ä›>Æb8Âìó¸Bºc«∆›/wÆ¿Ÿ¡≠÷Ÿ'ñ\R;òË√ÁÁêûTÕ˝ˆ„si¬w>Y*<∂˙∆ÎGûƒzØ#ƒÃgùÛΩÛù(π-
+∞≤µ?—rz[äÂûhπ ƒ»AÉ√°r"Òˇ*ﬂ—"ØÓ∂˚–,`Œ5FÇ-«Ç@øP†ÓYfwF¢Â¶p¯Û{à∂öçfËHÌ —ª˘∏:ûÉ\f	◊-!ËÛÈh6ŒL ıQÉ_≤JdÙl+Nßöé¸Û∞ÖCë‘nI>+ß+Á©2æ§≠„oµÂs•\X⁄Ó`ow ü˚-y§7ÿ#Ω»¡Ä ŒÎ» ¡ÆÅ/˘¢Z¢_CÏãx¸9c·rk√8;∫}@DŒõ¬É≠pv+ÿ[^üBÚ§=ˆÇæ“u˚ãëΩëÚä=õr»Bêæ¬ÈÕ gc^`üM‡7åt‰_0èâxƒYÚaè⁄—]ãOΩQøÊ02∏–ÓÒøZ†⁄Õ¡`äúE	T&å,Íñë.—±Î†c≠ŸB¿|∆GbyäÄ—¶0¡j4ZkIÙN p∞öÀZ@sU«N•ò#¶¬©öÒZc4æ˚ÃäJTé|—»:|”¨/+éﬂx	·QºM|°»Ã†g≈õe!=ü <ÓîÿøI‰µ
+û“±§ÍRòBné!ï,êßü„‹
+?Ø9íÙöπ9≠∞/¡s5¸îOö‚I«f^W¥´Êf?˙8zÉ†…k0‘áW◊ÔH∂ﬂ?|∆uÏ∫SâîSF!tÊfÑí˙ÏÑ_ﬁM∫ç—§≠ß`“L
+öpv»Ù}É¡"ü/Ñﬂ" ∞øÔ˝T>˚i±ó˝îÌCÛÉr°ﬂ)hŒ|Î´,À7¢˜¡`\å™ù&É”k9∆z√8ÈG∫®“Ü"∆æ{˜- }±õõŒMƒÂàK€0'‚2Öê.¶¿ú˝ü «àsÜMÜe	 f0òBÙ¯` ﬁT¯ﬂ·ˇŒäÈ˛N«¡ ˇ∑¿Mê™ds	8™¯âÄªªΩõ¿˘~£;–˛ÔÑ_$Álús=ëpc¬SHÖªÆˆyLûpb'.ëpœûeƒgÏ£Y÷}«´Ã3˚∂ﬁÅæA$úc)˜`¢G›)ÿBü)pWˇ=Ó—n·ª«Ú .√jï;añiVõºŒ€≥oäè8»#]vèïŸ⁄òKã§•ﬁ0~é∆åÇ™c¸ÃûAcº®™§R«9U∫çJ1D∏(@_£≤q ´ÂOt>‚ÊèÇ[¸á\≥Å;d,ˆ Ú‘…%9U{Ö0ïÊ‹O 74^õ€™æﬂ˝∂n>‡Œb¯ßX™›=fQª›kE˘êw@¥FFêh?¯k√D‚®1Ã«&ªÀìX◊µ±Æj∂`oäÌrê´¶ÒQò≤
+≈à(&‡ñ≥ äÕ1ô`zËÃ/Êédæ0Q*Ø÷,y±+∫·±¢µ'¶:1’¸§IŒ¿ÎE;†\º'Lü†‰SSöÁ@πu¸Íf§∆â˚ÖNLuuòŒòXyûg∂;jÒ‡ÀSláæ’˛.e’SÜMœîVò\ıŒi"™Ìd>%:#ˇ∆íòc~w¶ö7Ú˜Ç%7ÿzZ…‚ßIêM1- ¢Xê∂H»‰2ø£dó±'°˙"òïîåFñç'‘πã®31…¡ `Êqròd5\z£í{ªˆñF=9Y`0—∑]Ë[=6‚a¥™C°tÅ´j&¶Ù!ı“ëπ	T)⁄'Ñ≠}l¸˛zEÚË}ıÍR8»∂9ú7»ÀËÁ¥N;ÎSPÔ∫¬Bq≤å*ıèW?ı∏Y|©‰~a7É'ø–io˝Ó≠wß`'Æ4ı¶Ωı2'Ä$Œ`WÏ©|ûg€‹tVqÆóÖ`Ú˚è·ñºèÃ’´Q∆:0∂3ÀûW’¢¯ÛÆ Kd"~Œpe ¬!”´§	˘ü2†Öˇ%¢C± ;œÆn*_"DüBLô}6ıûä≥ÒÜ˜BïsYE§û';≈œ°ó∫¥Rj…◊N«&˛`œÍã∑ïœò#≤ØmÑ'©¿`uÉI 5P†¯8øÅT)Z8ü‹Ä´Elâ}–'(¯xLŒpıu~îéŒm⁄‚ÊìE≤ﬁ8U-Oäﬁ«‘fí$£GBúkvõuòôÕõrWò∂‹=—n¢Ω◊@{[8√ÇıâıÓ¬zÀô∏≈6>Y•5Á-+ —lá øöé≈:|SÉñ•\hI‚›¨∏Í-é‚Œ=ù†ì ≥
+û÷>Lªˇ“âõõÌÉÿÆ.~Ån´Í⁄ì±^˚í˝RTù¶Œ’•0EÔpxx˝ÁV¯yÃ%ZŒ‡+â%
+˚}‚ÆQ8À√cíπË*lãù.èµ‰⁄7-(p›ø#ä:˛›"~bx≥®wgP˘Ö^ñÇOòwΩòóœÍÂf.ä`yÖEdhÎC¸M»h{RB|Ã´7≥—pyø˛πò›ÕªfÜËë0Xg◊é>÷÷zx≈˙¯j’A|îÄ.™æHÜˇ’4©™F˝N0&≈ær]jç¶∏ñŸôØy»Õ‡E Y ÒõgÖpΩãG!Xû¢4™
+ÖêÈõn-«ZÕ¥à$iî}l¡m©:ép=/E^/m}ﬂ≠ÔÆ˙7“7Â±\ñl“˛y¸'C5@eˇH˙z}˛í€ä¶@˜Â….òI
+}ø‚ ´Î˜Ê„«2√¸¯1;B±,[ó∏ˇ˛∏°kt˜œ™ÃÓ¶c≈6Å<ﬁÎ›X!—[Ñ:&ø=ë® Xä|3sÔ2Æó4˛B⁄(—G7‚†»xÃÈQù_Ü•æ-B¥˝Áø®),v‚6üôOÚ¯B>_¯OÂî≈_pÒ43œu˙u8ß:e§vû«†8>¬éÚ¯∂N?Ê˚≤ë#ç?,ÀpÓ«Ò˘%Ëf¯c•pd»Ò˘S¶ıyePELË%Ω8ïí^ôÇ^Â‚Ïu9sÑ§gé§– Ì2î „∏=æ8èVâ{8èA:^—|6y·º“N$.ò˘ë~›Ù<ZÙÈn›|≥°|B—'úπ0_Ã|;ﬂ©ázgéÿÚqCµ4˘~àl;ˆü˛åÒ›K?CË#ËÔhyÃÙ¿ïw#°,†,¨àÉk&(‰çgüWg!‰àM≈€t»BàÔ_}Z7’∆‘ÜPêµêñ0~! j(¥ç∞ÁHÍ  >8Hûw(õ‰SÓ≈m¬â ⁄4}.‡à˘„ããÉ/¸T¸&¢Ù!\ø-˜â©"ãŸàl8„j¬ì (ªh
+»§íœTe3ó\íKf0e	j(›Áã
+°«SÉE*[¶å‹±á»ñ(e¥VÔÿ˝ñúÌõÎlsı∆˚∞ö-`XV≈Ùc˜l–±ÜﬁBÓTfP~Œ —lŒ~÷¨„xlÆw›µ2¬¿Ä6”˙ÏQÈ¡»:1√lTTQ…xÙæ°Øx◊Ñ√T±$√g,…{3Ÿ—à”ˆ®¥æ/ÑOd®øºxä%ûñ¿,`*lìbâó fªiúπñßK,1HãµxØE™Õ>¶à¬!÷ÿ–5a'‘?˛Z1f‚•HÎàı8^{&fkëº	]"yç±ø£’‘2åg˛>»T 3Ç~©GÜVñÀR‘Ç–“1√'‚x±ºí!ä/13⁄J4ãcö˝V!˙•˝0¬;√ pî◊.Â4—§≈æeÕ2ÎBÿëÔíq¬˚:Ö”z"Ytx	åÆ%√Éõ3x¯Y¬ˆ.†∫‹‚”∑è«ƒÛªkQô-¥ØÖ;H-GÉr
+Õ‡ø):Á!FÁ‘zâ∏•p—+◊*PÀJ∏LπP¿%πrç¥˚pE8v»©√ﬁÑ&¯üΩâπ√/–«Lﬂ»ΩlL¥Ó·¶ÂU(ÍúŸ	øeÙwo I≤ù˛k»º—‹rjÅçπMQËXÇÂC·àòójóÆX¬u‘-b®∞º#ê
+ÓBÅ∏°‡+Pƒ·Õpùäs“RÜo3ä∞GÖs)qN∫˜ŒiKqNq‘BKâìrKˇdSì%∑4∏'~~É$›Ω√ªÍìà0ìªjŒâj∏®^OGìª≤¯"9fÙ‡˜·7Ω[≥YªÉ9u˜Ea∏xB‹§;#‹lGÿAÓië›m8ﬁÊŒ Ôáù`≈ÏC_Eñj*^´¬ü∆ª⁄WÂÇWy"´àd.Ù{¯™=Åj°]ê»ìâ•N%”Èàø±ﬂƒoŸÙO•‚"\ˇa›~q¥Núû{¶ì˘%íí  ç˙ç/çµP ∏•4W8eòæ¬PÄ;RL]«¸≤àM‰“C˛√∏°äÛ€Íœ¥.{àÎ≤¶ÖSg]&⁄àßq7«Ç^4≠_|≤®ë⁄⁄∑<ıKîWÓÈÌrÃ⁄qÇ2J…âä|%(bü \≤¢/ûí¿fZy†ﬂì≥Ü^`Eµu!!ÇOAÃäêé¥„F˙ª÷∫≠¯ƒ„Ëò4n/‘Eúˆâpª™;®{J›?˙ÌŸEg›Ó”{e¡µ(¬—–…ªßÖyR'å7Mà¢&	„suÔõ‰l\è≥ë¿Ï‰c\UNùwj™â_{Û	!ûù¿Ú k≈⁄õ!zµ“%Ó∑öÿIm›UÙ§äù|rŒ&]Bèt⁄6§†Ñ©ﬁ}q¸ƒóu˛J%2B:CÓK	Y„˚AZ›by¢¶)Wb|/Y1˛Y∂Ω•å )Ic“ôœåóU˝xy%õ\‰]xI5ùWÛ
+|a(Ø:¢µC´)yˇ=Ò<\ß{¢=-)â™‡ù‰∑ﬁhøµòÉ÷·ÆÊúÑ ïA#§Ÿ	}Ì›ü›{=ÏÓ^ø˚YzÑ7V'wzrBO†Ca;GÁ„l8É°,¶0LG˘>Òbs`:ibU'M49°}-ÈbÍü^h¢^B–tÓE‘n¬zˆœ(’ X–"ÃÕ∆ÃA€ó|ÃƒÄ!‚ﬁÊ=z‘∞ºr‹«ÉmçîÎÖr- J—∂®◊dÅ§¡.OfﬂÜ3⁄;…¡º€€2ÿπ~óK≈b<Äæ™® y∞€—…(∂´ÛÙ-ÚÍn1Õˆ~*˜*ÔeŸ¡å¯¸˝∂K,™"O9’ÿy	“œÉˇj°‚¡`¢Tøìw0y˘Ï$µ¶o«ƒfxìgb=û	ü}∂WºxºÜÂÔ(πQw@kXKN©§åE:J4¢d^T’qÑSQx‰¡J™öÕí+∫˘I’l˝_ö≠âd”[x‚≥™qˇ#LS&5\üâ–0ˆ;eR#F©œõaY˝YLáãÔ>≥®ÔéÛ—lúxY‹≠ò2©±µ$GÒ,ÛfR{¡ì"ì⁄ìKyÙ‰¢M&µÀ#'ˆË…Ö{ƒ2©]2V≤Ú1°1Éÿ%€n“Tí;sy>œAvy¨rê]ÚΩs¨E´d%Ói≥π]áø,C J÷P•kÙ≥ÖõqN(ŒIÁ~âó›ıì@ÛfÄÊÌ°ÈòÑLÑtD‰!ª<y».1]"5Òy».U$ç¥"‡3œ(vÈã/±Ïäú_©`â˘?Î„gÌ~KaÜq5á&∫Ú†∞±Êv¯ç7ƒaÕZc›ªf0;∆û÷ÙQ∫ÄlÄÄ˙jÒ-˛VçÚøóﬂ¢ •~'‚5Øª@ºjà^ÎÿáÒÏxı’X1,˝MßX˘Ñf◊Éf…åîòﬂÇ”ı∞ Ùå<6Z„…÷çâíG9‡™†5©∆∆"uıúDJóÂ`ÄveãŸçãÆÖöÄ~Û˙äÌj÷°5M˚öÔ7B7¥”X»K8`ëVâÇ@Õﬁâ_⁄≈ŒWêÚ0V∏ûRØ>¥‘´µ±®LÌ•%f$'e< ƒ¸Œ„sÿÿU/é†∏TÔÂπππÙMQzŒ†ªK/ü:/‘ßóªKü¯I'B1i®§á√˘∂jàS(û™88VN¿L:Õ°∞{]6u.√€∂°Bó%ox\+x\ ß)•‡È±gÖ÷≤û∏˘ÓÈ±
+—ÛÉî‰bä*àeè/R7≥∞!¸•-h"7ó0,nÁ≥Eı˜bëè ˜ˇ˜ÓâzTC˝ú›ã…›"áÜ˘ﬂêY·∫¿Éj‡„∫9EJ¥ß^&D+“£T-˝Œæj°<ºc|5XÚùP≠„/ïÙ∆jπƒÒ1˙¢7’ÛÃê˙ƒ>;˙Òp_ˇ°q‡Æ‘∏óÄÛCŒMHœ∑â’ºΩvAùÑkd¸dTÊÂ&XÅ<µ‘(70Dàq•Ü⁄
+‰Èí˘EÌ‘!˜7¨Ü,)±	a#∫8í√Ì≠"i$	Ò ßnàWƒ+ÈÚM*8¿®é´§•“pNÉ‹É¨:÷≈GæÆ3ÏèP≈\˘Hd±∫AVA=M~z˚	öEêëƒñçï&–Æ/$‘ï}·!TD]5^F	[‚5îtQ)G∏kÀÓî¥Í⁄ûUW#è+{f+˘È⁄òîˇdÀänK*}*¬1h‰æüLÎ9Kº ÛŒh˚´OÄÅüÖ8N…Ô3wyez‘â]÷ß(óY^@v˚,EãÏb¥»√…$Aì34ÑY/õ¯?2‡VU°Óe£N∆Ñ;Fƒi}∂‰a…Ω∞˜Ç¶b}·u2p£Ú∞ºÇx\À2µ;1ñYg~µQâ”2øÍ89µXE`yßw‘
+Bâs÷Æw¯Ω…É¸ﬂÉÅÿk5€tãp≥wC7¯Às∆!¡˙ËdåÛ‰q„5Ë´Â9å◊R¶∆W´k†≤j‘Ööí8≈ëd¡°•ÑáN˝÷∑UÉå5SL>‹Ol|b„u^"8Kíÿ¯˙MíÒ˝ì ·⁄ °ûú›¸êÈÊ∑6∂ÂKñiÍ¥`ÙÒ•ØæAd©¡ñZWS≤`L”4fã3jqâ,ÿOé≈’⁄êÂ!`∑9ÿVó5Öö ´»H·éEüeƒk†;ÂåÂ®ØüäIû]/ÓrÈã€øôoÛCˇ´ ‹>"ÛT÷]kT˙yºe√Ñ5˘ÿbíwÎum…î.KÔ&XºfXº-,i:;5∑‚ƒ‹›∏;`âÀ–ËT›PmÉL∑«ô‘c¬b;à≈@©$>T·R-xŸ˘…Ñ÷Ä,õ¥…‹XöÍ∂r™k$vÙéÎöÈNoCø¬≥µE%pΩ≈ÏBMw¢◊◊&n +!•KìﬁúÙj7~É¢93—ãº2Ëπı˚)ú»>(ãøÚ„ß'Ê÷Ô´<ºÛ˚ÈÖ≥Û™”«´ùﬂOò#wæòUû‰zÎ‘Ï,d%'?UG˘±B§Û…6ªæ”§ΩﬁI€ªróZ·$jÄ9˚ òëıÌ°VJlÓàÿB}Ÿ~ı•'D–{åÏëie|¯ø≥b∫ˇNõ≥’∂ƒ1˙éº¬ÜÂË≈1Œ”xó∞éM»‰”¢RQ\∏f1ÂJ|Ä»•˛ãÑ~M∞O¬&õ49GVø èw|¯dQ ›ÄWRÙåﬁÄé∫E_«ÜM◊4o2G còµÚ≈c UG£ ë[ÖV
+Çn5T5=x%°íÇJZbK∆8ï¯hMtƒ¯`]∞ ,$C;èªû¸‚ÏçÈt¬¥'“Zá⁄ú0“FzòIúçs)d„â…÷Ì„ÜƒkÔﬂÌ∑>÷≈qãEì s›B~ãìf0¨El"§.πF”ìZ∏ß8ôt„g ãI1Œû=Àji*0î'¬eÇV.ﬂa4'GGÚ0öì£cEW=mqÕ…Î:Õæ-Ü”è˘æ‡ªû⁄ÑFsrƒvﬁ™©ZX"¶ˆÏ0öì£sF∑Z¥ö ©xrÙTHzrtA¨eO™xrÏõ√†]Ü¿q∑'«Ê…9VZjVN…™i5®%Á}^Çº≠IV€Ù·y:–GÚ<Ë\ÏŸYÁ^¥aË¥5≠(B·K¨S§qvÊÉUÅ{)ÊäuªìÉ(‘√,Œ—?c˘ª7\ y>¢À•ÕO}cÆ§VD‹v<ˇá—ΩµÓgñ‘Ú‰¯Ñ˛sråÊüZ≤Ë√†m.ÈÇJ∫G8≥åπÃôHx<XMnπeÁÚ‡D≤µÈ§af≈Ei›πfî-´KÍX´:πÏ‰»-~…âÂÈrQ¨öNà9Â^î@æDú8)d.ÖÃÌmı¸ÂlZ˝UL;Åî\ã|8€»ù
+¸vãÉ’¡`4≤ÿr„˙˙|Ã≥—lrh˝P¿2¯jÚ1N∫EY¿NG˘>oLêÒ◊◊∞:(Y.⁄√ó‡˘lEÆ.=∆™h‡™Oã‚¶Í2°k‚t∑'mÚ>:^:î»‚ƒYä≈SÒzQ—¥'¬'ã‚KñÜÒÚ§0Ñ5Ö!ÿ∆99ñÿ\k#∫îÔosSû∞’U˛•›5 •ÉO@9dp¸ò5ü»#yûnº|3ÔÔg9⁄ÛÚÃ
+±à‚Â˚‰‚S¸ÖÄ|isjﬂ§˚ÒÖ"›èŸa,FÙ‰¯ºÈ~ÏúXTˆÄëÓ'1«!È~“»xSíá”’'GäÆ>·#~cÈje∆¸<Íf–‘~õËó8ˇﬁe°»Å©u≈–∏X¡Ç “gœää?Ï∆˝*¢ïtE∂2'Á~O$˜{≤˜{‚Á~EÀY‹ï7êÄ·ƒ√æ~^uù¢ÖORF≈ÃÇÂDœ€|Ò1«â°3Î	QH@À-™≥ØÃsÚsÁˇÒﬂ5KçuÑJÉèˇTm<!w{Rt∞nN"GÃïûÌü9ï¯˙™∞úÍ°ıBMH∂ÍAÿ√∞d∏6CK‹ÿäœ√‚»ó‚7˘£‡ñ¯liëÒ â…›«(	È”Ã'öYÓrÄíFΩÀZú.Á'©1‹ÎûXÓ5∞‹ŒLl·vÓXâGÌX^av~I&N`/1«Zrîê2Å@ÌaâL’qÑS»ì<ò
+ßj∆®jº|≤ä#ûo…@≈ì„•„6^6^¡ë¨Èå"^≠Y.“Ô¯¡ìc`sÜΩhÙ
+`áÁÏg¸>Å†ÆC·èA#óµo¶Ù•À¿	Ì¥u`3B˚Ò≥ƒÛcq¿Íkrè_T\ÊÔ•ñÓ)≥%K jƒãX+˘ﬁá$:DëR;≥•O[¡]Kaù¡ø˙Z√Ò¶’A
+µ*¨{P*2ˆ∂+‘⁄3[®ù[ÏxÄáÂ)æKë∫E>ãc:YÔ∞mw*)ˆé¬Âz÷KÑıC%¨g77ìb )Îég m-›Å.¶A%úxñ·ø·<ÉS!ø6‡Bµnñ˘ZRòÓ.Å@_h¨‘ö~CóRòÓŒÇ!«2[Pà´\<¬Út≤=ﬁ3Qq€ìÖ‘–¸M¢‚ú’r'™,ûöSTÇ~é∫¥ÈY6pÂï®∏±Cáµ\íßÕRòQ#zO~ z¿÷,áñüãywG}¢‚vòäÛÃ¡˛LTF5<˘H≠QS/≥ÿ@4QqH3„bÈVY>
+∂Ô∂‹¸“/‹kîÌ˝TÓˇT>ﬁÀ~z∞T‹41qââÛŸåÑ˝01q’°ãÒ4iœMÙ¯8NÚ’tÓ^†ÃCÙò->»péC∏H>eÌÆ[rff%"ÓPyDRLÀ∆ÚPv≥P≈O<\1õ&N;ÍHπóB‚ÂƒˇS1#âácíx8P®A)Ñ¯'Ï…	à%¥Ô …Ï…ß`}&.—p˘|!*ã∂7•Ù;0fœ~Z a…E2H÷}óKÄé	‘Uu∆W¢·≤E~;˚íÎº£‚`„ˆHe¿Ñ5ˆÜE…—Õ€òJbOKA"ﬁΩ€ä+bœ∆"}–◊Ók-'(π˛CÚ)/≈‚}Ñ3ÍO/àOQπi±xZû⁄≠0¶•«âaÑÂz∞Ω√≤∏<˛˙ZX—¯ÆI˚ö◊∞ØŸ;=Yò01ímIQˆàè™‘cJÖV‚t™6Q`œöı$	«H)ã¥∑Ô§=ƒõªáÿõ]H”n@wÓÏ·bq7á¿%æíGH≈|	‹∞çW∏π<‹%x
+a£‰§ä®ıo}›å\ì˜º_7!ªM@vâÔÀ˜˛$îÙêº %ΩÁ∆wß◊X§‡[ÿë…VÆê3q4õÁÂfm2k‘û=ƒ¥;ß≥$≤Cæˆ¯Î1hßœŸb$ùy`l◊tâRÅ≥¯√˙"Ïd„åt üå/∫¯£‡ñ¯~	¶•tâ∏FÊ∆é≥x‹`8DûFç'RßubÚ4©Xü.Ò’µ#ã¿÷∞˚Éúm⁄99QYÛOŒ"Ä«øû\⁄’û@u˙t8“=yjtÉ≈f2FıâÀIé=y*a+C¸”ˆ·Øâ’Ò«æËdŒP≠-KªN$:tâ”å$™åL<*´(*TJS= ärD⁄§'èT∆q*»Zav‚e„¥dUyÛ<Œ3%FD%4c∂äâ~räáUì"⁄PëWa¶I˜ºh¯<”ƒoÌAòñqÍ¬√⁄Üú,yzØ‘p⁄ÃnÆùX∑$°˘áq◊IQÑ4≥fh1ÎÜ·_9-Ävp√S;„u¯Ír}ŸcëÙ∫•6`H®áYÙ˙5ÊˆöUˇò›M«ü¢	órO1„lõñâWèÊ’ÂbÄœQÒhÀk∞ç„Ô SÀ =Ô•Ãíu;;áæh[·HÚyæ®æwÁ˙aÁ*∂–c≤≥=ôÕ	oı‰d‚5‘ŒFPfßñ'È9Ø%≈ıU™√ô(ü ·’ì≈ﬂ≤MnJ™ˇÖ™MY©nÀˆ`î?SÌ·Çœ›€E}}#GãA;/√æßhãµE[∏”S‚é{‡é’âGå≤
+ç8ô*–HòT Àär5Fä%‚tÀâSsxvaO{•L7–*Ä[Íh›–w≠ÎP<˙9Œ≠˙¸ü-âÃMÀ∞Ωt⁄h.„púèf„|g1.æc‰l:˝Ü≠ ÿjü¢iYwÑ∑˙'|∑!¯.—ƒüç¢“∂£Mﬁv4Ö0XƒJ-∂ŸdåUtÌ4ˇJØtÉNú kO¥Qq|¥Yêk£R˚*∆ÚmT Aπ—¶£i7⁄ÛÍZ›ÃßM⁄2¢&.ëp\I$ØKb´E1˝ÿm∑∂&Ω»Œpv—I≠Ó#Ω®˜F|iëö‹∑>ëË†ÈM§Ñ’÷Ç’Ã	l88c@ƒ”\¥öCu5ÿM+7”]0∫pâfåìxIi5G“&RéVnñ4ÅÕÌ9úgëÎ±⁄Öê#·å‚'€¥‘kjÌ4¥g≠ô∂„`ŸéÇ„4ΩÒDıÑÕ«ƒ√ï`”óå¢Po÷çÄdÿÿQ&¬1∞˝3÷s(Ò´oEYï‰æ´·∑®€{∆^‰XÄjˆ˚Ñ¸>%øœ\îçUéfMhÁ6∂".œËfØ≠X™3Q˙,Ï]ÿ° @J^:$˚&áX˙≠å_‚Õà≥îIîâÒªlà•^U‘ofÖ2S·3~~yœRHh9œGtkX6ún|H®c¨Eüw‚·2ñß8¡…±øj:nÒ(A<üÔ⁄â√|ãÊ—ﬁjÅ°ƒ9È.Œ)˝‚“wfCyô∆ñÌ`qƒQ´%ŒiwqŒZä√ÄèŸ;j;òÁ¨ù8ˆÀ'“|sIÛ2ØﬁÃF√IQ}ˇÁbv7/[PÁï<ú·—ü≥èXøÛ*¶+cÆ§ EnM˝ı˘{XPpI°º»"!ˆgbm1`_§{Ûq¸V)$-§Wäø˘„]å/âN¸Wc|U¶cı[ﬂÊ≠¡=—ˇpgúﬂ@˛ﬁ·òzÍElRŒ£.séMQ”≤NG˘>oLÑã^_/Ü”r>[Tá/?¿Ûô~®Kèq6DõR}Z7’†√tôb“Pl9õO4º≠%Õa¿À9ô’CıS#Ê?ˇ≈aƒn 10¯åâNO≤¡˛Û~ñ≈_˘…Èqf&m¯u8Ás˙„å¥!≤6úû;YNèÌ¨êå¸‰Ù∆mù_É	6ÄåÂ'ßO†$k{3°yvâ≥c%È•)(ÏßÇ9≥LHzv‚JziI*3Lú±MbM¬*qIäâ3pÿÎ»f†¨Õﬁ¸6˘Føx/˝O›@ﬁBÀ_CÔçg≠§d⁄RÜ!ömÅÌt˘√|ÍF{E§Kî?‚8?Í∞ñ|:å«˙Xû¢YDjÈAP)çõ≈ZRtR∆
+öï5á{=GX]†~U«N-D»É©p™fºÄ¬∏≈wØ†DCÑ§,ëKY<µZ¿˛’x)õ‰SÆ&ºI#?ƒgÃ¯pvvÖˇ@IF:;îv™ç5y¥ËŸÜÏåL…áÆÏú)ìI>R	ƒÕ‰Ç@YB?›lõ˚õEÖ–„©"¬[∂â‹±TÃæìñM€¥lZ“	‘´ÁG1ã:pZ]
+{.ö==íπtb˝ÁV¯yûP&Ì…b,	˜«º]ﬁ≥T˚ÑÑïXò!ªD~üå0Jh≠∞8†¸±à∫|".˝0P<≠Ã¶%|XÏ3µ=‡∞ú¨
+ï•&XB£=ò‡Ë,äjø~*&yvΩ∏S¡Î˚7åÿ<‡a=O16a1ôü•=g+
+;ËY=¸	àı≥Äüzıq¨Á_¡å‘·¢ßÅÓïbÌdÓe›√µÎªî”b1´‡†’—d»í„fœ¿eÛ∑iºá≥—lrh˝F.ÜU>ÓÉë·®eÉV)∫=:∫∆ò22‡∆H x{‚ü`ÕË]∞2˝Â¥ 'ûŒìl7<|/>·-»ˆ‰ñ[Ä™é„¡lƒÖ√Ù’®BíB S≈	àø•‚Olüˇ¶∏ïì)œ2¸W„V’`Wı[ﬂñm√]˘Sﬂƒ'¡˛…‡z∑ªnA•5¸Ï∫‘4ØØ)\_©4®iﬂÚ4¡R_ﬂ»A¥qöÇ||‚»‹O◊§=kÿ3‡ùáë˛`ìwH»Œán<ÀèÂ…/!å
+ı!–õ˙∞ñ‰GHôƒ\omF«`t!Æª°sÕÓ3vW≤…ä˝“,≤∫fè◊¡Vßt"Ù{PhD§+q0ßt"¿“]√© á5Ùe"àY á¶ÂÁbæè‰ºúåÃ èP)l≠Kﬂ‡ŒÓªkX„3v¿=Ãb!s/üwönΩ6hüƒ∂F≥≠6~J˛˝ˆÔœ!"˙√p˙1ÒæZ"0Çb?ä„˘náﬂÆX”%òön ä≥àH≤¯XD,‚5‚´t≈£Ë¨a_d¯nD4›bâgÄÔ©óˆ=∫+Ìâí	ŒS=†/ﬁíˇ’åßz‹Rø”> ]‹GÈ£”ÛF¥rD}`∂–s¿€Kn ‘µ\(ÿ$á≥VÉŸ f≠3ÙL»ô†ÈtV°ﬂKˆ&«7ÎãLŸâÌÅÂ√7ûnƒÚ0›”UÆ}Û|±Ö∫#◊v6P÷Åµí˝‘„5^$UGâÖËƒGÅ≤ÅèÅ™N≥h∂–	›o∫o§AÀ;ú*p	[jÛSÈ?GP∑§?–ö∑  ∂1V¬Ä€D‹GàN˜a˚èQù'MŸRöV∞Ò Û>˜,æµX^¥ïJï—ÅVå◊K—√vÿUr¯HÇ'Äìn¯±Ôúin/òrYõÂV¿s∞0|”‚Ÿ3Ê˘ ∑Pl<?v6Bu-„b˘A”Á,Œ˝É„ım/ågıqJcÇl<Wª†X!¬Ãv?ÅZ/Rx∂ªÿb÷g3R· µÊlKºl>úû≤éœ¢ÃÎ2êìf<û5öøbxÍ»‘ïŸ3Ö⁄≠(R{N‘q÷Á=5¨ñ∂á∏º)O<Z/^å-Ö∂?äDbÉ%.3ˇ‚ø Ÿ∫Ç©Î 3_MÌyEãã`£]πŒBK—Rúáün'-ı∂'N›<•c«Ã6Ê¶	≈† ˘,, ◊≥§?÷ñ)¶;≈tﬂ>lœFBÜk@Ü∂aN4˝4}B$€âHZêŒ50Ds /ﬁΩ{˘ÌÙ“»Ÿó∆¯‚Ñ’\– nF3!Ùs>¨Tµd$S-Ω¸5…<PM€ΩòÕ&›éfIÛöÁ·13‹*˘®‘J{Ëã)IS›ñMuØ«ê+vÌ]3ÀÒ©Ï«Ã„ÒåàâÕydŸﬁ.ùfª8€5yÜV·óÊªuÕw⁄&mÚ≤3Mu[9’ıΩ®„9ÀıöN
+±yè&-ø˛ Ø∏AB°	0-˙X‘dñ?ﬂ|∑N;Ø]Ù˘≤gk2¿õ>˚¸\•œ>øêë(Ágm“gü_:±(Ágv,
+K}˛‘XyäùÎèˇxMˇáy£/é"J“Öœ<}˛Teûæ‡∏ì∑´WªVv◊îyz√ºA⁄ôOˇ+ZÌ¢πˆ-vÎ(s€≠s(ãafD%»«"âÚ&oßZüE˘B≈a	bÒ|»*0ã K·…ù¥Pﬂ⁄§s»œtÕˆıVW˘‚Kæà]ÆC$tUb0π+[ªC<0ú…†B\¯j_<b_éõEcá‡YÔK—]æ[∫;Ò_úLpêâG¬L"_Ó%yrêoòÉúè»¿ìv≥iƒép[€n6ØEﬁd≤BÜJ#√®-πi‚}ËÉ&ßıíÀÄ%~Ü–,·˘` Ó_¯ﬂ√A"çlä⁄K£∑buC")=U√∆§Ñvv–£¬q˚„ê|·dpÛÔ‹ÿ…ÛísgŒ5y9ÆæÒ À?¯M6ìì6∞oÓˆèyı|T_Ú´∏öÿÿ¶Â¶∂WÀ‡ƒ÷à¯ºƒ/´„–õçIb!v—>Läyg,%◊À4Ñ“ud%∂f£Ÿè=N\M‚jˆ*Ôe?ŸÁ›=Æ∆“˙F¶F∏4ôCÖs5Vù⁄FoqxÛ˙
+ˆyì-:Ü8êU\‚"ñN\˛6RV∫¡1‡azPtBﬁ/#ÿág°[FŸÁƒıÑÈ`ÚÒZ‰≤Iî—Ñ\µ!Cl|: G´—Ô∞·/˛ì)k.T†–≈©ô≤ÊMQ}Úä"gÕ≈'NÍ”áÀ§4ó»VIk`–T∫Ld‚ö˘<üéAÙI~{rq)›L2ƒ‰¶ô⁄ƒi<Ÿ¢ú∏πY•˚?a‰m¬»^fN⁄âxnN‘PÏáæ+mJîõ=>Õy`.û6‰Åπx⁄ê^≈66◊¶MÖt£&éÈ„S∂µû\µ:x9ªùâœS9˚òò ùç¥oBs>vPF"jdπ7®ëeb*wÙºÙ†UN|e‚+wÖØ§àdìXK-ó‰.ıïƒ`‚ylbΩGXÀcÚ;1òdÂúŒdJÓœE>¸,(Gzg0ü@¬zût˚…QÛ…ô√`B}É˘‰\1ò⁄&xyÃ'ÁxÃ'ÁöGK<&gôΩ)ŸØ?ÑHWñ]D^Â£;HÁˆ]ùck|)‹LÑÔóJ<ÊvòzñÉ-b3ü\4∞ôO.õYÂvñÌ§µ∂Y‡qπ—óWêÛ˝ÂlzS|º[ùwY◊êíZ}»ác∂Û¯é+Á≥Eıq+ﬂp˚iQ‹TÉrûèËΩlÉ¿v˝c⁄˜∞Ü}¿Í˘≠”&≥zi˙€ûÙV^ªÍ¨üÙW)¬/E¯%Òh~˜^3L¯±I¡û\™§`Oû*¶ÏIõ§`óÓuOúÍXR∞KFƒ‘˘KªÉI¡.O#J“ÙJ<)ÿÂâJ
+vyJ¢ı3≠I)¯/ëfÛ≈¨Ç∏ˇ—Ó∫ù]Ä∫"“lÂ	ÿ.œD∂ÀsõJãO¿v©û'`ªT¨<¡ ñq!w¨`πJhÙ¨’;vø%Úm≥…∑Ôeïﬂ&˙m:\|s…l4õ^ø(Ëﬂ‡}ÇM	¿MÊc§»ä≤òñ’p: ˜96{QÆ◊v¯2—o¿?Æ_∫AôØÿﬁø€åõ˝∆rQeœûeñj6©Íít/7Ê®ﬁ¬w•]àá˘t4Áû‹yü=)Íÿ©	ãº∫[LÁì9Ç≈ÓFbk“cGˆ)p–ﬂ"¢·,∑~ﬂ˚©|ˆ”w≈¬jÌ ˚2ú‹Â≤ØŸ∆.}UÅ´¡`\å*Hr∆N›Öˇª-˜Û}d¸„d–Ë√è]Û©X¢‡2ÿÕ˚cÜ;âÕ4±∏πHfÆ[ÿ<∫ªΩõÃú–j∏eƒ‹…D≥¯º∫≥)D-yÚ`üá
+˘È%jC‘:PpóOw…ÿ∏≤¯+?πºhC¡==r¢’./Ïh5F¡==é ÷êÇ{C÷π‹”cE¡=eCQ˛ó(8Ï	ü∆%
+.Qpaa¡‘Â˜·ÆúÑ{z*H∏ßCKmD<	˜ÙT"OÉ*;A¯)OQG‡"· ◊J¶24cÔÛàV˝Ä]%˚ñÙ["·∂y?/="":Î`ä~KÙKM~¿	5¯ßõ[$˝∆-•FØú]‚Y! ﬁ≤3F∏]ÂÏ∑Æ‹âXè€◊ùv.∫ñ…B4|#5Ÿ%C Ï…ÈEŒ÷n{X^eπß3©CìH-∫mk•iÔ!H ‹Æ©\-(∑ö©/*°;ÈàEàª	Î¢ºâ•9Ö∆∞.ÿ˛ë∞+∞?n,Hq¥?¢ònéñ1+…%∏â˝õ{ökY£.©Ÿû*ÆËÈπ9kÎ|J“‡1ÓA§f{ä)ìæALˇ«|üsMP_⁄\N◊`µ”£∂'3I6®NüÆgP;„Rõ¨¬æûvüùµ¶ÒÂââV	¬òÆ?íëy§Nè06ë⁄Y≠È.RU§ﬁí∂“í[i·ºµÁE~;˚íC–∆<_Tﬂc7çAä\ ,±
+L"5Hbπ-dﬁ≥ÂÉˇv>\Q∂·Êîï9ç_ú q‰»
+ Q‰œÑQE»"4?z¿SVzú:'ñÑ+ËŸêF+pªÛıS1…≥Î≈].M’Ωaîı…0ˇH1fa*]Ú`IÌlq•m¸:áÓﬁî˙∆'∑µ≈Ïx¨≤Ö5∏ù⁄  T÷¥íÒrI}uÿEﬂúAŸY—ÉTy(p§ëŒ¿L¥löNÁ+J<2”‚—oÇ=TüÖ
+ã¿Ñ°:SÁ–gÏÚâl=12ªÑvBÈÑXçLkH#îŒWÑô™:,?Û}⁄ññ¿÷|•o$OãoÂ`ËlÅ&Ô.nÍ‚·	ñßÿ7ïßQñi»Jdbò–¥ÜÒ'2]XU8~∞º#éÇJJúìv‚ê≈ß•ÌFõª›®Ã´˜K±5 ï0¨}„à`{ Q°:ˇ ÈÕ=’Gı∞ÕÕ!G.éÊëÎÒ'∂∑Ì√¸8–∞)òyoÇ8Ãû—.·£Mœä.ï¥‘@≈Ù„˛„ø±u˛œirÍTR%ÅLîæÆë#¶Yí'lû0{˙I¥Tïw£•$i∆E<$≈Ú‚D©bÖ	ñ£ra-πÙ e,`jﬂIHp;ê`" H>„n;„póà≤zøàæ{8Œ›ùÀ|bﬂA∑`" “aá≥
+"¿ÚYvmﬁEä·KñÔ„ÁHÿË!FWyYΩdÈÃﬁÃÜ„QMòÌ-lak„ü≥ayY	≈ﬂ˜Ê§$Òë_|[±á.”˚™≈rfÍŸÈV£ô3’PÍ7»ùÈ·æ˛#ySL'We^?Të¶≠∫ƒT)˝›MèóﬁJ\⁄∏4wí⁄6MèÜxŒJ’qx+Âª$ÃÂ≠TÕf|&	52<‚%‘ïõ®5]µYFÚñ…” rùÕ6ó_3ág#√&∑Æ!pD2âcHÙŸ√œ¯®˜€Ωx˜ÓÕA∂'⁄Úa∏#Q˚«ƒS™ìICïLJÊË$RÍRò"K…™í7*!ÍaoïÅ–¿j*.á≈5ÜÙ◊n;dN{2Ög_n‰¢^”≥ŸdYüi”ÊÇƒ"&qkXDﬂÙh·W9é‚aòû¯xü’6Züp<"ó Í4É/	qrnu«fVöîÇ ßc» 3 y◊r1ÜºŒ¯#∂QãYA¿îÛÖàIER¬’¡4◊a˙.ûÇ)¿>e{¡8N~Ù◊CŸäO´b›˛[ô/Z0úwPúM›jgëów:]¡N&Ñ‹⁄º&&j€QL (É∑j≤∏îÕπb¶§àe=ôPÇ‘Oå&<Ym†cd˜¢@r∏•ï√"¶`AHË”ã∑Õ)4ÿ@Ò´ÙÂä’„:Ê?ˇÎ®∏?¯Ã“ﬁü±Õøüg"]ÏÈ—Iãt±ßGx–0Õÿ9@ ]ÏÈ—ìÜœ√cÈbOè.#J"b—oàá6¡3d∆XhÑºØ˛VJ«î0dúÈPî0î[õã›;A[Ëx#∑¢à«Î¨8E∆ãÿƒÈ≤JÒh]ñwv6 ËJJ:ƒ>.∆ﬂ^c‡çˆÒù&˘îœU∫eµ7	‡âSûÚºØß«òç⁄Ï—©_Oèû ˛	¶~ÖG»2dUdŸ	r'znÌ¶h«ò$.ömIfãπ	5ú–Â`õîOÄ≠{K/ì∏Ë¨Àf£¶®çqŒ“MÑ:É!xú™—Uwà´rÑﬁrÇMp{€‡∂7¨5——ö¥!e«OZ@m4
+eC2bd«’Ä,bÉòTé¨P!÷t0 ó?¸okÍËK•˙,Îû1=[´b6çŒ¬d4[≤…bnç&‡⁄fR”WØ‡åâ=SXÜHçE$£ßó&£Õg,GHõm¡Ïh^Hƒtäø›º¯[f®’.†≤~˚´k',ƒ+ l§1@‰˛ GR˙Xë“««f^Í´\À)'@Ü=yZÍ”c<∞€†§°:ïàf8C˜ˆÙ¯¢°;X´8Òö"«cêë7A%–D3»Ov`M∞ˇ‚{6≈Ø!Ü∏vÍMÑ3Ál€ŒÊòiÅÑÕä3§‡#ûï100ÉNÈm∂g–Õ»6?Qá–öEµÕ ¯ZDUãörÙ”Ê–'w¨ïÇ}'%	pÉ7µÜ°")≤:∞‚1nE-VaêJô),·ÿ†{§H–>4r»%≈!9.Ò:#q\‚Y∑« K>F≈"omx2ˆêà¡.r±9Å…ˇeùIà&q9•÷¨vtá(ÀîZìçH›§ô&ï“p÷öπÙò!B=b}M"¯…ÃŒ;H‰ùlòE,ú…ç^|ñ◊pI0à)…&Ã)æ6ü‹Ë£%Ó5ΩôçÜ∆jæáD_gã6â4ü9ï;„'å?Qg˛9gûx6lÒLUN;»Vû∏'%ıUÍD+^‹EErs7˛´Q@ëÏ:ï§PpC˛î∞8Öœ¶Ÿ›üÂCW/˜≈ÚB3‚ÈÕõ®ΩµQ{˛I»B\)îp,Ø6ÏóÁ”à©ß'áÖß8Ωz	Ωj¡Ü≤:≤¢áh≥§≥ÂNt⁄¶”iÓòLlZ ø…6à¬ô≤Â|∂®_~Ä£ãáNruâ¨]»—x‘Ed‘õR˛Mÿ©'âMK;Á∑fÁ<g”BìàÌô¶7˜Ë»ÑÑôn≤¡ ˇw›˛ÒçqAOSÂJ›ªÌUO$Ñàh \`$≠˙≥òﬂ)ÑíTH¬I€Œ¢—XXÅ¬I∞tï]ƒ‹lÜ"ıCmﬂÙD¢·0z«ŒF≥	ƒg@Ñ‡LˆX«®t_±ôzm±Gû…«BXâ<K‰7ä)këå<[M,ö5iñH≥Dö›csè ∫x‡çt¯∞‹ª˜…˝	#Î3:“˘i|≈ò‡în“ÿùÅ`ó—)'ião9œGt›A=oêÛÓMdY"À∂{+ÌŒv^Ç*€úΩ≤*=Ë`PLãJï∏⁄AÛ,“´StòàåÑYoåﬁˆÁ"Ë1ò-9ó°v[ Ú¬XÊ^õ€À^¬ûÚ∆p	õ‡ ˙‡ NqW)‚jWÆÒMTQõî…+∑=^9S◊ì®òÑm÷ámR¸Rä_⁄ö¯%ﬂ‘a•Dƒ$"fªâòèyı–œçldÌcó!ŒÂD»|Z7’Ä±Ó*çŸvmDﬁlŒ¡iM˛£D»Ã˜1ƒJπÈ 9|ÖŒ%kãè˝ÅSﬁ∞
+d ‚¿»;6¬ﬁH1<µ1<§Q3”≥Õ›bÊ◊˘FÇF$7fA ?ÎtC¸'€Ò_DÙÒ≥o^_±¨¶˙æ¶t¶È4Zà ∆Ó>qY2ﬂ4$äºÉ† íù≥F@±L?∏N2/≥úÂ•ê“<ƒºPµ' ∞Òß£zÑÆh5˙˝T¶EÏ0,ûlÙéÇî≈_˘ÈÒ•HÙ¶(√ŸFO «˜43≥ç^z≥çûú6‰`“`pçêÙp8üÁpB$œ4z¢vJ≥r	1ÈÙÜvœLÓ$À˙í@È Û&åöàµD¨m±V7ı[ÄWÖ¯,[¢ÜJd¿Ázﬂ!R⁄n–}#:1©hJ-eYcÃ+zr¶2íä2⁄öJSëûú…’)`€rÀ^Yâ‘âpLÑ„ñéê;†∫˙^V˘Ì˚|q[î%°–ûpd˚BızƒœsÇ˝òy‡;&7Ya∂±◊ß'∞¬`"ˆïför±w´›ë–@Ï6Ë7ñs/Eñ•‘bªùZ∆©ûªæg#ƒX@°˝«Sãíx ü¬€÷ﬁˆ18√X‡2±©∞m∆ú8‚∏òÛ8¶∆iP≠å…≥ÿê¬≈4+ÓÅ∆˛%5≥;π.nÉô]Ô¯kdvGEÊ÷@;‡B zasÄΩR"~»,åDk"\a‹õv	¸%Ü01Ñ€√÷L!àKåXbƒ #vÕíhæ,º!V±6ÿ*u√π1ïâÒc‡˙ÉÛ…2"»¶ù¡;∑€áô·ì≈ˆL∂YéY√÷ ^© r˙sÅµüú‹—…›‰ï›©»AÌ¨Æ?qÙ˙ÉØ[‰“és·=ÎƒªiYŒ4ª«.öô‚˘˜‡°!˘wÌôL-ÿò∏ø(ÓèÀxÚÀ+ﬂªúË}†ﬁ»b≠f∞¢iV9ƒmíPúÍ≈Ê_%í>_|"$ ,>§öoÛ¡ Ë4¯ﬂ·ˇŒäÈ˛áﬁ√m…ÃÎµ	âèL[Å”V‡¥S»∞ãaëß,àYÙ{ïèÓT)+€ÉIØ[3ÉX∏2—ëâé‹n¥ÙiX¶º÷Ñ‚Ú$"k¶ìƒ‚ÓRëÜŒZë I”ÆÇ≥…6KÉCJ˚åÂ¬:ühZ¨	¯(:qn≠—ªùè⁄‘¢‘≤Öâ°{p]h~±ÄT"Ë¢:ú5‚˘9V‹‰¬|‹\‚¬,Ê}çTòÿ‰ƒ]À∏¬—?£7]øx˜Ó∞àzñsbªgõ∆ÉçÂ› \–ÿß‰w⁄eMLZD“ˆ]=´vó5p“5sâ±w«ΩòÕ&›ˆ7h◊‰
+1h,;Äd–^}ÂÛ
+∂É˘ô≥„%œ3–¬6°ﬂê∞âÓìßg5•Án=ùä∫Î"∆3˜‰≠Ì4≠$iÅTa≈È€…pFÍÈèG6ÒY—∑=G%ˆ£®#◊qvÀ:ª h8VH$d"!∑ûÑÙq∞¡≈2¸dŸÛ™ZﬁUyâÓÁ◊ãñ2¢Çˇ¬¿˛yµ⁄¸@5[JVΩ[XJÏ…¯	ü≤∑HëÊaM≥P:‹µÙÊÜr¯7¯gmgq˘xEŒÙP@⁄OË_ Û…≤éì~âRGS`‡Ù~∫%EDf÷ô8MfdÎ¡¨o*µêl¢[a‡5#k>(	9!á≠]Uƒ ˘‹Ã0‰„\S<d>πâŸ“µ+=†ñ∑∂EH0;0<#jª∏Œu†x*Á÷!uHdº?>»~Ã;N‚eç#‚<úñÛŸ¢z‹«Ïâf˘Á≠.âf~$q÷& "Q¿,«˚2'K>8‘ÃÁH7'863BÒñŸT§ hÄÕX^≈) ÏÉÏDdErüÚ¸RàæÂ]äk~‹æìÚ√on°	‰MV'ó±	"k“ø/GÔÜ@ÆõõvèLŸß%†kπjVI·ú„e8Ωî]ê[˝ÛÈh6Œ‚ÿ®mQJ'ßDLÊ
+¯F*äxœcó,H∞QTyçî8o√ÁY™u?úÃ’´tJhrOMbh =≤
+Gs	ñ´ÎwÔÂZ&À˛¸ˇ€ª⁄ﬁ∂ç$¸WÜe@‚»vÚ°Z†H⁄â{˝Ç"1âNä‰Â§æ√˝˜õó}Áí\J∂ı6≈]+ìKrEÌÓ<˚Ã33êO{™\ÆVmV+“ÉÈgØ/iÙä|eN˛]Âô.ÜÚÙ“/ÜÚ.Ø©ÖÚºT.wüe\Ã§ˇ§¡ÒhºîjäÙÜc]•oƒLÿ»™°gv'Üß“”(€w)2Co<8aJÂNo[Éô6oX†‰ˆ°‰ÒKd‡Õút†Y*|Á‰,üÛ6MMmag üÙœ[ó?ÈüÎQÈw¿]ú3Aˆgòˇf§√≥[—HÁ%…t≈ﬁ≥ç‰vGX≠Œ4øÎf_á≥[C¥„H±GÕ`—NÕ—Åˇ):g\Íã˜]ŸÈI—9)ŒN≥ÉøYÊ_”\‚´´Ω¢°ñ°KE≈†|≥âfCPAsZ©∏¥îR§úƒWoÏòﬁèπö„’J|ı¡≈W◊òò]&*5®¢µ;‚as·ëRﬂ8
+HÈÍÎ¢≠@ùd8“{ÑÕMè`~u≥ò‹OB¨è„5“πµÖÏë@±&=≈Ω°˙0ij‰ïyôvÁ(ß—ˇ¡Ñ‹¶◊©RtI2ÓõxXƒäP5∏j∞ƒE)B^Ú“
+µ7Eã´ÑS*`≤&„·*'T∆l@5wóΩ €ä™1–Üé'£’``mıRE+ÕE§<JˇË¨π∏]G≥aQ@Zd≈¬òÑ·Ú˜J¿/hò{¥ìê(~ 0d…gNñY	¯Uﬁg	¯C!*¢lân∏˛Ø6©aEW8∂˛˚"ø«[mMÖˇcœv;˛èÁe:æ¶ˆ.æ&N2F∫ú$]ıà§§‘@¡mÔë9ûØÉ¬H¬I:ı÷ã‚•›¥píVÉ”Áÿ≥Ωq^VË'âkë/0ù#YÖìåKn-+bW
+%ôw»Õ‹å›o¥ƒ‚Ïx,ŒÙ‘´¸«·jÙ˘›h8üÁÀ‘Tpﬂñˇ2Æ)o.%µ-‡èOÖo 4ÖºúLªõëRBAÃLWıù´¿C	∫‹[∏¶cæ˛Ô|¨õÖG™1&,¨ä´q5~Ê]i≈èJ÷˙ôÎ¡Èk>”wcy/ﬂ=¬¸I”’§ó«& %™ò~ê°01A™HW∑L&4$˝ íwFSêë•é˚√©⁄w≥NÃLuåõiŒ¯H¸	∑›0;∑∏ô∑‡fÆ∞r˚¿öµ>∂ﬂëñõçODﬂV6)Õ”öQû2*{”¢{÷ÚöŒëI6‘°k—⁄Ö¨Ñ/D2üÏnÊì»§l‰ÈT¨ö]Vû€è…Zÿ6Iç-bêo	ˇ~ËÔÎ∑±∞5Ú J u¿bv2ÅØ≈M>r— Ó◊i©¥îÄ’”)›á´Æ(yq£q‘Pâb˛â=ÀÍ∫(∆ûÑ4ÁAËç¿’èŸ`êˇªNOÈêL§∂T…‘oÂd’’RM£ººOÒ&O¬„%IÒõ~‘˘C®—E$∂“µû◊˜˙z©¿fÔÂ€|8F°Ç9‰e'”vK[%>ËHÇË
+:ró¬¢ıÚ hx3j‘ôÏP)¨Ëæñˇ+[¥ OÚÙHGì‘æÑ%MƒçÉv\E ]ïé$Ì<IÔòπ¶‘9!D1Cg˛‰$E@®a_	⁄2¬.Ù%bR¨‰f”
+ÇE€M_ü
+S∏–õ…¥—óÇ%#ï3T_vë≥jáPìUÌ0à2∂i’yW◊ﬂ_r∂¶ŒÙAkTï)4(Jﬁ§^	·ÿ¡`ôﬂ,¡®¶—kÿbøá$å/NñîÉ—Êp‘+ídv¨äaá¢zøÂØöT¢ãIa=€D™Óª∂íÆˇU∫KuYY[©N¿œØ˚ß\QI≤_«ÿï£+YbáÛµ8"Kqˆ%¸O∫.Qt~[–˘πãS¿eÈﬂ7ù4RWî(£&>K]ßMâ√zâ˜Ø˜Ø‘xπ∂’¬ª/ﬁ?=≤÷cejl`ÁâéL¿"ñõä“˛òOÁãoÛwl}ªôˇwµ´Æ÷öﬁBˆë¢–qË»èXVnÑñï?—í…BNr˝ÎTubpiÎîTÆIôßZìgõL±&^jæ}ûÃÚÏzyõÎRèñ•ñÔÿõ‚¨˛dâ∏∫p ã~jˇÙS˛‚µrµ |Öºp«$S?.≥˝LÖËEıª+®ü√æ¸ß˘jy'õÛª7‡4A]N/iîLj*∂àöîŸQù8„Ÿ{S∆»Ê|õsy
+≠∞˙Ö[Xaæ¬Xa’#€Û#¨7d«÷zt'Ω˙àq˝I€vwúP¿jÈ;ØÚªb°®Ê„7y>Ìf¡ÅÍç¯Zû;Áö0w◊Ÿå;ø-~],s¥Ûìº¯ÈÔQN<d»c«´üDës~:ïA´.¸˝P:ôPùrÓ‹á	€+|˚Âv∂xóènAtÁ|ç S’ﬂ§.É˙Q ‰eŒÍÔo@j 9l∏õﬂ;‹ÎÖ?b_S_‚s8$üC-¬≥X”2fXhGıãp}(s™ÈÜÏÊiòåQ3–Ñ¬¢…êˇÄQ_i }¶%Îﬁz¸‘ææh∫â™„tÙW≤xO7çå≥Ôv-µ5Æ–” Â/ﬁÈ˛ÜØWÄVÅ√…W»îJälì^B¯±”Ï£2YhÓß£sW¸õcyﬁ.øÉ€ù(IÍvßÔ∆ÈËµ*§œTÇ¬ÓŒÖ~Æ ˇÆÌﬁN¯4!Îvõ¨{ïN‘¡Æ+Æ◊ÏHX!Û]ŸAPbÊSÎœéäi‹‘j\Ña
+#¥‘¡Ω„ΩıÍV©'(P=ç j√„®¶¥€°≈`
+∆o*–∏wÄﬁ¡&¨˘åüEgµ8æ^∫J«ëi˝ÆX–PA+Zv?sÚBº Ó>ﬂ®¡ƒ¥ê¿%ö!-Ÿ±h6∞º¬6£=˚ìèÄáˆN–ù(7zõ∑≥U7≥ü´	ªD! L_ÁH∆)!9/apÊ`‡„.$8d¶Rh	…)9@«L∫SﬁzjÄxhı÷(~ËØΩª˛˝ç≈>Äù∆˛c±”f$ß] dñ&'à'¥•{öeÈ¢k€”&ÃY≈
+øâ—¶±˙®ˆ›
+ø	K0≥h¨∫êr^öÑË≠ªÂ"ìvo,∂”Q·6«ôàQÚ>’j∂Ñ˝ëp|⁄éLÑ˘n.n≥#1ÇKµ¬©Zb5unG≥Eë£µO('Qp3Ä»m&ñÍÎ—†WΩÊG˜O!oq⁄í”æ	%>3).ÿ-∏`K+TàSî£"›·©÷	◊ì€≈∏<nÕÕ~•Æ”ªßïDÓm¥†7º):ÚïØm ÊÃó∫§ãˆÍ" ©Éeo…˝yÑÆª:≈âe áÜçËóˆ/ú.≤∫ÊìWÜt„IÌ]”Iãö1ùf⁄R-S—√ÏÆÊˆfÖA0ˇÛÏ∂¯‹$å°ú°`q@cr{Úü£|6€ÒÑø˛‚¸©£ËÎ2º‚E“€ë◊øºªÓ⁄≥8%:/≥€/Û?Ë]u3˜/œ€vv¶ï;·ª¨N OoRyéÃ´TSÀvü.ªo~&äÃ’p |∆ÖO”Õ‡ˇ@Çé-ƒ∂”z0YÖÕ&Yw¨ì¬—Ò‡¡–◊-GcF-”˚ÓO≠”VÎzÊÀˇGsÁHÙS¸&˝>‘3|Âè±ò¸>ÕŒºûˇ:ºQ^øÃπÊ6L˙˝´l2œ˛ÜtÙüÚéæÅ‚¿¯aY6 ÷≥ﬂˇﬁªi˘Á¡÷»‹Ô?ÉñÔˇrûÖ=Œ©õP∑U=ÂπﬂÀ◊ìByÙ&òØ˙y‰sÿœÁA?·˘˘,ˇ“ø∏Ä∏´¢á:©ü™]wÚs’WÈonÚ˘˙œwˆ;gávü3'ÛÂ¸oÇ,¥‘ΩW/Ò/Ëö∫µÛÇÏ}‡«ÚoìÓˆ
+iR∞(òó∂tLÌ]úD —UzpÜà◊é(ÌŒ±k\z«Ã5•Œ/ìÛ`ó›2W¶wêqBzÁ®ΩÈa+#§wze÷Bn)ßA≠lñœô‹¶[Bé*û îí§/˚ó›Ø¸Å÷N;«{p£nÌ"Ó<YΩè©∫Öæ≠óü”ÆÅ¶{¥¬.ÈGöevâo˜=.é∫Ö}<à6®√ﬂ«|~•'€Q‚ù
+V$Á+	5π∑‘d∞l%êìPûbÖπ‡fCïÕö(– Ò√˚·æGá∫EÇÕ!oW„Ìiö√óı˝Ô'»∏.ÓÅøì⁄4!ó°‚ä]è"∑¿hm1ºÜÜ„(7„1πaf∏K∑8O`ºËalÊÑáiù∂QHõ"”∑NÒÓ¬®wz[öt±^£&e3¡ü ﬂÌ#_6!ˆUÀ]:å„é”2Øê∆I√4’‡D_Zó[ÑVP˚R‡µkwªÓÑNzw9iÆ5'VHZÆœHCπ˚'§ıd;≈Æ"4„Øl™=zVC≤uif|Í}±Ãx/Y¯ŒK	«LÀ¥pÃﬂÅy™ 8ì'å7≈#XZ	T€CW=¿ÎUÓX∞ ¶	EŸ[É¢$#”⁄¬‰)I√Q2êƒ˘ıÅFá ¢&	C¥hô∫å‡»=¡ëçåõ
+ÖCÜ)∑VÙõ≠& òé‹ßÍv0 Kπ<j‚pè§SÔ¡∞t¯ÕQ N]p“˘ItP^é@”¸>˙Û ¥{zàÈLöÇ`c*;î¨√∑ÏH_á¨k
+aàb>¥['‹‚tR™I)‹"íè√bıa2.Ôz˘|¥Á˛ãz ¿‘”h∆)d‚¿ò¶í…©GπDôE=ï“Òó∫¬Ö`dM©ﬂô…¸'uùÓΩ”*Zäë¨BzœÑÙ‰ÿiÜæ<‚*ÓF™êõâuFŸñ‘dOF´¡ ì7,ˆˆ>¢«`0œUÕKO/#„ö‡Mv7—ù¥4,£í\>n¿…˜ãÅ‘–—˚ËÍŸ:œ/w[¡Hze"ì€ÄµµÔL±æaP$l%Õn3^Ó*÷Jb[KP/û	Í%‘∞cmÁ≈≥6‘KH·H;/û9"*‘_ëzÚS#◊Ωjâ‘KTÄVHP/üÈn^^∂í†^>/ıÓ‡R©Ù|ä^=Å$HPØûD˘TºëR”^^¯‘+ÉW∏ë}i‘Àæë†^^‡ ≠˛±˜	_m2ÔX¶i€yT∞ÏòÍÄ◊UkH:ÂJŸ∏ﬂ´ˆ≠ŒZïéê…D∂p¬S{”+2˝∆ÔtÈ>ƒùWÁJ‹yE´}=z|∫∏Û º.OGŸ,Óºzw^ëÚù≈ùWŒ‚≠ƒùW—Ï–•'[ ÿ;ÃuÁeõõåÕe8=)&Ûb5úèÄæ«≥™zˆ£c˜è)±s<’ØWÂ[·G7CdËú® ÁEπ¢,π√≠XÉÓR+ºHÔY·7e«Í¡_:m*(Ö^Ë„¢ª(Ì8HK∑?ŸèyP5˙R—wØ¡p;Ä£ï€‚Oíö$+¸gµ@.§≤¨ÓcæZÏ]íOwçºt™˙yuÃΩôzˇ'5Å›¨yâ‚‚⁄
+«Öd8’`¥xS#¢$√fQÍ#›åK®ÇÁ$aõéVIEª ]Ã{Íöâ }ÍñŒêP{CEË•€Ï¯â/†6Ìt\÷wà¬ëv›yÄ¨ØÇÅˆQ&∆…Ó∫áÛ—…û_©$bìÿ°Ö«yYC¡;vÒ—"JÊl	H¬„1Pï!uóˆ•ÓR∏4∂W˝ƒÈ÷é/p≠oRnæ¨Ÿ=!Vo?≠ûÏˇ'ãπÏˇWΩóo°ÃÕ√,øÜ|V≈Õbπr‰R´œÀ…«’`çË1€T¸ßî<-.*ñ˝?xf±L¥~é¯»?ÆÔ¡≈!Q5±∞ Ù´àœo:} Woﬂﬁb«&`π¯∂°€Ó  ºHÜéç™˝?\Rv¯√Aÿ‡aƒ’/€~⁄ˆÛêê=ˇ˙hïw±4úÌ‡◊á›	¢`œèøo˙ÜZ∑ﬁÌ√5≤’/ä¡ ¬AÊ√/ i∆·a⁄∑˙*Z´ﬁ¿yÒ—∞ãÅ∑c£√:dDª˝ßzWçQ”U∆N›¨l‘	0z∫üb¯–5≈«6Œvh–¿+ªÃUÉùÊ≤ˇ‹¬˛”µâ—˝ß˛Ò”-£∫¬µé¥êôËBSzÃw&d ∂Ò¿l„œãŸlÒcM˚>»‚÷≤â‹ó´zŸòøÓCØÛ*øÎfØj3ä›~ÈCÄSÏ\_⁄A÷I’‡ëJ®ÜWóm+úª
+ˇ∆/…5l«Ë˚ä°=@CªN⁄'ØÚª≤âÖSö◊DMÃ7nê÷j5XÌ÷âØ{±/æn∞Ò˛Jl|qÿ•õwh]2Ìæ»«j+≥Æ%f4Œ“{ÇÕMWhıéÖﬁ·X5£X ∆¡Bå«ÿøj≤˜Œ«ô•ıbã=€;*≠Ÿf{o{eX†wQí§˛&πcçr—ÿÅÊû“f˚l¥µ ≤ıæY™t@*m≈kÿΩ?=)^ú,O≥ì¨†¢õAç€\€p*{déb2Û:”F≈cÙñ=‚äoÅö¡M;'≈›U]1ö¬.˛a{‘≥xúãèOÃ…âèW∞UàV/)©,H-V◊QPOŒœ+.IÃ+sììKsKsÚäÚ+*’cπ ¿¶X¥x=éQÇ0Öﬂ˜+¯R‚kΩIJIÂ '“£Ÿ¥Å∫±-»ﬂî’ÀÖsŒΩﬂπ	ø≠Ï¯»um˘è	Ï•EkqêÉ=◊XE·.å÷$pÀ	EN“$c(ÛKZ∏”Ò-EQ∫¡N1[úsN+T?5Á	ÕÚ„ÅTV»—¿X-∆n59ü¥Z∞KyËÉí⁄Ç±IÒ-ÿïSw‹´Ù”‰íX©^4ıå˝€h›≠Å'm˘ÁnMªç"xÌ]Ìo7“ˇûøb—"∞8F¸&€yêé„¥æ˙%µÂá‚ (“:—Eñt⁄uﬂ·˛˜gﬁ8CÓR“JV‚Ù≤≈]ºÀÂê√·p¯õ·ã~|ÚcrxóﬂßÉt‹Œ”nÚÓ>i~˜nÚ‰hx;Íı”q≤˙|„`„˘⁄ì!ÛÎã‰¸¢ôø>i&◊Áß«WW…ﬂ/Æì√À„‰Í˛i˛|ÿ§î_Œ/~O~wo¯˝ı≈…˘OTH2ÂΩ· K≤|‹ºëåÓ!˝…Õxxõ‰T˘Ü–ª«y“lﬁè“ı§yñfY˚}*o«ü;)_G£~Ø”∆b59,1∑ï¶Ö∫î†Ê—xò;√~‚≤ΩÍ⁄„˚∑íuπ«'˘¯˛≈ì$Ò˘.Rﬂ¥≥¸$%vâ@ìó…˘pê>yÚ§”ogYÚ∂=Œ{Ì˛/)|	"|ô<á*‡©utq˙Ê6ÉLˇı˙>lE?`ÜﬂNÆ‡˚ˆ¥Ô≠Ê…Ÿ1d⁄ôô©ı˙k€}9[øû^_µö≠Û√≥c¨Â?êú$œ_$? ◊?¨”€&øI$q+HtÌêè€—è“…≥3-µG2ÓŒÃàm¢Ãˇ•VQ[∞Q‹<m5ÈEÚú[ÖoÆI/íÕR¢6ÈE≤5Ò£k“ãd{Vn“ãdßRFj“ãd3C´X¡öÌw˝Ùm:æÌeå‘∆À„√◊–@Tûﬂ/Oö®®(ØÆOiùúΩΩ∏lB
+j≈·iÛ¯≤’<|uäyv!ÂßÀ√s¸⁄ÄÁ◊óoı„ﬁT›†éáZΩÆ¶öΩnıj˜˙–„@R–≥ƒÖºÔ¡ªqBâ≥z±bF¨3|FLÚ>#"‚ƒ1Ú"iHˇxåºHˆÇ~∏∫œÚÙ6Ï'MG–+Õcï'y+$éΩÂ1)ÿgBu}u|	)ÿgD$ÔÿcL#	ÿmWøj£Uôﬁe8ú}9„ÄˆyÒcœüíàCŸ„URqz¸J*éTÂY“∞èçoIƒéfﬁ)aF'3Î6p÷mËz¨õF¯¨õ^¯¨õ^Î¶Î¶¬zI-:ÌŒn8.Ø`∫§ëÜ˙Í∞yÙ3Ù“Ê‘ÅÖΩƒd"%Ï&"≠"$°4)1•àGM»xïX@&O^+ãó◊ÁÁ¿21ô$ø^_≥]ÅlSß	,√„W ë‘(.´J®(kÄ+ zXäíﬁ’6!÷iw=8Èüùú_‡ B·ü_˛Ñ&G·Ÿ·ﬂ(‡õÎSú∑gˆ	Ê5ë
+ÙHÖ ;é,∏Jsπ\k/ók≠ÂrMï©\—·H€/”v∆sÇlºl˝—œo°≈ÿxÈy2;ßW }jWcπûºú$ÿ”Xæ'O3»\`=U‰B’òXt∞π)ö™1±à÷∏˘˜à™ëA≠b:…!«Wù!èO˛ëSê√ø·#JËÍËú$4KHÓâ∫ Ω¢ ∞ò*-•R¨•Täı?ïR‘ıfÔñ4ﬂ”ãüNé;íûüúûPúmeÑ–o W·Ÿ—zl3≠YA+ÇÉ¯·‡ı0o·›]ûf»yÚ,?Ò†ı7Ì€^ˇ^_Ωk˜{7Ωt¨)øı≤ﬁª^øóK¶§êÂÌ€‰¿Ú·ª≠lîv†Wëî–˘zÚ#ôÅ$Y›¯èb„™y	∂n=Y&V÷%B˘ıdÛ£*@˛≠R~Â5FÖ„
+®∂cT⁄§!éB ‹âZÀcîÄr◊Qû4†êïNåqƒ
+¨õﬁ$≠Vo–À[≠’,Ìﬂ¨cüºd1hCÌ]õ`I∆ú§iÕ¸æF}ù`·P6ÙãÙ:'i%Aü©EDIZ'Á–◊ ìq¡πÏ›≤)cêEüù∆iª+Ë°(l˜nz›hµ~∑Z…ÀóI3Ù(7
+ÔáùN
+n7y„ÌA7≈Ä¶:È*Fû,ˆóÛ_7é¿rwŸk“ZÇ§$_≠{Y2Ê§Æî¡‹S®F?±Ã¡±U?u£õvÜ›¥≈Æ¨ﬂ“·Ü“¨ùÎ•∫◊÷HñI2NÛªÒÄ^∏=(º´||◊…_•Ô{ÉUŒ¯ÈíÊ¯ép)ÈÕ†}Ï&ßh¿MØª}aeºÈ•˝Æ_Dí@Pnª‹ã∑Æ}IÚÍ˛(|aﬁ^snZÜX8Ú-G‚+ß1Ç–∆Í⁄ˇIÈIíˆ3m
+6áÛf{£U‚—…'ÀÂ8Ÿ≤z*s¢„ Œr¯Ÿ^åu_Ä•ù≈X≤!˛x⁄ù∆XX˚,⁄£%`r.¶@æ¢MR3SU7«ÉÆ<˚¿ÉíøÄ£πˇ4ÓÂ©åˇahÈË’,¿ñÓÅÊä {¥¡|z,îXõÂ•g¥∏™¿∑Z+ VV8;Uù∞"f’+¿3YÇ$Bx±ÈÍ˜hd$ª"9ä*Ïòa®Œî“ Y€äTÏ≥¶îë|ì4K1èJVbs;R}ÅM%édùÃ©g@Êb’ËJºÓD(j‘ëºò5„RùQ•Q&	ÓFjE+≈#◊AÍH¶kû:”ó´|8Û„}Ç∂(ÏœüÄÎª ç®FAY26kµ∆Èh,àT≤†õ˛« ”ÏÂ”ÒJÚ4Y˝òﬁØ'P÷]ÍxΩéKMz¬≠V∑◊xªfMﬂm∂∫ˆö“π÷
+]}ö≠Q©$Öz`
+Ø¥ZÄß·ˇ∂9$¶¥’Jˇ•∏yòH«A{|‹G_Ri˘ƒs\¢Õ•ºP7ÛmïÄg∏Àï!*§ØZ…!„£aˇÓvp=B±„ƒ5¡”Òé“yÜh\«ï¶òˆríjøRác pû•˝>º?ƒ?S∂†ÿ1©Ë•)˜1¬iéö52FYÙ‘hXM˜∑ä.ö˙û$ØX%Ë°ÅS◊p6˚’≈≈)®†	5FÑ—`O9∑N•hûõ «í¨ÂqgéGú|3f8Aîü∆êV√Vü©MÓ≥÷Œ9Ù5»d¸p.{∑l™ÇêEüÌ3â>©j≤Y0Ê·õΩ∏—VªÉ<#®≠˙Ó‹A’Z–è P?ûS®c‰∞¥†_hÚ‰yYeﬂÃÓóv¬ÃãüÍ≤5/1„œ≤ïßa5ï•ÇÛÑ}ﬂ‘Ã[–IØÜ√~ÌùV¶1Æ}4ÔÙ»Cq7’lUuˇ@i IÑ~·,óU)Úˆ ¡Kp~4êòÒöãG%+±Y¡}U‚π8ıl⁄\¨]â◊
+>¨QWgV·N,ˆ[Ïé´@ï˚ù lÃs]ƒ/t=Œ÷Ø∫¸(In1o’˜ßâ™∫º<CXù3#Rˆç7"ìM%àkdëlÖaRÏ™⁄ô.˚∑ﬁ" £:”$¸√8ÀNp§!
+Å˛«3ı9sØèö‡ÚAa†w´PÌzˇlxãA∞NY≈vC´‰<£<…_Ñj≈Õ#Ú≤á M¿øì\-H«xsÌI}OûËl	~≤¶¸íﬁK|#ÇL·”)Ådg(øﬁJÈv äevYh’Ø^¥yúE≤«HåJW}éá‹:πÉ;GñWa0MÁ®©‹:ö¨ù™gnoN÷lX≈™≥B˘}fhó ,∞KT≥ô*≤[çoh‡.ÕÀ4ªÎÁS†∆ò2d7ná„û@∞i±ÜîÜxC]Bà>hê°ß áL"ªFÓ†‰πPà0$HK(…V‹yë “I.5˘ﬁˆ˘†Ró¿àiÀº
+»hdµï‚û$ÿ∑◊ zˇNüá˚íN{Y∞≥âip¡±’€¡ï∆œ∞ëÎ}∫*¥~•∞ù¬nwA› 
+`ê˚ÖAäìÑÎçˆhî¬6.“ô{ÃeAF‰’f!¸∂ÙmK— £å5c§/zì~ÖΩz<7?Zx—¶õír#∆kçS"úêìP(à·ŸEÒîGe+òoí~:`ØIä“≠á8Êp!ø°Î˚í√±C?œ¿j≈A‚±TÕ∏x©wu`vm?OÄ1g·"$pz27≈/5~˚vÒ€%N	®ñ¢D∞#xú3p£«ìAßóı˛D±£6‘ÿìˇq|Á|ö™	ÒLFs∆ì∆ÖºNtÖ= ¬&U´ª∏«BÎéT±™q£≈§à1.H2lÑ&Gﬁ£VTÜúD3:˝≈Nb∏ñÍæk9~∆·à>s;jØqÚ’hÅ∏é¶2–\r«øè}	±hö”=¿ê$±–«(î¸: ∞4ñqïõ∑ıœ⁄§óçµ	‚éñ&-o;råÓÌ†¶CQ»åˆPG8å¯e´éA>Bí¶˙lÊqZ1R~ò”B ¨†ŸﬁÖ!#sNæTKï¡*ò6¨s6∫uX«≈¡[Å°‡t≈]}Aπ˘ct±yt©≈÷⁄Õ¨¬l°’.a¸klƒF˚à∂ÒLÒt{‚≈“6Ï≈¿?üt’íc–y⁄yW›G#ú∂ä¨5
+ÆÜw-´´57ÃÖ˙l®Ÿ'ÊZVΩm∑>≈…^îÍMÄß≤™ks¡≥ú™•Kc©yè ÚÃxêû©\ux†4
+‹ôE|ﬁƒÓoyS Ÿ–¿·) 1úãG%+±ãfÿT‚Ÿúzm≠Oì·-ﬂi≤wçJöÁx˜L–"ú£qoGÓd3•cHÉzºàÂoÃ„$8à<J·Êºﬂ¿8'€pQ«ä´0S&‚‰+F0ÒÑX¿~å≤Ω<;|KÃπ&ç≠Ø#4£5qı_\J∏™>-¥È⁄-([$èØíf≤.C0WLUÓ;àÁV,>∏é‰ƒ†ú·äùÀŸ¨R*⁄â¢nﬂpÉ°jãu¢YN◊PN
+ A∆≈éß<±âñÀè≥bó0ÍKb	∆R õÂ45d	V´ƒP0äˇÛ_2h`πßı#û˚∞Å‚O|8êù{I∏ï‚¨=í^èö∑Rln˜RÏ…ôRÆˆJ|LÔ7∑fH3∑`C‹ÊvÖå≤f˝¡5¸(πèI”hƒ¢[,jË˛–˝$Ñ,¸Æ∆ß:4v$0ìÛ¥M¯#›—àâé1öÜl'CTù'ÃÆ¸8obLG¢ÍÖˆ®:k]âG’z^ÄÔJ‘’ôµA=G,ŸàîMBo±ê≠ö≤ πY üÇn∫ì≈J6≥|ƒ÷mÓ¨ˇIwu[ãe«ã+“
+3∆e9I)N8	‹œç≥(5•T‡≤x
+÷Ã˚RÿS¸rq˙˙ŒèoÛŒåV\%Ì®8<¥ˆ]˛\¥”µÎ‚ä—VFúˆ(ˆáH∫ÜÚ˙ÓÓÊ&_¡fI)˛xgì`ùqˇ‚1Ó8Ä1WvåB7(‚∆ÒÊb†≈∏ıÑ˛ªî›ﬁc(G∫ ’ﬂ§";†!TÇ-¡ÚW-˙≥ûÿsP~»h—	î
+TäÂ*N¬Yj=)$L©¨x¡MG+÷EPYiﬂı¥K √nøë$,œ"'y”F…ªUÃ	˛Õ a—†&a*{åT|ßøñ,5√y≤O |‘g˚l\¡w{©]–ÔŒΩ:.o’4$KÛ`ÉçlﬂtûÕf#ÙlÆ“â{ƒ∑û ∂˘Uû∂tom¢Ê“‘çß‚ Nûéê€çvW6Öo)≈¨^QÈóﬁŒ[˝FÏu£¯í6»;Ù°Ì†œK€Ç3’«é0k;∞óÍ“û˛≠≠∞Ømﬂ≤ﬂ"ˆb∑ho≤" ®}π∏ŒﬁÉŒ∂©$–5ÕçJO∏élÌ˘,ô∑</v.`jƒ *a5ƒ–⁄òå∑·FfñÒ~uoo‘÷~L∆€8	Á’ò†∑∑ßZàz[=óp∞-G‘SÔúÅ	ﬁW)j6•V=–˙8kÂ+ìŸ…y‘cÇ€aä–‰œ·”ÜÑ ≈_E Æ”ÖÁ€ÈD˙µÍ…ÜÂﬁ,éìm:EÊ4Öı+„[ñô–Y.ˇ{8qy_
+Œ©ãöÑS=6A˘M(r¯W„&6â-∂ÃM0’
+eâ55ûl“û"_H{Jä*wë≈$ãııƒÓå∆-ú«‘ÑnQ:á‚*MA±`ÃLYhaeiÿa"ÕTê«Úœy∆∫∫jëJÑ<Ωÿ59hˆ”Bdxz´ÿèuÑÁ€=_Ù™ùw><0Ã#±1Ë*?=Ág”W3.∞,é÷2Ç<;!SâÕ\¢oã¯Ñô‚Çæîjˆ÷bOŸêèÙòá%≈{≤J©ˆ°—ûÄ+w≤Em§{‡ãß•·÷$SÀmî¬|t:ﬂÍCTﬂ◊!™Dzvûãg∫Ωz¶
+ê›ÑäÓü‹PZ¬bòë"=;U±#⁄"=;
+Q±PÛÛÅπE◊¶+Óõà∫˘<la¨≈|¸∏«ö|¸ùÌPíÜ⁄"¢‹+˙¯@Â>‘JS@Ã≥ﬂŸüÓŸ3ﬂÅ[ø≥Ô3cí-Çﬁ≈"(ÀéQÌ¬∆7ñÌAuŸÓnód{ìÌÓ»vzåjwg∫Ä≈jﬁUÍÓr$º¸’.nk¡{AvwÁêÒAQ∆@—ﬂ∆sêÒ…ÏU„˘tAÎà∫?˚åBÊˇñ≠Ãs«®lN6VÍ ï˝p◊∑OH—Ì¯ãF©4QGfX°û3,+18ƒBf˛§ÎQÏ JïÕ·yJ›~ˆ]x⁄î:!(ƒ%ï¢ 
+©[∏+3AP≥∑ñr»æz¸C(
+RXjh¨A3#âAj+»a{ÈrP√=á:(MA:±Œ£ZXY),ñ´ô
+ÚÿY∫<‹Q]/ÑBe1;(&nnÙ§U∞≈/uDÏ€çà¡t7··†˚6M?¢¢Nÿ˜€à)'B£g…ávvû~∆ªx	q…ä^‘LeÇŒ∫/—Egh'RqGì‹u#LAi•HŒ¥∑é	€H)Â¿åÀÿ”=N$À'TÕâæ’ëìÔ+rBzm∆^ve9e›¯E>pªI\¶®√Úun¢16G£æë–õRø}O√ÈóòÛÇ£·tl–‰H'∏k—“á⁄ª–Ö!NÒ<QªATƒr]¢P(WUÆVöød¸¥„ˇ»Ô4Ç¬Œ”A>π‰¯#·'].È†{9¸ƒœ£q˙'¯†¸æé°+RCx°ä;e≤¬åƒHäãnJb¸∆»p˜Ù§ã¸ÑAA8\µºX°eƒ#d0qy2‰Ö$.æ
+î?Xy—^Í-√ﬂﬂñ·fÙG„M©fî∑Ì.Ú(rÛä™´ÍÒ≤ôô∫h1Å.0vñ√P}xÚOÍ¨T `Nı´°P†„ÊÖ_@íADÄLËfÉ]ïqPù3&(1ãØ˙å1Yuæº!Qù7#*Òã|˙¸Èl=ŸS¨t}ªÅÆ£á›!«'˚ÏÔ<0Bú¸M˚∂◊«ü–)≈™&BF†“ÇbÑÅ#Î1 iÿQy¿ËsaIV~Fj	0´È≥!Fø@Œ°≠2YúÀﬁkpYÉKˆ>TΩñ†*ÓôÄË
+∫ΩLg,-2Å%9KSç3g—§V ô6™&•)·•Y@S)g√%5ÅD¸°Hü¨ƒÊ,ÿÈœ≈©7TÊß—ïxùAÅW£ûÕlçBˇ:∑vr¯µ‹8%^ŸÈ˜ †â–ÁYró•c~"èé€Ô›≠Ä›~⁄Ïπ;Ò)Œ ∑àÁÚã¥Z(÷ƒª)¬sgPÃÉ‡-µ 4'b[lhå`"¶%yƒ(À¬5;Ó–˝V˜
+»,ñπtDËVz"◊ﬁ≈√ˆ\ﬁ,D'VPˆ±‹ŒΩÊ¶˛âeﬂ„Ï∞w2‹â¥¬›$∏NŒo˙-~Æπp≠îÔsÅp üúuÄ„àTd=·øAπ·…ê.x6|%Îû‰5hƒÍI∏asûÀ:6üKupÚ9®Æ‹∆‘ør5pRòúGû85®ëÚH∫&œ†HÚ‰¥ƒeêGÍ_yÊûìÅÚ¶≤í˜∞1ú(€_)®√Ï°Û£ÇQ/≤
+…ŒXp"1©j88¯áD1!ú‰ÈÓëƒÕë$hñ"∆Ö)®Åê™ÜÜìπ≠êŒVà¥æ»ì}R!¿G}∂œ°L OòP{~µÁ«∫ßÉcŸ>ñwk :^8ÏGj&∏}2 óÕ "Óû3ÀÊeÍëòsK+-lxå»≥ÿ%Ê˛NﬂK·¡ô7¥5zgÃiXkÀ:¡>À*)këœƒ¢WNò4ˆ¨ñjL8+Óâ‚·\ÏO„Üúµ"ù7‹î7Hqû•mè:0& ¬ä◊≤9,v^´·Œª4Ê8Ô“(ùwjcÅ&}€√Û.GÕ¡ËÁ®Xêúq„˛‡êÀﬁ=‰≤˘‹ZQQº:˜CScﬁ`Näˆ6´(⁄£[¸ãÖÄ⁄X37†÷ìüF%›ò.imD(ÎÜÛ‚±BmÀ9ªµπi™(ÎCM¯æ;ÀπW8Ài«%¸fÒaŒ˝“aN†6˛T‡˚ÊÙ~Œy_£>Àìk«|Ñ8¶ÖEä±LrtÊ	∫»É∫û¥Ckfì»ú:#j«˚·¸∆YT¬w’„Åò|”ê'U^Ø:%â™sƒ0Ø:Kîøƒ”¨–$QUg
+!_uñ ∑2DAõÿ…k‘êª:#ä˚™s„HBñ¢◊∆8ñIuæVÁ	≥?¯˚:≥xJÑáC’uØŒ£¡ÍÃP˛êΩG/∆ÂØŒé`¬Í¸0Å2ƒPs=—ìÈ$AëmSv ∞:KB°<qÙÌ "õS’HTªój∆·ª˝o˚›¶¬POef
+CaVÈÙ›˛Ã”w˚À?}WÄS’ı#$,®…fl“äà&º3=,≤,ª∆,ÃiÕÎôéP‹˚1Àá‹ÿ‰\°^ü	‹¯Á∞7X=Ö.Äh&û˚´¸‰&£±£·Ì®ÀU√iKUlN1Z˚ÃÖî·6¨¡Ë.”Î”S¡á·].	úg1~Çk≤≤·Äü˚√Nªø|ı”xx7‚$X∏√œ[]¬eZA¬ÔY∞™≈ij‡u±5+2¥Ø∞W¥πLZn*Æf…råIlÄ≠öƒW0äÎ[ÇÑU+ì3îR⁄UVZÈ¢üˇDQ _Â‚˛äï^\ÁR¶ÇnçQóºX~^◊«àäÀZë®GåÓV≠º·ﬂÙÚVã∞Ÿ∫,ë∏ï[T“¡#ü¨W%ªLπ?‰%ê¥§ybSDFí®càﬂ˝5'ÅaÂ%Á¬ø8Ÿ+25ÜêÇΩXkd∞ÀÄmÉOŒBp±‹JHÊÀ¥æÔñÕdÚﬁJYD*ñÀ≥4“DâÖ˜ßAAıQﬂ˙®ÔÕÜéñØ»ˆ÷ —?∞ãÏdîÚ¿µ($‰yË:Ã‘u©h0›¨∂X∏wﬂ˝f¿~·7;7
+ÌGJ? ‘æ $`~P˘Gåœ ¢{†ÿ+7YÒb˜ùy}VÓRûY˝Fëck÷j	Ç_Ë2s¨ª◊≈µŒÈÎl_iykÓ56ù7Ly†,¶Æ≤MËú`b˙˝3uÕ-fºI0`g	∂`Í¬⁄^lÓı∫Î·¶È¨D∏ü∏8ò„'.J?q‘˛(v¶	‚‚dˆJ‘¡ﬁ"+Q°[û›™WL>Å?öÆﬁ¥≥¸]o–ﬂo§ÉŒ∞õ∂¯M>ád[≠˛Çs´µŒx.UÍ›‰≠lîv÷4X3NÛª1π∑Ö•ªÎ»ÔÂ¨}Ù¬∫â‡êÍë(& ó)?Í4˜‡‡)¢éÍÏ@nÂl∆z[,AcE|Anáº‡U!ÂñnlFüÉ#R∂ÿuè-òBQaÜ1:+MªÒza˚x&µ rôôöÁ≈Ê4∆Ì}/BÔ”…x¢zOëJ∆˘˛±ÂÅÀH´˜9à’π√Ï Ì‘çÖ1\0|Qù&˘ô∫Ä√’•‚åÍåt üÎGù3<Ú˚1†ÆŒ¨èA™≥ÍQ)£d!bc@-ÑG57ÉòÃÕ£Ül∆äl
+auN5~3èIsëÂè-⁄≤Wdhè[4W•4≤yKª—”–˙Dvˇf=~ª'≤QÀ”ÒÏ\Ωm>Koá„{◊=K˙p¥e–π?À¯5á„/0ëËÎC~zÉÏ»ä÷£èG˚ïßI1Êœµ(ﬂ1íbàüfÆª≤≥ƒ˜'öµ=ÏUfÂ]9qÔ,¬r(XEü±ØhπYüÌ≥VüıŸ˚Ãµ‚GÈB¯VUø´†*åõD´T—@3ñò;n™:ΩlN¶FOc2—·≥lN<Òóè`ÑJΩ#c5‰c—[H¯Ùı	¡,\à"ÿÿ´é}ïFa%ÕwH|`ˇ]i™#^å’YSöêµ©°•©ŒöçŒÍ¨)M»Z,∫†RSö9XìIv∆ò¬ÿ¬]1«ﬁ|h¶òÕîß	5Vˇ∆±˙ı‡„`¯iÄ◊Èxµy¸πìépoÖ∞q€MíÊ∞[Á›]ûf4M<Kn≥˜êºÿû
+ò≠@	†y%¥;Ì/êDêkˆ¶(‰ßïÙ3Ω∞Àà<Ú©·hê˛ÁE£ÄA¸GÉ—<‘?}Ä_Is|ó:î∞z3hﬂ¬è“ëI¯”ÎÜwh‘ÛÖæŒZîQ«UÛ‚≠+0IﬁADÏ£eÀìS¿LXíePã¥Z¨ÅÀ# ó–$ëÙnıIéÕL¨è?Ë	4NiãôÌà-~YÓÅY>ñ›d≤ê»#ÏhL√€ã`Zò˘‘ˇèïßŸÀß„ï‰i≤˙1Ω_O˛l˜Ôt-◊$,U◊%Z≠nØ˚ÿ60|ˇøÕV◊˛AcRÍáBWüfkTjhe˛Wnù›cÏ\œÜ∏Ê˘v<Ãápﬁ·∞”I˚ÈÇt]∫.øóıpÚc–IWyˆê˘ßŸÑU F√qæqt	|ÒénMZ#R“oÅ‘—Æ‚˜÷cªiy=6‡¶ûÎŸ0Ìﬂ¯˜›Ã©mlÍIπe5√”ø/ø ∞Hıd®∞µûQ≠›îç{˘hEHSúC?ëÍ÷Ù»¢—`ò≥À†E ∏†≠,‡ûù«È1ü’P«∞ûÎY±ˆùã˛öCèÏco¥Jæ±ÀeÓuqáéﬁU√~7{À`ﬂ¡,˜bFÒ¿?ÊIIù|∫∂ËmQspm£æ·€1ÿ#œäq”TOèıÙÿjy>∆ùaD››ﬁıáıÃH˛·,ÉS˚ãﬁ¨£ß∞w≥û«˜õ®∞w“Ú"ˆ<D`Ë ?†W≤Jı§XOä_RºJ;wCÜçe=±vk∑±vù!Ø›∆Ï1Ç©nr,Yßzí¨'…Ø7I6qMÏ|òøﬁ∫ıYªè€£Cø>íÁ©¢ﬁ|Ü…]ƒPVø¯Ò„∏i™ß«zz¸ ”„Òg∏Ç0´'«zr¨'«“zbÌ>>ä˚Hìc¡0’Sc=5~Ö©Òˇ@T"±xú-è¡nÉ0ÜÔ<Ö’Ó∏Äˆ =tk'!±1ïÓ\Ö‚A‘‡Dé°ÂÌg¥Iñ|¯Ìœü∑∞Ô:»„‡«yL–#![¡⁄ﬁê§nÚlÁ¡%–≤p|≥&Í`"qR1¬U{ÇªìAßZAVÊ„ºª!ÿ9∏ŒQØ¨bJ\x◊«¢Âh‚"C ”.Ç
+âÍÄ'Ç¿ä•Ÿ—UW!bàk6X˘W[ï‚ƒ8;ügŸ	 ı)pîƒz¶~cíB<ö99ΩáU$ç3Z≤Ω˛lá ªÕ”ÈÎ„Ú˙]VáÀ©Æœõ5P7ÓvÂgsﬁW’Òpy/´cì˝Â¯oXÎÇ∂vxú˚+¸úmÉ
+≥3óápàÇ≠ÇRN~rbNF~qâWÄH»‘¿¿“å+4ÿ5»Q/ œ/QÁ
+p˜râß&•≈ KkjkQxú{ŒˆåmÉ
+ÛdUf' 4ÆπÈx›Y€n„F}◊WtzBÌ*Ù8YÏÉzP<V¢$#ñ≤A‡1àŸí{á77©ëî ˇæß∫Iäî(⁄;÷A¸b±Y]uÍ‘•/|Û≈≈:”_»¯Kw˘c˜ﬁ∞üî/„L,OX˛(Ÿ(>˛ÕíeæZ≤q≤éë´$fŒh6Ó3<JÕíX≤D≥(—J¸$ŒµZ¨sÖV!+-e$„<sõIi¥OoÁìÎ∂T°dÅ Ï$ﬂ®¸zÚGï±M¢?≤%4â PdXÑL≈à,-WB*^¡l∫”jıò≥dKù=™‘Öñ9π1óH2´÷ÿÑìø&Î¬áöªˆo®!_øvﬂBìC"ºx…˚ˇb;Léƒé≈IŒ÷˘¿F≥‹˙2Õ®¢4T"ˆÂﬁ-YÚ. ÈHπÄ∏0n∞di*l1ë˜ﬁ  ˝=Êyzuq±Ÿl\aÇ„&zuQ–ú]¸Bß≥õØbL˘9eñ1-ü÷JÉ⁄≈éâÄ|± È°ÿP‹LpLÃÅ`£Asº∞¨:¥‘Éc#NTîË‡t] |âòÒ—åMfú};öMfË¯e2ˇ˛ˆÁ9˚etw7öŒ'73v{«ÆoßÔ&Û…ÌOc6ö˛ ~úLﬂòD
+ ±‰6’Ñ Ò(
+iô?% Jî•“WKÂ√Øxµ+…V…'©c éTÍHeÕh	U§rìDY-
+ùnØÉâF`cïÁ2À{KùDHqˇ#A°7ÔÒ€é¶;·˚Îh&Æ •»¸¨î˙€ëH™ìÌŒÕÛ]*+©I1m&sÀ~5Ä¥ñΩû
+–≠»d˘bLN	Œ•ßkºÌ_ı(Kâ¬êW¬q2.ãó$†ÿ∞°ÕâE$áúÊ\~˝∞T´ô∞^^^ò1oEê–.âπ◊â˜ç=RI\Iùﬂ<≠Eò95u •Ÿ]¬∆érKª]¢¸ √Ä)∑BÿÔUàúTÓJÓi2ÀØ”©~œÇxlÒô∞Eï.ÜÃ.Pøˇ1`dŸ†s%≥¬Õ*–"œ—™ˇèaÆXUπóΩàX \íÁŒ}ô∂3ug◊£ÈÄ5«ﬁO¶◊Gc£Æj≈“C£)ΩZi†∞æ‡-’e˚K◊≤T⁄=!&+Ù¡!Z=˝‡˚|R≈|áÏèv9µQ[0ôqw¬¶≥EëxæCx¥⁄9Ö≠C•ƒ5:q°∫÷Æìã∑‘sT‚Îª@©Ì≥ª :DÆ£8ﬁﬂsÅˆ¡¸a¿Ó˘oÙ{« c?°Ö⁄£∆7‰≥˘›d˙›ü±P3£ø„Üv⁄94 K¿>éßè—•iV6z¿{¡ºí+ö⁄`±V•^Wµä¬Ôç'·î@¸™bÂX ºÚ+∆óƒ7ø/8'qµ¸vµ„!Ù⁄∆sK„% ËAP=!\πﬂô–'Úá
+≈75“íFêVk¶ûÜ<xÖ]kub∞≠ØZcLÓIr¯‘:ÛÍF“U>¶±(◊€√@«q¿ù‡¨œ∫ß^-–â⁄'€ne4î≠Ÿ:ä–™Jw^ﬂe÷ñß„6¡±£/7˜’æ“«Ÿ™⁄-d.é⁄=Pj¨ÔÉÃoVHç¥ª≥;‘–zVØöO∏ˆ^lœÁQMŸy©)<Ö_≈gƒøWv&¸{Ö'ßeZn¶^_#umŒC—ê„÷ ÌÏlVÇ*õ&tµÄjÒçqcêÀ˛æ√ø¢Îêè8¢%Ç˛>siÆ?Èh[·0VACQÀg›‹/Éuœ,p∂q‹…’Õv¨B0˚˙‡÷îù';k
+O2Oß‹öú£ìçßÂJná|ª£≠©ø,ü≈¬ßÁßÚãû?â∞¯œ«âˆñJÜA6úÎ5ˆr∏ÖÚΩlΩ†€´x54Y÷ïÜÖaÂVX:•-,l
+†ù¬3Ñ/:Ö≠? ≠\Ïí∂Œ*‹5Ów	Wïv@Nm∑z\rçÙl…v–ÖH -%¥â]cïn¬e%càkïy™d_«2`d-+!√”±P¢«&OéTh€fˇgenÏK±Y≠áµàMJ„ bÊw˙†–÷Ê$FUf“ßÀ¢Ûu‡6≠¶„\«qÉËD	b”èe≤•SÆ?Ωe(V*Bo”≈<‡ÙN¡°ø„†øxß”êÍt	ı‹’Rvªn‡6≈BlŸÊôÆ‹ÓÃk˛·Ì€K˚Ê∑ëñ+á(B8Oõ≈ƒñi∂ø<oÒ√[c◊•√∏¸Á?xøæÆpÓk0zxx©¬óhKå.Ôß¯§p+AÎ‡≠zE‘I{Ñí˝ΩL„£WxCy}4ÓjjÒ©√?ƒDc√Ã·π"sN¶\7¯¶⁄ñ6hOÆc)‹ve‘RlY¡=≥áÜL$ÃuNVm~µ%@Éò?ö≠Æ´µUÛj=.ê[ºK¸sv∏CùØÌo»R|€“©ÁÛu$~1Ç_œ‹íøÙ∏7!;>˛D-∞£ëïú(wœTWÌsCU…bg¡ˇj¶Y%¶÷U¶ŒwTo%áUïî|Y{1√\CÊ3+ÕWˇ”_ØGóDæ`:≈G¶ÍÀîƒÁ¥%Û<Z©=èáÏKœ£7û˜•˝bUà˝Œ.iRÊéxúõi˚—nÉöW~πKjNjIf^˙‰ıR^BAægIjQbI˛‰z^wn$·…˚•%&‡cﬂ¨*T¬ Ω›*æ´xúçV€n€F}◊WLhíäpÅ>N]‘p¿@Îv†HbI•≠Wªƒ^¨Ë-“˛\æ$3K“‘ÕFÙ Q‰\Œ93≥√òùÕ†4ï‘ãæûΩÂ;£∏
+~iÏ¸n¬B	◊≈-¸RïÌ’o˝E¶—ˇJñ“A-˝6JîXÅ‘ﬁÄ_"4°P≤Ñ ¨Ñ‘Ÿ»˛Z®2(·—Eã2Xã⁄√Z'çV∏©°1Œ…BaJñ\F
+aÇoÇS√∑Øˇ-§á
+]ieÅﬂæ˛ü¬äh’íPÜ“Ë⁄ÿtp∫$ƒö¢∏râ+§˚¬ÉCoår∫6˝ap∞dgµ°≠5ñ¬LV∆yPÚ’
+,Ä5é-	¢Ÿ0ËFîèÑß4ÕÜA
+£Pêô∂J•∆
+hçé~¿©◊∆>ÿË9ePSh®…
+
+
+$UÉÀÿICÑ=…È83æüˇ1øzòœ>ŒÔn˛∫çÖ F'\7√T[eô`„Spr’˙6÷ÿò`[q2¬ŒŒ)Q™:ONh—’Ê[†œ	uﬁ©<ô5På¿PœÙ˙_D µ5´Á≤w)œ‚ìòpB¸È,.¢ßùAv‰w⁄RdnkIbâ‡©Ω,IπÑ¶¢˛{QüdMﬁKtNÿu√≠Ò]ßº‰niÇ™‡LF}¿µXb¨{úÇ˛é∆#ñ]TãKw£:ﬁ43ÖO® #+π–Üzg(‘ﬂ&åâBcM!
+Bø:˙V“yÍÀ
+Ó$N¡ö≤yﬂpÓ]`bıS¯7–#k
+%‡œ´€õ˜Ûá9« Ãªk-ö‚vlk£îYsﬂ)©±-(P∫RÖÍ Õ}ûS⁄<áKò${ïL¶Ù<6É±d’˚~∏3ÍÓnÓÊd£
+k‡Fˇ~0'¢(,>]˛<Ωqxªi/¯”P eÚiLN„∆Ω_œfùÛi5ÜShˇ|Nü›áèÛù;ó%Â?4ˇÒœtHïµ∑≥Ráì·KD0‚säëÒ»Ú=7ô~:ˇ¸l÷.—:„“6">≈/%6˛bﬂÚ÷h|ñÖÉÊ›¡2…EjÇIˆ î§êÿ§œy‡∑5å°~â≈æŒzèLƒ 5O‚nzÓáYØ≠Ùx@ª˚ÌÿøJxù¥u™≥jíú∫tB≠–«@ãâ˜è£Ω<Å{íáÁokÔƒIª~ÁÒI´˜g%Î»ÔQ"
+«‹ôü¿{iy¿ÌÜGõ–›Æ¡Ò».∂>ÎêÌ•)ﬁ‘ÌâXtz‹.´tw7EÓBÏôK›´súµ¨áç‡b•áÚo+±#¬6"⁄éŒÛâ_∆¥Ot§Èùszëˆ(˙Ì˝#Yy3K:≥?2ç9{Mík°ÈîÁ&Æv €æªºI¶G0èœ≥ü≤ÛÒÆzá¢¸ÙˆRcº≈uØ\\∏G’Î∂÷÷ZkœmC{®œpÑÎõ%⁄Øœ’V”≈9N˚Ÿ<BihËÌ3!Œa…s-V»ã·í<Á◊ƒ<OZç•Õy¯V1˙Ü`â‰Váoxú≠îAã”@«⁄Ó6 Ç≤≤x∞œ.ŸIhvO≈"¢Tˆ^KI”∑m∞M¬Ã¥€Ó•‡≈´2∞WøÅœ‚—£w?Å_√ôŸù6MãzpHòyìˇ{Ô7y/˘∂wãÖC+•	Âê0≥b≥Âí” ƒnæØˆáQå–Ñ◊Iå»ëﬁ‚g·™‹C“®ãëû¯å”(u\Kç¯,I1vZ§q‚°8©ße®åßOüQ)ûÕY2¶!vHüTÜÍ%cÓSzäÄ9nÎ®ΩL`‚Ø{e¨V#Ëve™vÜ%†úI’íY≈ıY:å∏CÊu≤äù√P"köM8n,ü©1A ¢$VúJ"¡VYp»pCÌ≈°ó£’æF97“Œ‘””Ïz∫îB9L?C©∆¡Ù‡Ú ƒ8ÂpYè‚ê‚cY]
+’4‡·†™Úc¿0¶„G1wÓh√Ökç ˜Ê6Û’’Û{8±ú-Ñ˙pôöS‰cõó¥vj¥
+ß!¶Nı§5rgı“!z›÷û1’H©A#éQekÄMﬂƒäHYô~»´óΩÏü'téÃ‰»€uE•Ù`æ=5∂Í<«m⁄Ï:OnïÚ/á˘#’›∆JòﬂG^dë2{ˇ«–‘V8E…TX˝<ÒΩ∏∞L{zDåK/oy‚k©v{≠Ú‚WÈ§‚)ÚÍMm4á+j;Ô˜<”™ù¨˜óù8vé9œ⁄gµÕ˝«ÓÁ˚[≈DÃ ü’áí›¥= æErO¨gπùw÷„ﬂà±©©æxú«K
+Ä  –˝EPœ–¬EÌ˝L6†)¶Å∑/zª«DÓÑMÌŒ√	ÇjX’§ÜMÒ]≠€∏Ã‡ËÆL£‡‰üB¶U‰r◊÷∂ÿBË=ßÎH^≠_ÂÇÈxú˚ ÿÕ§ùôóúSöí™‰Í„ÍÏ™ÊÏÈÔ«/K-*ŒÃœ”+®‰ö 5Qˇ „li<xúÎf˙Œ8°i‚¥R Ô48xú+…( L+·‚ K¶∞›xµVYo€F~ÁØÿ20$’= @Fì¢.úÿàÙfÃää[/wŸ=+Eˇ{gñáHE™zêƒ·\˚Ì7«ã/ﬁö≈V®®GVÔ]©UÙÇÕøú≥LÁBÌñÃªb˛#I¢Q$™Z«¥ç"gˆÀà·ßïYø≠çŒ¿⁄ -πM"∂b„!Çßj◊ÿ}¢Ò3óé£+SŒ◊]o°8≠ej,öŒ⁄(Ï*$˚⁄möà5«‰âˇ¡y’Eíg}£\XÁùê6…¥Å±at¨QÂù¬O∫™∏ £(M¡X°Uö"2Ò◊…w…WÛı€À€ı/7õ8ä§Vª4õQ;T#•8Æ˜<À|Â•f¬2ﬁ^À§ Âò[√Õû⁄∞Àög%∞ÀN›ï‹1Ñ…27oJ#
+«nç~⁄£ˇ(ä2â1SW”6◊YÉ‹Q.[/dN)ºª}√0÷ﬂAÆÉòTá§-f}wqJ8¡•¯ù¬‘Ç,⁄ƒ§Ê~ËÈBù°mº:v'
+6ÊXsÚOÎ∏Ûî‰Å¶I∆•úﬁ!“TÒK2$ıû˛oÈ⁄SáÊs°–ÉîÛÊñHÜØé§â-„˚YÉAÎ•hCè”°◊ÜÏùWNTà;ç	‚Ä7+∏êê«GÓj#ˆÒˆ:ˇÙ€
+;[wxXc„¿ùÉ8zﬂùñûH¶¥Cxj*z»µ\â‚ñΩLÏ6@ïD—≠é…s˚Ä7xF\ _Ÿ`ZÇ¨ì(≠·YÆ≥œÛl
+w¿ê”¨ch·+d;ß™8Õ∏iLöt¯5•(F≤ê+R¥ò≠u¿s:L˚ﬁQ§Ÿ}¥≈û\u¸%Ç7—Œ¢9±>	«Y±∂ÁQjˇÁ{˜G◊Ã]I}œΩH°-rPïŒ°’@ˆû`Œß./lÃ.ÿ†øıÊCﬂ•´$∂uü~út˙’6©¯‰¬ÿiç¡f#ì·0Z⁄Iˇy∞u)‘”<`J~ãﬂr°√ È_ñ7::0‘lra']±#òÒåöıå√÷b˘Kf¿zâÃ/¡¿íÓãBå†m{¬wa§A'Ì5N0°mB√Ç'˚_{H∫’¥ÕJÒäh;9…IW˝]∑ZyŸΩ‰[Ω!À_π≈Iª1⁄∫ﬁ¥yõBÖ≠ót~#ùƒëª‹∞…q®z`wÿ∂ûsy–8√Ìx˛Nö¶˚7&ü◊âç‚X‘!‚M8jÈ\móã≈N∏“oÈêãn˝Xú ˘ˆ¥¡• QÍÙ∫Û-£—iƒ÷”qaÌËSk˜á∞.ú∫æaiﬁ'¬—l–∆ˆûû”ƒΩÙi?ÈÈ{PªÔŒ‹ŒÚ‘¿Ô^`y‡)Ó&mûΩRΩO±Pºª∫õt{È§ùUyk´?BwX“iñÇxIıœ.X–Ö¿pu7»jÚ
+AÍö[7€…r…æesv)ÎíèŒ9πRTép^˙¿Í∂–ÛX˘Zd†p:£ Õ˙
+˜CÑ‰mÒπ›◊∫p8.≥≠Íÿ˛-ÆJÜKvÕ’Œ„≤GÜØ’N
+[éo∞Õ‡p∆∫ﬁc3´öàÏ
+3≠)]u®-∫Ü	Óû;√´ä,ÜŒÜè}^ó"}s∂AÚ˝˘&?úmPPr?6‹ËZdÙ™«~H î_áï^ Ò°≠˘7álnv∆f—_ ÷t‰QàmxúïTœk‘@¶Ehõû=)8–√da/û*{-‘ãW)%ÃNﬁnáf~83Y7 Ï…ª≤‡ˇ‡≈À^ˇˇ	Òèƒ7I6Ÿ•ã‚Bﬁ7ﬂ{ﬂõ7_Ú˝Œè£œÖ4⁄z‚J5Øc%ôÁW´–#c5Á¢hlµ$ôpæ"w	◊HC{¨•d*ã>˛æ{ØO∆Be©a¸öM ÛŒ¨Z-?Ì–ΩåÁÃ9r^æÁ„&ªw\îR[(b ƒ„&FQg‡∏∆c	2 Å‚V‚5Å¬ayNÊh¥¯vÎˆb¥˚nŒeÜ)‘C˚Ñ
+Â<“ËeU7,1&Úqg≈®"ICK-º)Ñw““√¬ö	Ã<®,˛WÍ\ÔÔRU√+°ˇ–Ÿ»Î4¿Z•ÒƒÕÂ°>ﬁˆc±çN*‚¶ûe¬ñŒÉ<ù	Wú^‘íéàÖ\≥,ò&1Ã_ë±∂Ñ©í(xKr1≤Ã
+p§ôd—ºUl<%<¥ÂBêH&T‹uf¨Pæ≠ø¶\`k¶\]ypI5Å.±ﬁê4≠µ“4¶f^°tm>x.Æ3@bùQ7pAèèπûãòíq^»"◊!™‡c°bà=XY·”©´„‡∑ÀN ¥’Ç“}î¬æ:}1|˙¸Yüú=û°tÛ=$ÈD¯¥â„ﬁ‚Î˛ÉΩÜΩ¯µˇÂ }∞¯y8X~>xø3ﬂ∏˘`ÓVõJÕØiøã±w∞¯%Æc¬d£ı∏√M§û«t66‹≤·Ö]l-ƒå/Çs&[6Ö‚$(4Ã⁄ÓÂÍm[˝/ô‡>‡ì
+œ4«£„≥O⁄$k$b¯ÏÍ4û®6‹[™√◊ª—
+ËE å–´xú340031QàèœÃÀ,âè◊+®dx6˜—ÏMØ9{wkÆ+è∫qËIODCà≤í‘‚í¯‰¸¢Tê∫àv≈)a€Æh©
+ûÌ_Ω⁄·v˜∫2»Í2KRãKÚã@jèÒ_0ÒYSw¯rt˘ˆ⁄I;ÏíX~:  )â3ÑÂ_ù_xú≠TœkA¶±I€,ï"b'ÈÏíÌ“z)Éà<TÈΩñe≤˚⁄&ªÀÃ§Mz	xÒ,s≤Øã^≈õ^Ô˛˛Œl3…Ó¶≠á]ﬁŒ€˜ﬁ˜Õ˚1ﬂVŒ´JwéA¯«T¯'¿8ç#y^j‹:ÿ:¸ÚΩÙsn√¢Ω$f≈‹|Ò·‰S0@õo‰˚˘ó’x¿h¸.ç µ–´8©ïå7Ú˜</πHVÀÀ^p∂bÓ%Dtºê≤àÙ¿6{“ÊZ⁄æDª‡˚é#˜ µ•I|óÓx\0öÿéïBò˝8Å»>¿Í<ÿEò¡…fBΩy±˚Ù9ñkÂ˝è˚, øCxG˘$*T˜Ö«ÄÑö;∑u˛	Äâü˜ Ïö§›VPá.Ñ	Æ¨r9Òx“•¬∆£M<çJèPWQN‘j°ÌÊ‰ü^„™hû⁄Dõ¢@ó√åµãt›€‘◊Xéå©?pS1‹ÀGóÚLy(i¯z∫z’jË8FB=@:€§Q¿†ëÍÜ÷U˘ÇŒ∫&ÑCë·j
+@#aß`j†Ì‘Fí•ÂQù{„'ÙB8©såÍ»æâmz‚L#0}ôÃÂRa°‘
+$Ì¶"µQöÀL¶…¡OÀ>‰∫AÄ1ÔîQ6ŒµâÍÏu§9Ê‘Œı˛ì©Òéb÷#¬Wÿ∂zù‘G÷*˜F≥òâŸÎ&µùVù_ÇÙSÿé¯Ofwg©…µ ˝+h©ëU◊áÊ•åÓˇ–1l˘L°b•∆u◊Wç+î/,”¿.ñ˝ ﬁú+øV∑s˝ ˇTv÷\Õ|}‹e3-„»∆¬ª◊4≥üı˛º‚°≈€ú'7ÅWπˇZ¸Ù`À€¬◊\1Xó>nËÅ Í´W«ZµpÅ ÎYAÛ÷z¸›@⁄`ÂÑxú]êÕJ√@ÖQ6…NTT¸π*%ô∂]	n]˘*al&v$ù	3ó∂Rä{∑≥sÔ^àkE‹¯}_¡$ïJΩª3Á‹Û]ÊiÔsˇe’ŸU›
+Ñ3PÜfªÙN	z;ˆ√iú¥f2†E8 ï	HÖ≥=>MOâ}Û∑ú*óo;œãûJF”hÏdiÁ!eEAMπ˚\ˇπ°=„ïs Bv4Ôqâ0Ë2‰E∞À°ÏÄr	TR<åﬁ–çÈ=ãc6W2«∏L%˛∫‡‘°ê˛Û+õ@⁄ƒ^‘÷èFcÛ˛h–DÈ√0†¡ÙßÊèoÅÊ)Ò<˘kˆµvláÓÚJ*$?Ö∫æí‘°Tƒ≥ôªaø›Û¸—m.ÿ/3üxÔŒz°æ´xú340031QàèœÃÀ,âè◊+®dx6˜—ÏMØ9{wkÆ+è∫qËIODCà≤í‘‚í¯‰¸¢Tê:›T'máÎØ”ØÚ∂Où5õ	Y]fIjQbI~HÌ1˛&>kÍ_é.ﬂ^;iá]ÀO ≥1YØx340031Q–Kœ,…LœÀ/JeH9eÛd“ı∫NsY{Ó°¨∏ñ!Dïèß≥´_∞+√›π9\ñqG˜Æ|xÕŸw˛öøœéLÉ*ÒuÙÛts—ÀÃcàùÒÈ©ÔÍÜÕ˜Ù.À<ò'ˇ±B©«¶,1;5-3'ï·ÛãéIyt ≤#¯N´Ãq9Y…t™&»’—≈◊U/7Ö°¬y—üÁâ—/tñ	ù…˚Í_uÅâ(§V$Ê‰§3®∆Ó0\ˇ°*qÚyüæIÊÁø2Ü()®LLN.Õ-Õ…gê\*≥¸Õ•MBÎÌdßÕ…∑Xh.ü=jYQjaifQjnj^I±^IE	√ŒÙxqU√òbãŒΩ„ó˛Íù±w:'LmAÆnf^qIbNénqrQfAâ^qÉÛ…/Ôéúwˇ/õxœÆPHÜ%àıO®Ü‚‘ííÃºÙbΩÇJ}Ô¯®Î‰ç7˜VM}ˇÙ∫·“«€ J@j∫uæàxs™Tª:˜º®·Î¬Çœ û)I-.)fx™¿∞!é±Sv⁄›˛∑LåÇ+ìóBÕ(K-*ŒÃœô‚S8IÔl§Ö∑∞G∆ÊÛW^~’Îpˇ QH« ËÇJxú8 «ˇÔÔêÌ{cvÍ≠Æ∞ñ®©›
+œ—í◊∂l& ì¥6eÏ !d∞¨Ü´â√i*€3ìì…&"ô1´xú340031QàèœÃÀ,âè◊+®d(ÚÙ;2ìc∫«œÆ}πb‘µƒ-vö ÅBfIjQbI~Q1√ﬂˆ9s.æïÈ®Ω§ºΩZ„Bˆ≥ï˜!j
+äÚ+*.ü:∆y'ëÈÛm√=ró]?IäÀ  å6*ÛπˆxúµYÎo€FˇÆøbOAaÚN•ù^{¿˘†◊FÖ$v/Rπ@XS#âäKsóñuE˛˜ŒÏãÀáÚ(Z0…ŸŸôﬂ<vvgı‰/ßµ¨NÔ≤‚äV‘V£'ÏEñB!a≈î`jÏ¢‰)>Êb≠ˆºv-Íb≈U&
+]ÃØcÜüP1Q €â
+PH*
+UewµBRn2æ© vP(ô06–“on≥À+∂Œr`´LöI®|ü©- Q€L≤Ω®>∞5J‚´UFäyŒ≤	;£ÇØVY±AµÂ° 6[≈ƒæÄJn≥2A)2c~ÌêH#VÎD#ﬂä⁄⁄òkΩ0aø†RÚ]rÜí"b€¡q¸/v¿…;~`ÖP¨ñHÜ«JÖ@’ÆÃ3^§–òÂ5†/ﬁZ‚NqdÁ⁄&÷!„jÙg“ﬂV©Ú¸Ùtøﬂ'\£MDµ9u∆ùæ@áﬁÃØæ’àq Î")—K˜uV°kÔåó(Âw3Á{äõéé9"ÿWËÊb3a“•Ñ¡iºÂ–°—!˙ãl|1g≥˘ò=ªòœÊîÒf∂¯ÈˆıÇΩπxıÍ‚f1ªö≥€WÏÚˆÊ«Ÿbv{É_◊Ï‚Ê-{>ª˘q¬ }Öj‡±¨?ÇÃ»è∞¢ê∫¸q (=Ë[ñêfÎ,EªäMÕ7¿6‚™Ç≤£ÑjóIä¶Dx+îígªLÈ$í}£í—h]âí™l≠Hπ®Ê}Ö#â™x!ı†„ôãÙ|éi·(-æ≤J§"˜lóò=<U?[∫Uxö÷ª:4„Ò‡ÿ/,ıg"≥&JJ\v∆<Â≈•»Î]1aÊ˘∫ƒıç©O#∑•ˆŒÑ=á√Ñ=„*›∂»ãl7ao0i†Ú3¸‡∏¸Á†(óFV€0÷*¥/á‘ƒ√N(¯V™.sËYìYû˜ó‡ÙéFóêÁlà∆DOÿ∏{ñÆYzœ“¶${‡˘8çV∞fÀ®•Dó©vÜå)„Û≠<KB©7XÔ4)[UöÒ6œª˜ûHÈ©ÉZt∏ÈO¶»‹Ñ!ä;£	NπÊª,? æø;{?¿ÒüöÁò˘ò√ÜÈÈ{¬ñCAƒÏﬂÏ)ÉWäGﬁåµ§Ñb…‘ËØ@’U·Fçs÷±«p.yUÒCÑ~≥ûAU¯—ÿeg#Ìo„ˇûç5ù‘˜84úQös\‚/k≥#q˜?L+ZGeôôZ.#	˘z¬0~q#I÷∏≤#7´Úƒâü“∏ìä˝î$¥…µNz6Ø∑¨ïUôÆß''¯∏7èá)ü`Úÿ¥TèdrπÇhzà2–‚|Æ∑»Gyöíæ ¢”Ù^~…dvóÂôBñ‘çkO*æ+ßJj 5LÒˇÑ îÏS'éùó_aeÑœ∫∏ï"∆ Ùô5V¢7‹€Ωs>ëﬁ)2+“º^¡tQ’0ÈãÑF$xë‡EÇ	^$Ñ"~'¥q)–É4I {YÄÜ=]w…˜ö|ﬂ%?hÚCá¨(çálë”ò}Ì¿z∞@√Ç.,–∞†4,Ë¬∫∞†Å-XîJ,+ù.⁄°¡‚EÓ∞~'&©?cAÆnóª
+ƒ±ZOiOÈ;;fi+/ÕÅ’•¨[é<ˇ∞–∞å∫hc´©KÅcºÕ≤lòô˝äıåA4,”å,îŸxû^≤8o¿†oEy‘µ¢¥ûÙâã·-W{Ü!ô=«¬Äc_œØ0‡W√⁄w+∏y{^ÖéWEŸs*Ùúj˜#<8ÿ:©;ÊT”Æñ„Òx%R:Ì‚°ívˆÄ«éUTÏâpsRtÍû‡yˇqπÏñ”ßg}zˆ›˜<≤*(“√r'ß'⁄Ÿô©Ò¢VD˚¡ë∂ïƒyΩ=0 ÚπmpIpÙQ°(:#{-¿é%)πÃsT™¿∫£ëê‰bì5fµÅ˘“ÿÿòÎÕ|)ßç¡ﬁP§6&7∂⁄g‹5∑∑4‘≠NŸ5«D5Ò<99aªÎ›∑ÿMÂÿòP7ÂÃSóè∂ñÀùeê6`$!p±[ç“Œ⁄„.î+›ˆ—!f|…jµ;©≥¬∆Œ`5’2≈Ωö™ÛØ[GFD@GF“÷•˘	
+±Û:W≤–“û‡È%N‡Q—ÈÇhˆ¿1|Y√Ö±üqÀõ⁄ô/Î–áG]ÿxœu‡WZı´u”9|Û1nˆª5Vâmw≥˚Ω∏µ∞Ø›®wòlZL[_Üfk≠S'È¯“°≥î+{ÆÉÏ’<¶{J?Œ>QÍ∂B™È8)œÈ[.Íœ¶?úù˝Û∫'©¶'ï
+œÀ%Í‹ãj5=ëÄ5FùÙäöS¯πä÷tÿ”†πN◊uÄûŸÓ<±œàÄ›Ú‚{ÒiØO∫Ñ®ç°#…ƒÂ¥˙Û‰Rì£ñ≤cV%[ÜÆÕ∫˙∫=Õ&Ä¶E‰dL¯Áﬂìs˜ˆÒãr™—kxÇITPó∫‡Àﬁπ–l¢Ôîπê°‚’ÇÜ3ÕD5˙--u	è»Á™∞&ıUÑb5ÀU3©µ)Ö÷Í=Ã@?"=kÿûª≥◊Èû∆_Ä$/g/^ÃÊÅ6”w}±6√~D[ ∂∫—hâ˘ b*`ˇ)fn_«ÄÄF°.°C;#’;<Øx+R†≠wo
+wLWm√√˙R&n◊RΩkcNœ˜Õ˛Ëè$∆«;:ÌÿÍY‘Ì	I{[◊∞ª,ΩÙ÷7@M◊Cù-/ÙwgOp‰Œn`Û”ç&æájT∑oBÇYÊ6§èDv°t&û>(ˆ›ΩD˝Ä^™^ ˚ﬂ’]»-•πÙs®˝E›@Œ∏°Ûñ‹.~ªgaçLAJØ( å°oÆÉÇ“ü“@j£	“”:7òÒ†à5’êúVÚ∏êd»ÅüNô#«k±˜«9˚FéøÈ&(‘Ì5ÌÉo/ZËû“æÚZm›ª˜≤˝æ´◊2˚øõ§ó§˛nu'¬4ˆö”µZÏƒÜ6Xt~πMé›∆Üì˙I◊§õálõ(¨JIXÍÁfl®ÿ[‚nfö≠*˙5jiújÑæ‹nJ÷'ú/øŒ˚EΩs-“†{Ö$
+2
+JÕáËóÖ¬√¸s„—ÊÙ%∂√ﬂ¯qø•üˆhÁÔ.dâ]òÏòR`#ˆ|@8ó
+ò.øVHbümÙw» _1∫◊ç ˘ ”ÒôW¸eK@knU—_üAﬂ"7¯Zl…v0Èßﬁ>∆V(ikıA4œ∏7√‘±9›“ËÑ¡∏éºÓ‡ÿ÷⁄Ó€«ë?¯2≈ÊRxtD_®'îÔcÆ˝≠·”ÁéíxúùWQo‹DV°-Ë
+™Dì¶AW}†wÍıîH<†¥WµE
+PíÇ®Je6ˆ8∑‘ﬁ5ﬁu.«ãüx‡≠ï_Ò(˘+®‚ë$~≥ª∂oÌ‹Ö¥'E±gæôofgfw˝˜ıüËØ_
+Sö¶tBXúàTŸó˝'«9ñíPDë3æ„=ÄIˇz´Çøã/öˇõ†≤îK¢F@Pã^bUM¶∂FÀxí)ÉπB∂©ÑÄnÔ—]™Ÿ#àÅ+™ CëÒ<@C"“ùM®?Çı˝,Œ"1E
+ÉÄ*:x&}f‹/-KRw7h™çë$¯ÿ3ﬁVÒë∆:í’:l%»6î∂XXûö‹V	µêU3“ìÕ‰ã√B-(ÉT4NìÑE>Ï2Í_reHVå
+Ú®¥˜EÙ	ìlõELMÊ˚h¬ÜNÈLMª0v9¿°˘(£¯∆ ’,˘\ö)l.K9H≤FcûáÅ‰á$a}¥|ßb<ﬂ´VŒváÎ»÷€T±„Gtˇ·…GœÁ7§nI?5∂1c±ëB»ˆ∫â˘◊õRbT£A…ñJÌ`I2Iæ»$éZ®p	iï â=∏√8◊ÿ1S#¥Lr„∏j(˝≥T∑&
+$&d”∏tÎRøTÙ:5“QæÎ<Ä=DF¿ªém«p•ÜéG,“u-Æ…2«óÒûÉ∏OÜŸC‚‰}ê◊}C ´5îÖækdπX>∂∏qÓDÒ√πs„πIﬁ[^uM/ìï˚Ω⁄oeÿäué¸≤≥
+e`é»Å“T¶[ÆÍÏf∞1u±è6mÉMMkª¿ªêJS˚TÔ!G)|ò`∆«†›~SÍv.ﬂï÷†>ëå˚Q¿NöAüÄVá	>TÚ5z"í–ÎØuÆﬂúÍO^Z)ºN7◊H	Q8–.˚§≈RËáFVO%˛“àß[O%ﬂÌìzÎ+eJˆ›Ñ√≠'⁄*◊  õgÚEK‹‚3Æè¨RﬁÙY¸vjyö
+ÃJfßsRÅ©¿åT¨Bgqmn"ôôÖH¶ﬁˆ_x˘—â”}‚˘Çsï)‰˛∑Ø<wÏUgæjµÂ)æ;ÛÊ˛güZ÷ou˚ÅO˜aWááy–Ì€¬ñXØNÒÁ‚RÒpÒ‰›Õ
+4àvÏh9)⁄1U
+œlè·.GïH[ŒA)Ã|ëÄ‘Ã¨ª¯6O” !K!∆ôöCVI∂Ûüj¸a\m#á¨YKı@_CÙ-£¯y·ç|‘ZÍ÷*«ºòÓÈeo∆J35íC}ÄŸe≠´—¥Ø0’Ä´)˜û‚˜Ö• )n”ΩÕí†ïù°©
+W9∑~ß.›bÅgˆz&= /å29*g_œ›]ÍfêßÔU‘2öçM‡%I_ó8‡ıu~
+xó"ËçƒîS‹)ﬁï?"„T/ˇ¿›H›∆÷;N «i„~qÔÏzÒıÈqÒœ‚õYÇóB∏…É5ﬁ¨Ã}à"∑ò6/ìPuç~‘ìr,“@∑Ê∫} |}\+øM∏„9HE“ˆ´ΩΩ≠Û}9"&ïÒ`ßN∑÷m-´ç›itÏpNåôßÀ,Rˆï≠G#?”:ú˚ˆ@‘ÓnÑ7≥4F≠6>úH«|aGpÔ˙M)WûúH±ó@3)—¶Y Î¯?7‡-É›hB[%BecÀÿ‡h$Á?”ÿßÁQy\#,Ç|zˇvùLgœ#(€æZ≠‹ò‹—¬Câ≥ÉkvTBÁ*d¸àˇ.ûi'œÇ^“#'¨õûïKÔz2¡cæ}4ô^Œ-ÑlMÌÛ hZÒP∆k%e\5ù‚7áîßqÒx·¬ªà|ß	lÔc⁄FMP¸∏–?≠ESO≤¯~ÒBnŒ πq‘ÚÊM∂~.ø†|µ‹ﬁum¿‘ë˝“ÆﬂﬂRÑgÒ∂˛˙ëÂMÑÌI+|%]˙‚…‚“@˛?À2çæÛ»œ≥ÑÔ¢Fxú{œ¸ûy¬[ëà_m≥54∫'/*Mæøae®å≠√dF∆w Ôﬂ+´xú340031QàèœÃÀ,âè◊+®d∏¸'†‡fˆ·kJiÀz}Z∂º‡»ÏG&@†êYíZîXí_TÃ∑}Œúãoezj/)oØ÷∏ê˝lÂ}àöÇ¢¸
+†¬ßéqﬁId˙|€pè‹%E◊Oí‚2 —f/'Ïèû`xúùWœo5V°§R
+äDìÜÇ†VtW›ÆâJª-(RÄ¢êDU™≈ôyì5ù±á±'õÂ2'‹ZÕ¡Å?ÄÇ·»øÇ*éê¯x∂Áágv7§]) Ã{ﬂ˚>?˚=€Û˜çüËØù^ö$tBXãDŸó£'ß9ï˘ê@Ñ°3æ?| ì˛u7	˛.]∫d˛ÔÄJ.âA/≤D‡3™ ú‘±∆Àxú*ÉπJˆ®ünÔ”™’CàÄ+™⁄ëÚÃ«#"í˝>ç©7Ç>ıº4JC—˜D}ü*⁄ˇ &=§‹+"Q4w∂i¢Òëƒ¯ÿ5l¯H#=íçjÿJê=(b¡∑∞,1πmj!#™f§'õ…5&á⁄‘W,©h&	ä|$8ÿi‘ø&‰ÍÄ¨daÔâS&ŸôöÃÁh¬Œ“ô5ÌLaÏtÄ#ÛqJÒçA¢U≤π25lÆJôŸ§èœ√@≤cí∞-ÓDåÁ≥jÁl:ÙX"ªﬁfΩê=\xÙ|ˆé‘%ÈE†F¬F£-∂ÿa'6ˇ∫µ$ñ@ŸîÏ™ƒvVêƒ&ì‰ÀTb´
+ßêÜaêXÉ˚åsç35¬»83ƒeAÈüï∫5Q 1!õ∆Â[ó{Ö£ªX!ΩÂ˚∞≈}8Ddº„ƒv±◊+ËxƒB 7‚∆Ä¨öqﬂUºÁ ÓìBÉÄ8yOÎ∫o(y≠Ç≤†°wù¨5yÃr‰7^Y»Í„πôﬂ[€p˘Æêı˚›©¿VsÏWú©I 3eQ"˚JH≥\ùb™gWàSãk˚ÿ⁄ÿ—≤∂4<q â4ëËç•¨Ü¨.á©jbL¬pÙ€5YK;πòTæ#0®@="˜¬‘á¡ù$ÖÌb|X*õ4î–]Ã_[ºñ{∂õ?yq=.v2çî}MŸ#UF/0∂jK(Õ_sΩïˆÉ©ˆ√¬¶d∑QbÿÒ∫Õ≠s≥_≥
+Mæâ˚~£Òı9Vÿõú˘og◊ÍT`V*0;òì
+ÃHf§b:ãÎs”ÒÃ,D\≥ùyÈ—K=2ÙÁ‡)≥êGﬂΩ¸‹©Wù¶´‹V'ˇ˛‹õGú{|vMøUÂÎC
+Ü∫;zxò›±,ÏÎŸ…ˇ\YÕÆ,‹›)A˝P`≈ŒÄù¢â©Rxên}Tâ§EJav¯‡â§V`6`À≈∑uöQéXˆ‘±“Í®]¯L„è”j9bÕ≈±RÙ›D_=Úüóﬂ»ˆAmñ†NÂr(0åË°ûˆÊXi™Fr†O5;≠ÂcŸôˆj∏ûbÔ…_^ıQ‚6=‹)ZŸôr·JrÀ[S∫ãÈ˚√(µw69§‹a*Gyˇ¸ÎôªK›Ù}R·ÙeãZE≥Ø	º9È;º¢œK /XŸHD9≈›ë‚ÖQy#2NÙÙ˜›ç‘-lΩ#`rÏ6ÓÂ˜ŒoÂﬂ,çÛVŒÏ§1ﬁ·&˜7ıfeÓA∫ãi1L%îU£ıÇI9âØKsÀÇ>?)Å%oÓ0˚âà€ºöÌmÌòœÂ0ÑL*√`ªNó÷mm´Ç›nt‚∞OLÿP/≥Hÿ◊v=˘ô
+–√πoDMwsﬁÃ“µ ¯x!=Êª;ΩÀõPÆÜr"D√íàIâ1ÕB≥ˇºk∞€Mhkâ–Ÿÿ2ƒ8ô»Öœ5ˆÈ5FTûD ÁA>=øù'SŸÛä≤/g+3!w¥ÒX!'lzŒN*Ë\ÖåÇ≤¸ﬂïÖë&y÷!Ë)=q¬∫¯0‡YµÙÆ'c<Ê€G£±ÈÈ‹E»nçhüW∆”"ƒCØïîq’$≈)áúF˘„ÂãÔ!Ú›&∞Ωèïphoï@˛„roIõj&ôˇ∞r13gÂ‹qTˆÊM∂z.>´|£ÿﬁı8⁄Äö»~~WÔo)¬”hO…‚¶ä¬ﬁ§5|%]˘¸… j_¸¶•˝‚§∂¢§xú340031Q–Kœ,…LœÀ/JeËZP£[‚&ñ–c≈ÛÏÕ∑X˛4≠D%Cà*OgWø`WÜªss∏,„éÓ]˘ö≥Ô¸5ü·ôU‚ÎËÁÈÊ¢óô«‡)k’&4Mç#{⁄‚∆X±Ï‹˙˚3† Ç\]|]ırS*ú˝yû˝¬@'`ô–ôºØˇUò ÅBjEbnANj1ÉjÏ√ı™'ë˜Èõd~ﬁÒ€!c®9©UÒ≈©%•zïvãû•|ªÏ|à[◊ôÛ˜ø∂/cKÜòTPôòú\ö[öìœ¯Í˛U©is‰J◊k-T∂º5´(µ∞4≥(575Ø§XØ§¢Ñagzº∏™aÃ?±EÁﬁÒKıŒÿ;ù¶∂ W73Ø∏$1'G∑8π(≥†DØ8É¡˘‰ówGŒªˇóMºgW($√xƒ˙'PÉπ©©BQi^|Ij1–d†∫ŸOΩT˝ÎÂÌúñàN·
+éV85ËõíÃºÙbêáÙΩ„£n¨ì7ﬁ‹[5ı˝”ÎÜK√oC(Éx⁄Éœ≠iªõ&€≈ÊC
+aEŸUÛŸı!û€∆p‰“Â*öﬁøsa∑g2.>ZV? aÅ¡á·ÇKxú˚¬<çEÕ–¿¿ÃƒDA/=≥$3=/ø(ï¡uä¯∂Øz1{öˇùN÷òb–È6QÕÃ¬V†(èKˇmgJêÀZ—S?õÑ€æBu˚&fß¶eÊ§2|~—1È èNYvﬂiïπ!.'+ôNN,h˛–6;QC£{Ú¢“‰˚VÜ ÿ:LfaLò‹√hµ(yÍ#3ˆƒnû∑!%Kwä*Î}fb 
+%©≈%≈O56ƒ1v Nª€ˇñÈÇQpeÚR®Ωe©E≈ô˘yzïñ|Ÿ?ïÃ˘ÛP¡éÒ¸ ⁄?kΩ ∆[≥ΩÿxúÌks€6Úª~N©Ñ¢Ì4˜œ©3i„Ù<Õ%ôÿi?$"!â5_Â√≤˙Îowê 	…Œµw37s∫´#ã≈bﬂª è˛TÏÍMûM¶”Èwy^Wu…≈oºlj¡‚¨™yí:†…ÂäÌÚÜmyV≥:gM%X%Í¶®Û<© GKVéØÖS…AøÿyÏó¶™ LöH∞zWìUú z¯Hx*`’RÑu^Óÿ6Æ7,Æ=∆≥àÒ(¢	∏ ¬÷y¡Úï\I„??üL|Veû‘4Œ‚¥»À©:j	æˇ»ùçvXä_ ãqV"åWq»ÓEY3êÜn™áﬂ* ∑YíÛhí∆eôóÀK‚œOjQfx™Å∫{¥hPQŒ™ú-w¨jä"Ÿ≈ŸzÇõÊEQÊE„Ùº@a?noá;∏Ωı'ìkdÒ7§Ö£`eﬂ+‹JX∆mOIó®,÷%èLy˙®≈ºº“ﬂ™]˚µéS°øØ≤î◊·¶iÅ¥øyI?[	5uå*#Gì|=ô‘ÂÓºìb£ˆ…·OWÉ´ÀÎãâxê~Iœ/ê≈rJ¡Ï]û	õ&ªYCQURU"±bÅT˛ L#˜/◊’LN¡˛d.l◊"ljæLÑ7cœi®Ö+Å_ef†˜C‡®Kÿÿb¡N'{â>EÊÉh@ä[Å$AÏÖˇÕJ‰˚µ…kP&|‹§"´Åı+X>]Ï¿‡b*¿‹Åò…w ÊõN∑§&
+‹Ê¨?¶8?0nls¶«’‘a«8ÇS0√!µÈœƒ:¯¢V¨nÜ“…+ø*8Xùﬂ>?ø∫ºˆÿÄiÏô)≥◊o^}z{¸tÒÒÍÚ˝;XozÍˇ≈?{9má>}|ãè7u]úüúª"ˆ•®¸º\ü('XùT‡®Bqùt~Èd:π∫∏˛Ù·˙˝˚∑W¡õW?^º,ûùM'&–á.ﬂΩyè„”Èó…?EÕ#^Û˘O“ù≥3ˇtÚ¸Ëπa¬ìvÙ∏ö\5i ¡*ÿ|&ˇ»S1/ÄB˙=y’ Â•˘}.R'Ú…€8Y•@_È@/> Ç@Ç˚v4ôLHçïØq¡,·ﬂô∂Ò 1'$Â$˜.ái∞Npë∞eÌM¸Ù.¬Ô‡©q‹ÜøÂeÊ:–Å„ Ò‘d	ò'Q∞ç à-Íp)≠ó (∞›ÃqÕ©≈âÈ¬¸ºYªã&P˚P[ÏMˆ√$ØÜóŒ ◊π"7›Ç ¸â‹:Uz„ˇä0&†M≠üOof„çH,›@«∞w˘ñmÛÚŒ‰òÜ6®TB√04∆qŸ≤◊≠n;3”ùdy›s`ééÿ∞ú£ê;“-p:
+°o¡e±mô√◊®)µÆò…âo,<¿"AÙº,Zœ¯2øz“*Œ èM§ÊÃ¥/õàı⁄Öˇ<≠¨%êuˇ◊Èˇù&R,ÃH—ÇËª¬PlÑÌ!Â›qjüéœ≈øKÙ˝®6Ùhéø‡Oi z¢ »®¶µ´Uì‘}ÂÅ•$∞≤AÕqÒ KW4‹≠RÚR‘À˜îö∏Œ˜yìD4ã8%mgΩF[QV—*áuU:ÏµYm∞‰ï–3G"·;µ*≤r®
+ﬁÈ¬‰¸∏öª„»áˇ#Ô¨â|éYGuı"Œ*≤<<ªô=ù= ,Ä‡v/F∆Ωgˇ˚h|ˆp©”´GRŒÜ‰É?eÌûz¨ìø ~˚uèë‰/u’ßt@È˜ÇLC {Pc®/)“Ä#M≤rCÓ`Å*ﬁî&,Œ˛ÏÅpÇøãÎ≤≠wM9ôx’@a∂•‰ôtî/´<ACE^L∫%M¸◊5π∑ÂU π$–õ:≈›: ì¢¨≠¢$˘õÊQìà
++•/Ìnúé+C¿±'Ó˝0D”[Ø ïs√+^◊•€C	"#ËZìpú≠8hœ¬i®_AîsËjób_Y”Œîπ˜ÔÒ˚ô◊cÜØ tw⁄±‰€≈ÙπZmf!k∏ã>>ï6üg´$Î˛“¥D÷!yw˛d(8S´∆º«ÈÍ #Ò∑%∫ÓbzMûù∂ô=£7„~ª8ÜÇj}4øátù*ô/Ÿtå[)!œúÎMeÍÄyª¡6ıWT[ æïMÜ—≈g‚±‚”≠Œ“ºDRCL—4°´∏¨jL–Xß;Äxß]õ2ˆÂ¯¯/ŸóÃ˝æ)KX%ŸIƒÏ∏úÚûˇ>Vqò9åUY
+-Æ›˝1ëT˚ dì3Ï˚Û¿O‹‡åÃ‘ÿ…Ôˆ≥_cOä!˚,∆™◊m6´æÀÎ7yìEø€h%”F‚(’9‰ÆÇ∞ºCo‡Ê»€,
+√’Å(˝{c},ÅK≈+ÂÖ°~›µ¯Zs•∏⁄6¡ˆí<§“Ö⁄úäÒq-;wTÚ2)ºU¥ﬂ≤jCôŸ€ë˜<â{ÿµÂeM∫%X4'SnΩ·¬ˆ%Ω‘1i˚ê†4E∞€?nˆ8\·FØ.≤HÜMÏ—rÊú83ü›Jû‹‚äΩ‹¸ã(ÖN!€~ó^EDæ‹#q∞ùÆˆ@÷0œ"Íu˝R¨–›`[3¨ûtW⁄_çïTÌk1¸GÜ^,"°6%T¡KäB€‹™ﬂ\&XVMk¥∆J≈€‹z˝[ÄÍÄ≠ü^rÏc∂˛†íæljóΩ\…û∑Xd˛«Ô∞tO
+ÆAUvYÜàˆ•Z´ÜµÚfâvvé<uü«®’Zn‘í”e8£êﬁ/≠ıêèØ¶n©Ô≤%QäKÓh¯à}<:°ÿ 0¿@r§≥%ò‹ùáˆ-*!FCÈZ@ì√º,¡]êıê¡nI´µΩƒx÷QÇ◊*¨?ÿî√°Ax4»®$âh…,èM∑ÀÈH•à¨˘L%	XÀíb ∫D¿~K∏ÉEM¯ÆsJÜΩ$d	J∆™w]Å˜ZÊÓ™…BÙf 	“∞9NÌUè={v∑ù»äeÛø´O‘tmØµgπíœ%ÃCXÃô°ê∂%ÀHÌ}úÀV“®Õn~
+^U£Å·J>ÆÇ?oyé0ÌüW‡±ï.X$=!±È&º· ‰|~8oøïÓhçËâ˛QmVÀåÈ>Ã ´¨Iù“TzSoï¢U˙Õ¿w ´ªêˇ3≈6ﬁ5yãïL¨E&wë]$Úñ‡€ÖC{D<3Ωpcª–Kw:á”vöyñû÷´>ÑŸ.UªÓ¥°õı°±ı»&16‰àbôœôõ C€:∂`©‹öÊù=\Ÿ¸Èˆƒ¨gzcD˚&<T÷l≥
+Mª∏!Ô+T£=KôÿÍ»åO! :˛˚∑Ø˝„
+è¥t‘«?£ŒÓGD'Éí\ˆ%âßjÚbmã?]€®⁄Ä~ÿõÊ˜ê,Éifá‹-ä(ª–ùÍAè+Ï5é¡˙‘ Ó ˆöÔêx©=s˜Î◊
+Îéûˇ¡tT_0¡vRÄju⁄Ï´]úÎô˝ògÿ1úcq0t˜zÒë∑\ÇÙÔL∂¨˙ÂQ«ÅÆCJ)ºyhnÆ;`¿d§ '‘ëy$õ75&ΩË=∂|◊ŸúÆsÜ	õ¡èI’W‰$™ÊúËúπ≤ ;Ë¡JW’ã £I“™≥úW™Œ∂‚Ë»∑w‹ S‡CÂ±>5Ve:Ã[ñà⁄©*~Î|á¸lMÒuÕ5[xﬁ†˘ßZ¯xø‹”…C¡Ùé√Ü}f2®vMo3¬2éÈ6Ωß*˜¿VM¨‚ƒû6∫s’]‰âå6Å3ÿIﬂÔÛ5CÔºN˚jæÇt∫="∆ıSå Ü Ìçï∂m›⁄H«{,W ûäÅˇOS "»óø∏›Å£Ø{›îÑPw…»ˆXó°Á‹$›_3•ÁrMrA%-≈‘cnÿ"lÕ›Xª ‚‘Óûx&ß"ï˚‰SYvUëÿ∞"uhSu~¯“”9wﬂUO“ˆNo@ »ˇi^é†’ÛH~gË√øG˘ÀH>ö’•D≠É<úY›'ÏOë$´Í6'⁄œ*CF>LpÜI…`+ı∆‡h∑ı¯±≠Ù»0:eCy=æø«LlËiüıÚ˘6Ëu9›ë
+%Å¬;T•ŸÚÎΩ
+*3‡ã~ò£1ÑÄ8Â˜ØP–xî¬å≥˚b¬S„™·€ªÿ∫'Ÿ‚”ªño˝GY1{ƒ¥Â‹≈¶VÙ •-ˆ Cj˝í} 6¢ç¢Ÿw≤èπ7úYNÊfj÷E)VÒÉ´=}\⁄ G°AJB˝}oú˜{√ﬂÍBù¸¨ø@îåƒÉ6üüùﬂ¥Yz˙⁄ù»öTî\^»3{'*o¨ |k>/aØÚÑ‹ƒ0AáM ÷,Î
+€Ã®ƒ#è•1SÁÖíÕ,í∏v\g·Ã>œßs4˚Ã≈Æ·ë§
+KCIÖı¿5Õî∑øï¸±˜êz‰Vü	ÚπÖ Ø•¥£ò€T¢tËh°ª´é
+±çkÌÿÿVig[Cj‰HUá ~r:P4ŒııHõÌÓ=?‘°:b[·ÄEÖ@Ç%»Ÿ-(§q´' ÖdJ%DäÁÊÒË∏KB?∑h.˝RA›;B6å7dƒ!LLaÚ∂Ú1kÎüÈ˚Ây/&€‡KpFΩÚƒû∏¥Öb>bXêWWqÓzWàﬂ∞Ui$Ω˙p˘>Îä¿!BP»æ2ö∑πÃwÃíDÊv—±H‘B›ö√‡ç'ÒmDMçÜ9l{∑íÁÎ°°>õÔ<Eè\¥[∑C,´(^–°ÇÙÖ®ê‰„"∂(Û˚8ë|˝!^)xÛEã h>DÍ¬]Íuá∫„hV˝¿a£Ã.ÖÍ	DÚ,ƒvt¨≠ÚF8–≤Å˙cç“K√¿*•+Û∫û⁄íeæ»"4ËŒÿûMesyõØ^è¥Ô˝}4´TıdE‡∞yXKS≈∏πü§}ìÖî√	î"—›ó¢Œıª_ëÉÓMB4üºÈœ∑üM›hèÓ–¨È|Y∫?:Î5¸}&Ü¢ÌgˇøWûzÈ¥3F√<·Mn∫Æ{2åî’Hoœ⁄ÿÜckﬂHíTÎ7Z$T,ÂÂûÂÁå”,Ô&,õ÷x⁄TÔ¸õL>;Û–ºëMŸ^±Iƒ\µ Ê‚Åﬁ_ÇúyûÚbw‰‹!Nc<Ωi˚ÿ43Ãœ˝7.nÿÛv⁄D„†˚9÷óiZÓóí+ë¨d„|1ıßK^®S∫ìuëöÇÑ<f§K %p[≤ÜÚäëæG¨˜◊]h@üåÔzÂ€´Í4è≠0Èˇ±ŸO Ö(”∏™Ë5≠Ó»N#âA	©·2è*ü›‚úˆbæ¢HWÇ]£B‡+LV;r–À‘î'DDäØ‹—e‡'ëL@ç{ÏJãAcó;∂µ¬ÂŒ˙7(TBÊ≈Œ¸Öd¸ÍF†d®ºNÆ„ªkÉ&@n⁄º@ãeîËåÕ…j“V∞˘Cà(
+§W9´a’ˇ¯•#MXèu°•‚+ÅRÉc˝“ÁT†ë´÷Ëª2M◊Ç∏Â„üÉÄxü˚6/_˛çró0NA|T4}ß==5í±dÂ+—kúR˘€ú‚£@k¨BÓõ$õÜoˆÙÿﬂô˚¬c/°ç·|Q∫Ä·ÃC</f÷r!LÇÒ±I ˝Ótj»6DÍJÃvÄRRÔ⁄éFàÓƒn°–«„~P_§ŸAúô«6yuX327∫Ë∏Zn≠UóƒÅ©‹êy•3∆{D“9†µ≠°ﬁg–ËÏú§nÄ∏N∆
+Ôlÿ–˘‚ √ÏÏ †*Lã˝7nΩJ≈…	p?Å*¯l\”ç‚Aumªß@»ÇhπvA	ß µ‡õlx·IËpêÚòjÓ{èÌπ‰◊ÇÀCØªí
+\jß†¥Û;|˝_≈¯·Àm@\L˜_0y
+®"$5‘ªîDw5œŒofì˜öÂ_ËKxúïTœ´”@Ê·=Û¿õ^º,àlm<Ë≈'EE<˛¿ä •ÑÌÓ¥.f∏ª©ç={
+˛“´‡ø‡ˇ„≈›$MZ^Q‹C»|ÛÕ|3≥ì¸∫˘Âˆ◊Wπ– 8dÀÔ˜]k¨Àï‹|;¬«åÊƒZÙ≤|÷≈OîD≤‰,B˛`åM!ë.SÁùﬁä*òÅ•ÜkÁS†!
+ªÂ ß,Å…s0ã£ıœ+◊◊”ﬁÁÃáå±Ê˜Ê“:O√ì*o8|Ü,‰≥îqÎüA$mhôÅ7`œZz8>g
+Kí≈ˇ
+]ÅM˛.Uº˙ùΩ∏Nåë wlã©6äz}õR_OÏìÌUR˜ı·–®¥ƒ˘íª∏‚$QK∫Ö‰ä0ª6’ƒΩC3eë%íÂ|jà·`Q3`—™Ul÷Ç;h”#ÑÀ∏´L.]õGπ•Èr{ÂaK™	tÅµoà≤¨÷ ≤ÎUÖ‚ù˘¯æ®b‡âuD]¿T-¬äËíPZà"W¡™‡ÅÅê1ÿå®≈¬÷vÿ∑I'JájxAÈéóÚ|s˛jÙÙ≈Û>∫x<∫“Õ˜êŒ¡esÓ≤∆éìıèì{«{Û˚‰noµwœaï[%,}è˚ùÌ+CÊ∞ãqÕ¶ªv›Ùe§Ó˛∫\Ö•;‡p\Ä*&"⁄aOÊú\R§_èÔd˚™ÀL(V‰`ácü2ÎGß7û1N]‹≤ô¢~˛ŸG-f¥òvIõu®ˇ3úl‰È€^¥íË{ªhÃ‡®Fxúõ∆2çeÉ£Hy˝IY—sy~Ô§ätÉVœ≠º?YÉÒ ƒ	÷´xú340031QàèœÃÀ,âè◊+®d¯{xû√Mã5”˚÷<„NòrÚÖ”' P»,I-J,…/*f¯€>gŒ≈∑2=µóî∑Wk\»~∂Ú>DMAQ~E%√e·S«8Ô$2}æm∏GÓí¢Î'Iq ëá.MÏèÿRxúùWœo‹DV°¥R
+äDìÜÇ†£ËÆ∫]%îv´∂†HäBRP´R-≥ˆs÷‘ˆœ8õÂ‚n≠|Ap‡åT"˘WP≈ëÔÕ¯«ÿŸiWäbø˜ΩÔõ7ÛﬁÃ¯ÔÎ?Ò_ˇ:π‚%"d<I¯î˘a,e^ûû¸ÂDÊÇ«<b‚Gª√á0Ì‡_w}Å·Ô‚≈ã˙ˇ6®4â$Sc`ËEñ\ü+¶u¨ˆ˙Qú*çπ¬F\ÇÀD§=NÍÑ)Æ|¥{"ç2c¥àHv˚<ÊŒ˙‹q“0Dﬂ	Ù]ÆxˇCòˆòóFNYà¢π≥≈ÂÛ Yåè]Õ∂éè<§ë¨W√VÇç†à◊¿≤DÁ∂Œ∏Ååπöëûl&◊òﬂ#S_˘!H≈√ò˘íEB±èEfÈ◊Ñ\∞5ÌÇ,(‚|ÊK‰æöŒÁh¬÷“È5Ì¬òÈ KÊìî„õ	©dsejÿ\ï
+rXdÉá~ptíëÑ·hq'b2üïú≥È–càÃzÎU\p~Ë‘„≥íJ“	AçÖ)åF[l%‡˘˚ùXˇÎ÷íXekp∂£”XAõL≤/Sâ≠Ê)úBÏÏ£qª~r‚´1∆!kÜ¥e9—œ›ö*êòéI‚“≠KΩ¬—]®êŒòGª∞π∞è» ¢é€≈&\´†ì± Îÿ◊lïÒ»Õl≈˚‚ dﬂÛòïıa]˚%ØVPﬂkË]c´Mûb1ÚØùÃÍ®&ssøø∫n3^fk∫á[)Ã±_∂&◊@è§Dˆïêz=;≈dœÆ3¶◊÷ëµ±M≤¶4±â‘ë–∆R÷CfD´ºì–˝vM÷“V.:çÔH*PèI?rÇ‘Ö¡ù$Ör{1>,ñéHË.‰o,\Õø=”Õüæºñ:!%^ü({¨Íœ¬Ëx⁄Vm	•˘+mÆ˜£“æ◊c’~XÿîÏ6ä;û⁄‹87äÒ5ÎPÁãë∏Ô7üŒ±¬ﬁ‰Ã;≥Zß≥RÅŸ©¿úT`F*0#„†,ÆÕMCƒ3≥qÕvp˙ï«/-ˆÿ–Qé“y›´/úx›jª mtÚÔœæ}«Ÿ'gVÈ≠*_P0§:Ï–0>
+∞,Ã”Ï‰.Ø‰èñO›€.A˝@`≈ŒÄùBƒ\)<»á>n}\â§EJav¯‡à$)¯&`”∆∑uöQñX!ˆ‘±“j©ùøK¯£¥⁄AñXsqå‘C∫õ–’#ˇyÈ≠l‘F	ÍT.ã√êÔ”¥7« S5ñ:’Ã¥ñèegöW®=`{äΩ'ˇ}i≈Eâ€|ªheße Ö+…oMi/¶Î√‘‹Ÿ‰èã°§rú˜œΩôŸª‘M◊eé.[‹(Í}M‡ÕâÓP‡ù}Nx¡¢√áÖ<‚∏;rº0*gÃ&	MﬂﬁHÌ¬¶;0¬nãú¸˛πÕ¸õ≈I˛œÚÈÌ4∆õ"‹å‹ﬁ¨Ã{1Õ Ü©Ñ≤jËëL âH\*ÕM˙H8<¯¥ñºM∏≈Ï&"nÛ€ª‰òœe1æTö¡tï÷m≤U¡v7Zqÿ':lHÀ,ˇk≥ç¸t–pòëËnÜ7≥‘A≠2>Zà∆|a«†∑y©°úJ·0Ü$Ù•ƒòÊ°ô∆ˇÖÔhÏV⁄Z"t6∂å=Òé'r˛s¬>ª∆òÀ„‡·"»gÁ7Û§+{û@QˆÂle:‰è≤¬œŸq≠´êVp?ˇw˘‘òHûw4•«NòäûWãv=„1ﬂ>µç¶s!;5¢}^iOãeºVr?RMR¸ërÒ0≤t·}Dæ◊∂˜±Ì£»\Í-í©fí˘À2}VŒGeoﬁd´Á‚≥Z√◊ãÌù∆—‘DÊÛªzG±(GÙI$ãõ*£ik¯J⁄Ú˘”Âï>¸¶•˝¬gf∂\‡µ*xúõ∆2çeÉ£H[…S£Ää∑õ”'¶œ:ü±‚ÄrÚß…åÔ ◊(Y´xú340031QàèœÃÀ,âè◊+®dHZ»ÿÚ"W≤dÈ±:ı?¨÷√˛rô ÅBfIjQbI~Q1√ﬂˆ9s.æïÈ®Ω§ºΩZ„Bˆ≥ï˜!j
+äÚ+*.ü:∆y'ëÈÛm√=ró]?IäÀ  ∆‘+æ„ãdxú[ô∏2q√j~¶ÙÃ…yÂ6üÊøß  Uª;‡∂jxúõ∆2çeÉ£»ºÜ≥[ﬁw±Ö?[◊˘∑˜MEËU˛‡¥…åÔ Ó®*´xú340031QàèœÃÀ,âè◊+®d‡{Ô¸¶¯ıŸÁ˜9*eÖÛ§¥â(dñ§%ñ‰3¸mü3Á‚[ôÅ⁄K €´5.d?[y¢¶†(ø¢í·≤©cúwô>ﬂ6‹#wI—ıì§∏ Çc.·ç$xú[ôÿû∞!ÉwÛ~ﬁÉåõOÛﬂS  I „´xú340031QàèœÃÀ,âè◊+®dXpíΩ%@8∂¯yDƒŸ2ˆ≥_|tøŸò ÅBfIjQbI~Q1√ﬂˆ9s.æïÈ®Ω§ºΩZ„Bˆ≥ï˜!j
+äÚ+*.ü:∆y'ëÈÛm√=ró]?IäÀ  Ÿ»,§x340031Q–Kœ,…LœÀ/JeËZP£[‚&ñ–c≈ÛÏÕ∑X˛4≠D%Cà*OgWø`WÜªss∏,„éÓ]˘ö≥Ô¸5ü·ôU‚ÎËÁÈÊ¢óô«‡)k’&4Mç#{⁄‚∆X±Ï‹˙˚3† Ç\]|]ırS*ú˝yû˝¬@'`ô–ôºØˇUò ÅBjEbnANj1ÉjÏ√ı™'ë˜Èõd~ﬁÒ€!c®9©UÒ≈©%•zïvãû•|ªÏ|à[◊ôÛ˜ø∂/cKÜòTPôòú\ö[öìœ‡∆qw˜‹W{6§_≠‘ñÚ|\õtGjVQjaifQjnj^I±^IE	√ŒÙxqU√òbãŒΩ„ó˛Íù±w:'LmAÆnf^qIbNénqrQfAâ^qÉÛ…/Ôéúwˇ/õxœÆPHÜ%àıO†sSSÖ¢“º¯í‘b†…@u≥üz©˙'÷À€9-·ù¬≠p"j0–7%ôyÈ≈ È{«G›X'oºπ∑jÍ˚ß◊óÜ?ﬁÜPÒ¥ü[”v7M∂7äÕá¬ä≤´Ê≥ÎC<∂ç·√\◊Y˝Âœ¸∏¬{:VÙÕÀm÷˛ £¡f‚ÇKxú˚¬<çEÕ–¿¿ÃƒDA/=≥$3=/ø(ï¡uä¯∂Øz1{öˇùN÷òb–È6QÕÃ¬V†(èKˇmgJêÀZ—S?õÑ€æBu˚&fß¶eÊ§2|~—1È èNYvﬂiïπ!.'+ôNN,hë\*≥¸Õ•MBÎÌdßÕ…∑Xh.ü=a2c¬‰Fì(ˆøº	ˆõÑ2}s‘éiKO0ﬂ8K‹ƒ JRãKäûj0làcÏîùv∑ˇ-”£‡ ‰•PãÀRãä3ÛÛÙ
+*,˘≤<*ôÛÁ°Ç„˘ïµ÷,,z 	GX¿ÔÄjxúõ∆2çEÕ–¿¿ÃƒDA/=≥$3=/ø(ï!_r⁄Á”Gñò±wTœ“˚ŒÂªQÌ# húm∑xú”“+®LÊ“KŒ/K-JLOÂ (…ÕrÙπÙ2SRπÇ\}\É]u√\ÉÇ=˝˝∏R2ãKÙ¡dQfRiI™ÆWAebrriniNæ^jz∫nf^Zæ> ·h‘ÍLÄãzxúïTMã‘@eaw2‡M/^D:3Ò‚≈ïAE÷É8"»≤ÑLwÌÿò˛∞ª3NDòìwa¿ˇ‡EêΩ
+˛˝˛/V'ôdÜ]˚Ú^ø™W]]…œk?n|º”“hÎâ+øﬁæªsπAs∞NhuˆiáÓqñgŒëßÂsp>~†•ÃD•‘äò2Ò∏â(™héYa<¶ c$n≠!^X +<ê,œI‡çVﬂ/]YMwﬂ/ô‰rLç0tH®PŒ£åûTy√ßƒA~öp·º”"ò$ç,µ¶‹A+s&∞†x¸Ø–%∏¡ﬂ≠™Ç◊Fˇ·≥◊yÄµJ„â]15V3Ùw	√zbL∂UI%‹ˆ≥ôp@&•Û ¬«ïfµ¢ÎƒBÆ3é∑Îì˘W‰T[í©í(xKr1µô‡H”‡—≤ul∆Bxh”ê»L®∏´ÃX°|õ√π¿“LπæÚ0%U∫¿zoL“¥ˆJ”òöe≈“ç˛‡πòÊÄ¬:¢.‡òéFLœ√àò2c¨êEÆ™ËëÖê1`VV¸|ÓjÊÌ§3•C’º‡t≠∞Å/üM>y<$G˜'Gh›|…|:>mp<X}€øµ◊®Wø˜øÙr¡@·—«´_˝ÒŸÁﬁáùÂ÷Õá·nΩ©‘Ï5vkõÕ`ìÜO7q›ÜÛL›èsÏb∆Ç/$Ë‚¬DôÒEòúŸõB1Ã∆Ó…˙’î©‘º»¡çè)ºK¨ÓıØ>‚Ç˘∏UsÕ∞¯íñ≥F"áœ.i3 ıüß£g™ˇr7ZÉË2?pa‚ä+xú˚¬<çEÕ–¿¿ÃƒDA/=≥$3=/ø(ï¡uä¯∂Øz1{öˇùN÷òb–È6QÕÃ"ní˜≥‹<ÔWo|ΩÔK’Ê∞ùìY’Ìõòùöñôì ˘E«§É<:eŸ|ßUÊÜ∏ú¨d:9±†ADr©ÃÚ7ó6	≠∑ìù6'ﬂb°π|ˆÑ…,å	ì{M¢%O}d∆ûÿÕÛ6§di·N—CeΩœLÄ@°$µ∏§ò·©F √Ü8∆NŸiw˚ﬂ2]0
+ÆL^
+µ∏,µ®83?OØ†íÅ5.˙ƒé#!GV§ØeHv6™=x¬O ©„Zl‰Äjxú4 Àˇññê\=rn
+/ÌâdRD≠$ ˘ÇÜı±pí9k¯‚tú¸· >œ©}¸¨°rÏ*> ÊåXxú˚¬ºèeBåE‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥¬–¿¿ÃƒD¡71;5-3'ï!ÃzyÛŒ5ˆäﬂ≈ﬁ∆5¶∞]í»∞abAÉ»Â˘sÍiÆ^"—8˝‡§≤«˝”'[Ofa‹UµíÒÆ¡"«é°sØ:8∞*OtXjb 
+%©≈%≈œ3Ì|8÷ú`=æS9Q}â{åÔ€YPKÀRãä3ÛÛÙ
+*>»IÀû·z∏ò„`Ωë˜:Ÿ‚µ”ÃÁ ÄãKbÌÄCxú} ÇˇæñêÄÛËàí¡,vkXÀ$ùTD…y…ëîÙì∞4Z¢cï‚6aãÌTt•qπ¬vçÊ40000 tests òÔU¥5?óF!ÃªŸﬂâ≤'100644 version.py ^[»∏ƒTƒ®g≠ cC2}¡»NBè4Ç‰Äxú4 Àˇññê\=rn
+/ÌâdRD≠$ ˘ÇÜı±pí9k¯‚tú¸· >œ©}¸¨°rÏ*> πxú”“+®LÊ“KŒ/K-JLOÂ (…ÕrÙπ k‚i´xú340031QàèœÃÀ,âè◊+®dXi—’ö•uô5IzıÏÖoÖòOﬂ‡ﬂob 
+ô%©Eâ%˘E≈€ÁÃπ¯V¶G†ˆíÚˆjçŸœVﬁá®)( Ø®d∏,|ÍÁùD¶œ∑˜»]Rt˝$). ≈q+≈ÌS˙xú}TMã”@F≈
+©"∏,Çß°†¥–ª◊b=…DÒZﬁNﬁ¥Éìô8ôÏ“SŒÑï\ƒﬂ‡AÏ’≥ˇB<˚+t>“§—dJ'œÛºœ˚¶˝˝‰œ”ØEÑ1â%ÁÚÇâ’‚-n∆Ê3ôƒú—h‰æœPÁJdDØëñ∞$¡àÅFæibÀDökß9"K»0"R8‚úÉâK9&(4hfXÊ¢àLå+"’*ÑËC†4Or.C*Ühü„fJ‚\–*≤*j‡ÒKPö7WíöÎƒeõô+$∂ìY›∂ñdâU,F^V(ÁmF¿K÷†;Ïems≠·∞ÿB°f	fíî∞å©…)–è—û∂‰hNNÖØ‚©‰oX∆ñå3ΩÈœ—ñÕ˜VJÅ[^[„«Å{e^Â`û*[•Ë-”»z´‘íˇãúB¬¯’>ú§∏¬ÑœÒOn%/˙≥Z≤;ùa|"øo∑≈Ärÿ^~‹(ﬂ'ÂØ€'Â"F9œê«afnSR˜QÅ4vXm}øsp3˜~>%ıﬁ+Lgì∫ÎÍ≤v<y Ây¥glwîâ4ÔwÀ†˝ΩVx;g˘mx‹X¡.+ÿm{¨`áÏ∞‚	Î‚qØôv∫êiìm{ÎŒ«õwßdA•Hı¸µ q˚ÈﬁıkÇΩj;⁄◊)?<⁄~?¯2<∂O≤ˇor‘∏0C»∆∂=„ñßƒØÿNß¸yxøº<<<€âB.WLtH'Aß;∏M´xú340031QàèœÃÀ,âè◊+®dx6˜—ÏMØ9{wkÆ+è∫qËIODCà≤í‘‚í¯‰¸¢Tê∫ñÓ§Ìπ÷¨[π3&+¸€›8£‚fM ≤∫Ãí‘¢ƒí¸"ê⁄c¸L|÷‘æ]æΩv“ª$ñü %’3nµ§xúÕYKo„6æ˚W∞⁄C‰¬Ub/zŸBálö†FÛ@coÉEj¥L€D%JKRÎxã˛˜Œêí-K≤Ïu”á%Õ„õoÜ‘êyÛÕy¶‰˘îãs&>ìt≠óâËº!∑<dB±—	—KF.S¬üQ2◊+*πI21£ö'Ç∏ó£õ.Å[&I"I$â…¿Hò-˘4”(≤	]H∆b&¥Ú1f¨ﬂ?åáW◊dŒ#Ff\Y%pæ‚z	vÙí+≤J‰ÔdñËl∆—1ç ∂0$[P9„bn”µ‰ã•&…J0©ñ<ı¿ √›Hî5k|Bêì,è°nŒBè¸
+f–…¿ª K.ä8˘Kß˚YÉrL◊D$ödäï,≥óê•Ä™8ç8!€ÜµÒ \|Ãm$SMAúö0H2/ã™;o@Ø•÷ÈªÛÛ’jÂQÉ÷K‰‚ºÓ¸Ω]gÉ 1•Ä•Oó@ÌtMh
+ÄB:ò]aﬁLrLŒ¡JÕb—#*O:X)'gÀVÅÇ. _TÁrDÜ#áºøG=∞Ò4ˇÙaLû./Ô«√Îyx$W˜?«√á{∏ª!ó˜…œ√˚{ÑW‡ÜΩ§ÒHé<≤¶¥®ü ñﬁ´îÖ|ŒCàK,2∫`dë|fR`u§L∆\a6¿õÅïà«\õ"Rı†ºN&+∏÷LÈÕÉtM√0ã≥(ÈÃeóÓI.Ò≠}'·Ô≈£;w:aD!òÀ\|V›¬ºáwWT±ÓªÊy∆†‡Q∞`:P!AòDY,î´X4œÖ¬[Ã2©Ø?e4RÓ=L«^	ñW∑Ò<Èv[,<ìH_atnhÃ£µÔÑsß˝R@4ìËì”%ìCÓ»≥’EÒ…´˙ÓÌß_´w‘¢€Õ¿<â¢dEP)È˙pT˚Ì¬Ÿq_µbÑúV*jâ¨⁄@Å‹Êb†q~◊jVfA¸M∫>`°ˆo¿ÎÓ»y!L7°Ak◊≠ºåíGSŒ-ú&MÅåé=Fjrûd:ì"¯L£åÅíb⁄}vtS§Ê˜≠3…∆K€Q)ÏÉ~,ÕAH£àÕ\ò›<í∂|ÏÅ”38
+¶b7O¿^¿ÛúÉ‰⁄ iœFI∞öé±ÃX#˜;a:Ò⁄‹;áÌÔOp[7Sœ"Í!íÛ°dT3õÄˇñyãƒ^;Û%¡vÊ≠R9¿úó-≈yèXf«<f„u ºª·ÌÌp‘-åW»û±à˝?»∂H⁄»ﬁ¡zÄ∑íµckuó…çˇƒX$mƒÏ`-UÇ#ÿ™ç§íÂcã´l≤ﬁÌHËﬁNfK÷£ìûN¨—∂w’)Áº¨ø8ç´]	§l¥‘¿B€"f<´Xª?Û¡?ÿ1l-’y=˘3ÙØΩôúº∑œ∆€‰(v’ÈÙ‚¶È´Kv#h¥¯µœ=ÿ˘qVlUˆIÖQ¢Jyh¸XL©ó¡Æªrv|˚™§~Q0˜Ó:Ú¢_]lÏ•Ÿ:G¯o\+ÍÀqM™œv“LJsÕT2àÉjSP¨àŸéÜ='T+éÖà®©Nd -%n√øz∫Ó-Ò∫Âì´=ïIªÚç…W¡X3:Ã#ã◊≈ØåÔ~˚ûiøV€Ps˛v‚Ö©‹Ü¿æ?ï<Å“Z˚É>ÏFq;o_Ü_	k«N·ı
+Ì˘gaˇ¨GåŸ3ÅC ï§9S˛÷¬¿r.;|§\¡RvmN†`∂îÚ≤ôéıx<√¢b•ˆa63Èoµ0YeCö˚èÕ˚ÍR∂#eq¥´ÓôˆÙÂó˙„é^äèNˆŒ∑—æë… ∑Ö√“wK,@r˚ıj˝TÂ”M,<•©‘«ä&iw/0≥\Á»`<pNÑˆ3[ª{›#Añîø]l’ˆ ﬁÇƒ”?FŸå’zêAz/”•^Ÿ{øΩ!ÌÄpéÁ]v¯	œπv≥c+aáFá∞•ˆ˚Ã˙®˛Ÿá»à¡ËÀÀ´TÄ9á€ûÀıÊôÜÕ#ßà¸ üÚ◊=Dub%U‹‹*Ó˚5˜H≈NMÿ’°Ëté[ äé§∫.∆ª=S≤Í∑ûbX	hú<¥v≥ “4SıØr¶ˇ&éä˘çMokr[íõÍ*Í∫Hö8¯”Ó»û◊~0û‹£ä©^=µ€6wﬂ#vÛ~≈¢»Æ ‹·ï'˛=6vO¶k<.˜˛π-˝Œ¡Õ”˛Ü›±çn≠)Ø	lﬁN·a)V•}¸:±ıˆÀç<}	b'r˜HPD∏bÂøΩ∞Ï'ô∆€Ô·n	PgP˝√ë{L`•L£\@sWs∑ÉÂÆ
+•îÁ7ﬂ·U›óXp∂*Í©òz€Õ“ÜÈÍﬁ»‰dª4ÊÊ√Œ£¡:uæ8ì≤—Úf∆5ª•˝†π*†Ù»∆Î;RÒˆg9pÚﬁ?%r–TÙ;zU¶Ê2˚SfØ◊7˚Ã¡‰ıπÉ_ƒıÆßÅ“&œÛ(SÀ&BÕã=”‹ºkE{ús”˝>Ì9Mò6˜Œu’@
+Ì“≤éá≈.‘Wvü0´Œª¯WD$+b≈ÒüÕûÁùº©iöRØc´Zlß[-ÚÃæ™·p¿™7 ŸïÌË´”A£1Â¬ÕMmæuˆaß√Á$Ãip@|üúæ	Ç3+üã˝tâöÊéJxú;Í≤3l√JÒ…[ƒE'Øsöl#!<ŸFÃD@IG!9?«-173ß“V)9mræò ‰I‚NPEÍ Eì˜H®N.SäªN~)^3yìî–‰6	ê∏∆‰œÇ πÕìƒ5Å&åì?J(M˛/&?yæ8–>qæ‚Ãº‰ú“îT[∑ƒú‚‘…s≈ÇÄ&1≈L∂3≈t¡{1}†V^l∫‘†∫Ä6©M˛(¶R®ò\f´TQ	4'ƒ™™ ≤∞Z©)¥(,≥83)3'≥§§	n»#
+PWG‡0¿ò…“rÚ)êÁ7ÔëË‰ ˝©w+·
+ßXxú˚¬<çeBåÖ≠@Qó˛€Œî óµ*¢ß~6	∑}540031QMÃNMÀÃIe¯¸¢c“Aù≤Ïæ”*sC\NV2ùúXer£I˚_ﬁ˚MBôæ9j«¥•Ö'òoú%nb 
+%©≈%≈¨«‚6-a≤tõ„ıhyê’ÕÇm˘PÛÀRãä3ÛÛÙ
+*,˘≤<*ôÛÁ°Ç„˘ïµ÷,,z √É@ﬂ´xú340031QàèœÃÀ,âè◊+®dàôigπÁÌÇËWA™o YÍ’Ã˛/ó71 ÖÃí‘¢ƒí¸¢bÜøÌsÊ\|+”#P{Iy{µ∆ÖÏg+ÔC‘ÂWT2\>uåÛN"”Á€Ü{‰.)∫~íó ·J,
+·Äí~xú{i˜œvC◊‰NnÕ…˜y'«si‘Âó€ßÊ§ÈY:
+…˘9nâπô9ïP¡‰4∞X`ibNfZfjL∏,ñYúôîôìYW^¶£PíôõZ\íò[ +)÷‰R@ôi
+y˘%
+IﬁÃº‰ú“îT+∞í…	‹"˙@w(ÿ*§ÂÁ‰‰ógÊ•«'%VjJ,*— ¢7y∑¬©ÿ|ëä›©8|ëä≈©X|ë yÄ·É'‹ö" ∑Ê†:u3;oí •5\‡ÄTxú˚gª⁄nÉÆøéB|r~^^jrâmHQiÍf]!&F).(»LÉK[Å'Î´m^À ÉŒt´xú340031QàèœÃÀ,âè◊+®dx6˜—ÏMØ9{wkÆ+è∫qËIODCà≤í‘‚í¯‰¸¢Tê∫0˝¬v«zÀ_§^í
+Ê;ˇÂMÂmduô%©Eâ%˘E µ«¯/ò¯¨©;|9∫|{Ì§vI,? -3±·
+¨~xú˚¬<çeBåÖ≠@Qó˛€Œî óµ*¢ß~6	∑}540031QMÃNMÀÃIe¯¸¢c“Aù≤Ïæ”*sC\NV2ùúXer£I‘¢‰©èÃÿªyﬁÜî,-‹)z®¨˜ôâ(î§ó3∞ã€¥Ñ…“mé◊£ÂAV76¥	‰CÕ/K-*ŒÃœ”+®d∞‰À˛Ò®dŒüá
+våÁW÷˛Y≥∞Ë ´C–·
+Æ*xú˚¬<çeBåÖ≠@Qó˛€Œî óµ*¢ß~6	∑}540031QMÃNMÀÃIe¯¸¢c“Aù≤Ïæ”*sC\NV2ùúXer£I‘¢‰©èÃÿªyﬁÜî,-‹)z®¨˜ôâ(î§ó3∞ã€¥Ñ…“mé◊£ÂAV76¥	‰CÕ/K-*ŒÃœ”+®d`ÛÒì˚”ixW∞äaUwÃä)w•äü@Ø‡[Ä≈ xú≠îÕk€0¿i÷§çaV
+elãöí &éiOÖ∞0∆Vÿ°Ωg≈8ˆk#öÿFR⁄§ó¿.;ù∂ÀÆ;ñÌ:v€.É›˚Ïﬂò§Vâ„tá	È…Ô„'Ω˜¸eÌ]º-¨˜è	˜OÅ2íƒ‚]°~´Ω}¯Èk·˚¬ñE˙iB9JòY±—d…iB'Oƒõ≈ÁÎ=j°Ií#ΩƒÂ"+∏HlWÔágQ+a^Æ}∞}ˇàÙ¿˜±_‹,G¿BJ:‡ã§¯`◊cúí‘v,Ì—x=HRàÌ6ñ‘ÿEò¬i#(%<€{¸ãJÒ`Ãí¡Ô¨+mRÈ*J‹£D
+ïŸé<Â$ÄÒ?kïë⁄Õ†”ë°3,ÂLjMòï_è•=¬m<n‡©WrÑzY8®’B;Õ…75ÆÔ^q*	6ç=s⁄.¢–ss¥⁄÷héç™?tı4∫öŒ•¢ú¶ó°Tcs'àÀß(Ü!GÁá˙À2†®*ìv´*>Ú`⁄?âπΩ¢’—é÷Ayu\cûz"/Ç”√®ÜÏı·29ß¿46ó4sji-Üêr¥ß'≠#w¶óÜ1÷ÎCù·Sµ îzgîp∞±J[’ËÀX))SyÌI—{G	Ì‹óël˘:é®îÓéÁΩßFVïg;≠ªäì€üÜ¸Àa˛HuÁü±d ŒóôA Ï˝CSü‚Ã%%ìaıªp≈∑‚Öe ”≈bP⁄_p≈ÁR˝ˆLÊ≈œ“n≈U‰’Î2ö+G‘ó^Øπ¶T˝¨ı«•8Á-_ÿÊ<3muì˘èÂ˜∂Ωm¸õˇ£Ú˚-’.Ÿ˝çõ}≠[8áÚ»zí€ye=¸ÀŸ¬ÇÔÖ9xúõ∆2çeBåH‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥bc¡2F ‘Pùºxùê1É@ÖwE∏A⁄Çﬁ(›úZ°
+EŒP5GÃ˝˜Ω≈ÇÉC∑‰ÂÒÚÒp≤ƒ≈≠Ã/Á‚TÊôJUz!WOv$…HéfvÆåqΩÎ»k‘∑í©ü§-”4ÎÉ¡QFmàÒ∆‘Œ«p_ßV÷‚Pˇﬂä‚’ã›BﬁHﬂmbz$4Å∫2	B3Ü:Ñ¬Í≥t;‘8•ü£Ç#,È_„F˚ËÚÍy‰·Ä0xúª√Ùöi3#ón™ÇRLû≠≠≠¬dFu6 +&o≤6£! ö∫UÍÄΩxúª }NzC#_fnA~QâBYjQqf~ﬁÊiåQÏíPé^zjI|zfI<îØ°π˘7«U ücÌ¶xú340031QHŒ/Jç/I-.)÷+®dhÈN⁄ûkÕ∫ï;c≤¬ø›ç3*n÷Bfñ§%ñ‰!„ø`‚≥¶ÓÂËÚÌµìvÿ%±¸t  {y"∂·
+∑~xú˚¬<çeBåE‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥¬–¿¿ÃƒD¡71;5-3'ï·ÛãéIyt ≤#¯N´Ãq9Y…trb¡ó…=å&Qãíß>2cOÏÊyR≤¥pßË°≤ﬁg&@†PíZ\RÃ¿z,n”&K∑9^èñY›,ÿ–&ê5ø,µ®83?OØ†íÅ5.˙ƒé#!GV§ØeHv6™=x¬O IÖBã‡Ä,xúõ∆2çeÉ£H‰‘î ¶±È´≤≠nÆŸ≠’º-¿öo≤„; √ì´xú340031QàèœÃÀ,âè◊+®dh‡L÷¸Í´Z}E»ÚoB÷ﬂï¸ã[€MÄ@!≥$µ(±$ø®ò·o˚ú9ﬂ Ù‘^Rﬁ^≠q!˚Ÿ ˚5E˘ïóÖO„ºì»Ù˘∂·πKäÆü$≈e ≈+”È!Ä£Pxúuë?K1∆QP1glã‡îEπÉ„¨´P›‹Èz¶◊˜J ó‘$gÈ‰Ï¶d)‚Gpoı´àããﬂ¬‹?€¬$œÛÚ¸íü≥óÛ∑2égævNLà‹{)¶},î=˘8ÏÇ$îÕ*1äÌ2%å∆d-ﬂÚÄ*:§åÍøÒ;köÄ“$ôTöV¬Kã∆òçK≥Eyƒ“ú#Ê∆È€∏èc¡òòR>âîdÊJD§¨ªgﬁùﬁÇö(†ô˛°Ä
+h†(ç`{AÌxùº´ò¨VÕ∂ZOª>#¡9D∫-S»Ê{Îkh)≥∂´¥ÁˆQˆ—~uz˘≠êF€Õ@ChÛïõó∞m…êÅèÀ?Ãﬂ¿|v˜ÕcwÛ™
+òSﬁ0Í!Ù5uÆû·
+º{xú˚¬<çeBåE‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥¬–¿¿ÃƒD¡71;5-3'ï·ÛãéIyt ≤#¯N´Ãq9Y…trb¡ó…=å&Qær˛?[w£õ◊'ecD¡€ﬂ€Â_õ ÅBIjqI1Î±∏MKò,›Êx=Zdu≥`Cõ@>‘¸≤‘¢‚Ã¸<ΩÇJ÷∏Ë;éÑYëæñ!ŸŸ®ˆ‡	? ’πD,‡Ä,xúõ∆2çeÉ£H‰‘î ¶±È´≤≠nÆŸ≠’º-¿öo≤„; √ìÈGÄ≈xúïT›ä”@fã∞kºÛ õïI†çàﬁ∏≤Ë"ÎÖ?XdYB:sZ2?ŒLjB_A(¯“[¡W%|
+o<ì§IÀ.äs1pæ˘Œ˘Œ_ÚÛ÷Ø;__“hÎâ´æ=z≤w£µÊ`ù–j˝uèÓsV‰Œë◊’[p>~¶•ÃOé"ÇáRjKELïz|D+™aéYa<Ü «$P‹ÜCº&∞ Vz yQêÄ9≠~\ªπö>/ô‰ËrNç0tH®PŒ#ç^‘q√S‚†ò¶\8o≈§"iKÀ,|,Öw‘—√¡ò),<(ˇÀu	.˘ªTùFË?tv¸z∞Vi¨ÿïc5C}ó2Ã'∆`;ô‘ƒ]=õd\9Út!|\sí®#›&
+ùsúÆKMÓ?ê©∂$WQâbbs+¿ë∂¿£eßÿÆÖ–ÖF*s°‚>3cÖÚ]¸-ÂS3’f‰aKÍÙéÕ€1…≤F+Àbjñ5J∑˙Éu1ÕâçGì¿9çòûá1UŒX)ÀB´ÜGBƒ`{∞≤∆Ás◊ÿaﬂ.zÅê:‘ÕJ˜P
+¯ÓÙÕ¯˘´óCrv2>CÈˆ{Hg‡≥ôYk«…Í˚¡√˝ñΩ˛}`∞‹ôsXÂNâ
+√'tÿ€MAóë¶≤KË"Ï”∏tŸæ<›î_Üò]·'≥ A·Ë∑^WwÔø‡Ç˘∏É∏fXﬁC“a÷HƒÓ=€y6?äN÷Í˝ ⁄ IÙ_ªXÅ‡Ö	xúõ∆2çe√Fë«+R‹ﬂ._€«x˙k‚Sª8&£®…› ˆ/wlÉ]xú{™2Wy√QæÕΩ¸7ò &zv„√Hxú˚¬ºèeBåE‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥¬–¿¿ÃƒD¡71;5-3'ï°N:˚Ù€ôõKû‘8Lˇ†≤gªaî˘øçå"è.\r(ª˘,mâ©|–Å¯/úÖzaìØ0*®AM(K-*ŒÃœ”+®d`çã>±„H»ëÈkíùçjûì ùI7¨Á	Ñ¥3xú{ƒ‹Õ™‡·Ô©`•êúìöòßêTöôì¢êôW\íòì£PíZ\¢PîöûY\íZ§êúëöúÕ≈Vh≈≈YPYíëüßPúZRZ†WP	5@W®q"ªÍDkU#®1VSÅ:2‡FÎqqÅLöSTöbÎgL÷`‹ R3ôÍ
+ÄÃ
+xúª =QfÇ5gfnA~QâBqÂFK{F>(Ø,µ®83?oÛ4FvÕ0◊†`O?«`[ò§^zjI|zfI<îØ°9yá	;TıÊﬂ—Lf)ô…%\
+Pêíü‘$u‡bEπ@1 ©“‹ú«…ƒ–‰ Çã0Ÿ¶xú340031QHŒ/Jç/I-.)÷+®d”/lw\†∑¸EÍ%©`n±Û_ﬁTﬁ6Ñ(Ã,I-J,…/B(>∆¡ƒgM›·À—Â€k'Ì∞Kb˘È  Çˆ"˘Î	«7xú˚¬ºèeBåE‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥¬–¿¿ÃƒD¡71;5-3'ï!ÃzyÛŒ5ˆäﬂ≈ﬁ∆5¶∞]í»∞abAÉH‰‘î ¶±È´≤≠nÆŸ≠’º-¿öo2„ë™ïåw9ﬁpù{’…¿ÅUy¢√“…W‘†&ó•gÊÁÈT2|êìñ=√ıp1«¡z#Ôu≤≈kßôœ lú>N„»_xú˚¬ºèeBåE‹$ÔgπyﬁØﬁ¯zﬂ-ñ™Õa;'≥¬–¿¿ÃƒD¡71;5-3'ï!ÃzyÛŒ5ˆäﬂ≈ﬁ∆5¶∞]í»∞acA £H’J∆ªão8ÜŒΩÍd‡¿™<—aÈ‰+å
+jP Rãä3ÛÛÙ
+*>»IÀû·z∏ò„`Ωë˜:Ÿ‚µ”ÃÁ ≥á3¸ÔÄáTxú˚¬¸Öy¬ëô{yî
+N≈ÏÂ˛~±òŸ^<ˇ◊)÷…,å Êl ´x340031QàèœÃÀ,âè◊+®dàôigπÁÌÇËWA™o YÍ’Ã˛/ó71 ÖÃí‘¢ƒí¸¢bˆîìŸπ˛˛2“©ÎÆô->tﬁ›v¬%àöÇ¢¸äJÜÀ¬ßéqﬁId˙|€pè‹%E◊Oí‚2 iñ)}ÈrxúÀŒû."vF‚„ÂUì¸}Ø÷LÍ¥˝c⁄B ñìéßxú340031QàèœÃÀ,âè◊+®dxÚ@ ÁKrÀíÖºK&s?yŸﬂe» ÎöÎÉ˝\xúK ¥ˇ––êâo∆dA"Íå‹4LØˇ#Ú$’Úë0PÎ4bµÇE+E)ß`ß¸√ıë\`"aŒ©7bV±ôZ Üéÿ;∞πˇ EËÉ¸yxúª2ùqE„Ül÷…kYn˛ ˆúqr<ÎduŒ|ÖúÃ‚…˜9ú7?Â¥fô<ãèkrü…Ê{|Bõ(˛d‹£≤ÇyÚrç£ì¥Y&˜…hr’ó‰dñO‘3ei/–0Io÷˙≈99⁄îsÚìyõEÃà -G„ëÉ‚PxúµX}tT’µ_Áú˚ë…Ã‰;3ë  B"!‹Øπw.!&
+,˘Hî÷¿ìí<à5ê&AB*$±î™TCÃT∑(ü}J±•%êöcQ™Xª®ØU@-Ì√™¡Uk-UbëE·˘‰ù˚1w√[Îıè7ˇÃΩgüè}˜˛Ì˝˚›˚ì3c˘–ò~U¯±¯2∏Ë[D‚ßÇØìÊ¶5ÒÖ¡Ô(ôäÒá¬k÷¸FÉÀ≥?pgÌô@¸¢oÔ¿‘Â
+2∫ø‰‹Ÿ]∞£e∑∑57µØâ>'7ﬁLè/]Ú1{ª=CÖ(/^ú?ºæ§—àã∞^≥÷É¸4*à∑›≠«ˇÒãŒ‰Ç¯ÈûO!≤ñ-Í˙œœ„;øVÔnª)-aégøZ5Öl=Ûñ¯–…ÙÅgV3Ôä„õ¡Åœﬂ¯íl9ôY¡Œ°˚≤Q]0±ù]Ñ ÕáØf!!˛È∏nX0eA¡*†=%Ë◊ƒõ∫µupﬁ›m2⁄ëÔöΩë≤hî&«WÕEÁ¿Mw¢◊È¬•®øÕÒ‰ªó¢Ç∑‹ç
+Ë„À–Ó_Å|0möEﬂYÅhú=â6ÅÙ8™ßmh  ıÁO˚6°Ò"ÕﬂÇv∞Î,⁄@ŸÑ2ùo9só”YO¢CZv"ÅmC=ò≥ŒÇ›Ì®<ﬁyˆE◊”® æxÖ]$œ≤áñlC›Ùç›h∂œpúˇ,*F‹á˜°µhƒ}”O—q2‚>4ÄﬁLﬁœ¶{)ä˙ÈWØ°…ò∂æé«X√¥Íc¥SpV\¯≠ÂúÀMG:v.ﬂ˘πóÅhÿgÔV–∏nyc[{d˛⁄ˆÜˆ¶÷ñ5∑5Æl\ﬁﬁ∏u°y4·∞ªÊfÇß„ÏîyÙ1üFYWè√Æ>4Œ~≈"˝∂àﬂÛcFYdYG˚Ωmç±ªZ”t_cLám‚‰<Sä4µD÷›”–ÚÕ∆íÑÂtŒÖ˜Û•ÿT`\ó@W&ŒÃ˛óe´Ô5Â•ëJ∂[C≥©–”'¯_!∏\àz{nAAS-Îhjoº«‘ÿ∂p$ÄÛ·£\\äL∑áåg'™Ö<XXÃï“jÔCtL.ˆõ	∑Ã(4tr•y¶yµ[Ã≤´ìÀ√≤q≈P_ÅCHÇ›îÑÈ˛Û§¡Àsp:ùSâO!,…P\Ö%À^…\ò∫Ñ\Gègê‹8˜–∂K¯ú@Ÿ¸g|)Í-Kä}vHñÙ´∑l÷ÈDñ^âuÃ˛W_‰jÈÆ˜xVÔ◊„˙Z77—-xs ’w‡)†Ê±„ÀóêQÓÒSÁ·Ã¯Âò@õ„ÒŸÓ4‹
+ˇΩó“é
+¸kD?k∆1ñ£ˆb∫®
+ˇ—Õ´ÒÂHXˆR(Àâ`…≤ìDxÚ6<§EÑ√älÂkHiGd≈Œ^ePÒrf±§’@')Å∂ı$äû‡E®âc>^ys:æè†g%s´<é'±!ëÆ¬Ô ®‹√¢ªÛ	\E¸äÈ$YV%X¯4{¿Ø∂‚)X1!;è«l∞ˆ)¸%VeÀXâ‘dsÖó˝∑Ìxk^@ı‚Æ*Pµàø!$´©qWqWÿ^ãã‡≥*^¥Ô≤;ÿ¶Y˜àt·x8{ ˚≤ ⁄⁄[Vî,kln¸ñ5â•(˛ØÒ∑–©¯<VcˆxúıèÛµtˆœÒãA®ˇ3ˆ”Ωß…jx≥í¯ÈÛ…ù÷$/‚öÏ˘j⁄…ööÍ´iN÷¥ë9–¢PøàåÅ¨Éx¥vr˘∞oÒ¡ÏÉ∏˙”8⁄bä„8íqR§EÀV$"
+g”∏™Y”º≤ù˛ ßCˇΩ¬'O¡ÕÉ=¸:[Í»k˛®‚¶'™Bo9™X©	Aˇb)â™••È˜wWÎ=gÆU∞ëƒ∫il®∆≤µöΩñ≤¸ù Ñ»”‹èh˜yŒG†ªá°˚ÄËÉ?~ã<O≥.qÑ˛v5˘}z Í!4uk*öR–ñÕ©h›´h¶l YH∑ÀXYW–ﬁ§è«:+Ëçd™eIÄ	"ﬂ!£Èéç‰/úU–¢ıπ‚√j‡<~óœ£cøv ®9Nn¢íü˚Q©ó|ò÷U/±∫ñpTW‹ƒÍ© d6+±Ï’'¯"Î1ß)vãúòc7EY7ºÙË0tÇØM…Œü∂.>›FD(}ñÙÎâ*2$7M∫[AÜ]A≥hw1˜*Ü·ﬂ¬€QÑébÖ˛Ú0ôR “%¬—Öœë-Ç≈uth?È%ˆ Ãò¡<~ê‘@Àf>J˚ø‡˛@‡ÚÌºîÔiŸ-9#öÚ¥ÃÊ§≈ÄHó⁄O	;ÂÉD6tª¢(´®Å˝¡ÿC‰ 6™„G¡‘ê∞uÛXÜΩ¸D:ú¡-%t‘r⁄àyµdƒ\lƒîT'bn›«‘d¨aˇn!›rZØüª¡Oœ≤ÄÆº@ûÉ?=Kr`∏éO∑=ÄY{»»÷KYt6˚< ß¯`Q√1›ÉÕíˆÈ±®”WuJúæ
+î\Ô¥);˝__ê©N-ÀÁâ[ÀKŒì,´üÁ˙‹Zfì9œ∞˙eßd»¶‰°Ñº"¶&u…x˛dFà8L”áÛj8nm≈æÚƒÑkî≥"I…r6MªúkÔ¿ÖÑºrÆGÉ}§;Xöü√Ñ%%ER›h(åLÌ“P§∞X6K,`E≤¿RlÖH@6EN¥zÉêkóá"ÈâWq¶v/'óÒm}˛xÔ˜Ì˙xˆM‡J¸íE≤„0Õ"÷lãS•b.›¢˜VúGôú81ﬁŒ,∞Ã~{p&^èÈÆr<ì¿£3π -X¿ıÆißÒÓ’—Ÿ{V¶.&o»óµîGe&…|ãùŸ„Eâ¬.lVwqâ’≈ió±aF œ
+”}’≠ú ÕÎ8‹µ?rm';◊r}ˇÓìqû}%‹¯	Äá_¬AzÛN|A†gπ\_ÿÊ~'A≤È9m∏	R‰TØ;ADq¥ÄÕJ<VT√£aQ''YNÉÕù‹ıÜ”‡˘N.”"ˇP»¡∞¢®I>RÀ3,√–À\"πä‚%WQ]I∏ÔóØøõ£€ÁëJCÄ”‡k‹vø*π	eÚ†ÒWúi…ÖÆãJŸËµ–¨*öŸå$91É≥ò°˘&Z˝sÓ(ûµRÄI!ºÚóK#óLëZﬁîT=0Uu≤¨)Òb&;ÀL!D.rc¨ˇ´îF≤)jå2 «4Nˆ,>ÇôòQNäÏÆ38Cò‚ÿ7“˘ ˝‚Ø€J¬…ü¶$‹—$;˘äñä:ÜıÖëæó>§%;≥õ-ÍÂ@”›ºóœ˚·„1¸~ÕpÉÆ≈Ï*bd1¢!÷=cöÈt◊…~ì+¯ ‰≈ìi˘8˛Î<å≠„}∞l&/ â
+{iÂ$æ
+”í
+~.à&ù7-*ôúMDñ…é%ìÔTÒ„≠ˇk≈“ÊÖ‹2öXß¿L 0B)bˇ‘Rk·®'ÇOb(Q›EøûÚ*cŸÙÎÚÙÎJíS‹¯ÈûBVtÂ Œ¸éÁ˜yÒ˜ﬂ°e0]w_qˆwÒLXØ6ò›ZÔ6V3:á°mÄë∆ì|.-ΩìîÉSùÏrN;ˇ®÷=∆QÙ„(z4Ò):…≤9=÷∞tR)6‰˜èXCæ⁄}8Ÿ…ÛÆ*T’È§Ü];„¨mè%	«Éõ˘l:i#ˇë/`xﬁöï„≤‹XäoÏÏ‰Bÿ0G∞¥ìO6îPﬂ”ô¸ë0Qbí'BXâAo_@ô@¯nuÅK2OÃÎ∆±ÛƒRô'ñ`ûò«<<äY
+ÕUí÷{M®©qç°XíÅbÜU /íÄK∞KÃÑΩø„ß3cnPb6µxo™?A ¸ñœÇØO∆—ﬁÔ	√ÏyõEj‚¸Ü¥†bz.õ.Åò©•l∫bFù`ïˇÖ/ äÈ∞»‡9æ—íøÚ"6¶Coºa_ÿ\“ªóy@•œ¯”Ûí‰ùe8*NïR˚>≥ŸJïî+Sì	mπ∞Uf!√öê«D$ÄY«w¬Æ≠,nôΩ¸÷–íôb⁄Hd1√KÛÖ|zv¶∞g¨€\{Ó™ùFGÔ[%¸áYñ˛ù®ñ¯rUJ âÌTo˜])IÃƒêîœ¸5Ø|~,ôVó=E`ÎSB&ú{FxŒ˙‡˘GTY¢,JK‹n[sTË{{Ö√ÆÉp˘6∞ı°¬ı≤˚∏p,›Ú≤„ˇ¯ﬁ YM¢ 7ñ¢ ﬂDz„á¬+Óal/Åˆ$¸¯üﬂêÑ7]ó\æ{kXˆj@ıâ*€5Pß>ÊØÁío&Œ±G7‡ÿ-‚(»û.H∞m5{õ3]pƒ(QÀ◊Ã'ZlüËª˛lŸ∏‚-ô1hÌÓ:´Ls‡˛#Lß‘≥YAŸ+vÑ√'Ù–\ÒÚ+öS3™ÖncX—E∆‡¡Åû8÷P¢◊ qU—=gkßy"	≥≈ùyp]Z{é¯Jæb&t/£¿RÍáW∂„π‰øäáÆíJ≤6©,RíÚôÏf˚3)K˘‘hÏÕ≥g'Gä!hÎÁ&¬ôÖ‚ı0<áÈÒ~n<¶Ö∑â≈N˙Ä•Øÿ+È0¸3ntÍó7tâ–ü¡œ#`·≤}`’&1õk√Ëâ>≤Ü¶ê Ó≈∂æ<ÙﬂÔ≥·”Í=S‹∑úy”;â@ˇd<∆vâ2ó|òos≈[-”IG}Õb	V<ë®*	ë®*∂H,ÀWSzÖe≤YRUï_.T&Ö,lTØ|Uõäm†Â´©5ÃÏª”8VëLŸ»cˇÚrTıJ‰©∂î,∏z™''ô.Ù*€≈˘»Øπ⁄Q’dz&íÆD^QÙZÍQ’íÍë≠Lû'coä◊¬]∞N<"ñ˝”Ä¨"k1ºımÒπˇ!Y!tŸ&±?˝ˇg˜A÷ÑÁG˛md8ºÂÅ‘'xúªΩêÂ«/ÊúõµπøÆﬂ‹~9ƒvr√evAﬂ“íƒíÃ¸º‚†‘¨‘‰í‘îÕ1o˚X0Ö∑20 B&,¶xú340031QHŒ/Jç/I-.)÷+®d”/lw\†∑¸EÍ%©`n±Û_ﬁTﬁ6Ñ(Ã,I-J,…/B(ﬁ˛m˙ﬁãŸõrèóqj)‹ˆæË∫ ì∏#«ÔÄ©7xú_ †ˇÙêPëw-ΩÈça˜€>ÑW˜&å˙uD±∏~}˜,¸ûËq1ª8äÈÿì‘ #100644 util.py SÉMùË=4æÒ¯ΩCë¥ Ö∫Ó	›g)í‚oxú˚¿¸ÅyBîπ«‚∑3ñjsDÙ\:S‘2ÈàÎtı´&@†êZëò[êìZÃ`¯∂∏ gñ#∑Ã‚}ígüü’?˝°x„ƒxF æÅ‰ÔNxú˚¿¸ÅyBî»É¢¢¸¥√-ˆö∂Ï¨’q…ŸﬂÊæ1Øâ œ¥÷Î+xú; ƒˇ»ê…µÍ‡]≈G±}©˚qﬂ¢¯…&˙ë›`ìeT™pc-+îP„˘Ï´3èOKÈX‹‘ìÕ#ãÌÈÑ⁄^xú€&˙QdÉ„Ê~∆TveeeÖ…_8¸ 'Œ0cgÑÒÉ3	¬à‚ä ”©•xú340031QHÃKÃ©,…L.÷+®dxíù˝∆X˘˘2;¡Ü”å∂¬”÷4ZB‘•‰'«ß&%gÄN}Ó>ÉiûÛû,õ¨/ÒÆ4ÓÏÜ*ÃÃ+I-*NM.…ÃKèœ≤KÚã@z‹õ^¨ÿ'|ÁòŸ;·øoî©ÿÌkáÍ)JMO≠@2~⁄ùÓ+€¶Pìe⁄§pøcæÂWï_?†Jã3srRAäˆ˛»ºzÇıûhÊûy∫ôë±˝=/ .ßVµÏÑºTxúEQ±N√0JU)∞ñQ®-¢(≠òê≤±t`amDˆÖZ$v∞ù∂L+kf˛Å/‡#¯úNÿMho9ﬂΩ˜Ó›…Áøgﬂ€A˚9xnwp≈û‰ö-[s≤€ñBJëO±±Z‘Ñ®è¶‹aÆM<.õä∞r»}cs+î$ÿÑ…î„≤ÃÕí)ƒ´)∫B…&)˙†·=éØ‚∫iøÜ£Ì")i GàΩ•^°U^¶ﬁı»/îFVΩ"!ëK¥[∏.Ö%„˘„bg◊„®;£Tk–ÑRz{ê˛€Y¬äãŒáfÔ|È≠âØÑ,âsâˆ◊”nå€ü!m/FhkX.u._¿§Ûüâ—jùbì∏°–='òftnïvƒô‰∞~ßÿ¨oíZ•Ö}OßìπfÂhòÉ+‡n.¥™pF≥˛GóAp îî1+ï˜Q£ìXÎÅ[xúªƒ˜ñoC=3WebrriniNæﬁ‰:Ê˛Ã‹Ç¸¢Ö‚‘ííÃºÙ‚ÕwôKôt*“ÌÑ«xú{Œﬂ,∞°ûô´219π4∑4'_orsfnA~QâBqjIIf^zÒÊªÃ\,å\ Üî!´xú340031QàèœÃÀ,âè◊+®dp›|á;∑»ªl{ñiuÓ¬◊Î'¸o61 ÖÃí‘¢ƒí¸¢bˆîìŸπ˛˛2“©ÎÆô->tﬁ›v¬%àöÇ¢¸äJÜÀ¬ßéqﬁId˙|€pè‹%E◊Oí‚2 §$*b‰Ä˙exúª }Dz√Ó…˝‹5ÃFzõ•y∂2 Rı‚¶xú340031QHŒ/Jç/I-.)÷+®dòÍ.ﬂ ¬ﬂ6èµÌ}¡"?´∂ÿçfCà¬Ãí‘¢ƒí¸"Ñ‚Ìﬂ¶ÔΩòΩ)ß±Òxßñ¬mÔãÆ€-!…„
+ﬁxú;ÍÚInCÛÊ2ÊF¶…ÛÖ'g∞ÀÄÈ;¨“`˙ÑÔœ°3∏!ÙLI0˝ëW
+L	6'•&ñ§∆'%ñ$gƒóeñ§MÓW„NŒI,.VJÃKOù¨(©∂YM‘ê§â71%%>∑¥$±$3?Ø®TôIdr°† ‰.≈› üN:A·Ä
+xú˚$◊.∞¡îyr"s»d6·…‚¨Ú@⁄qÛV¶…ÔŸ¯&3ÚòL>ƒ#d›¸ë∑ë { ÏΩxúKIMS»H,ŒHŒOI’(÷¥‚R Ç[0+-øH!Y!3O°"ì’06T–≤¥ÚãR4í55‘*‹† ¨¥(µ§¥(OAC§ †¬¬ PUj*Ë"… ~±!&Ôãxú˚¿|ñyB≠àjÏ√ı™'ë˜Èõd~ﬁÒ€!„çm‰Á]ßxú340031QHÃKÃ©,…L.÷+®dxíù˝∆X˘˘2;¡Ü”å∂¬”÷4Zö ÅBf^JjEjJ|J~r|fIjQbI~C”Ôo¢r)ıÊs?/ÿÏ*ºcÉàL9PMqjrIf^:B˝ˆ{LûKfüº€f¯Nn¢,”˝≈sßˇ1Ñ8£(5=µ"æ85±(9‰íiw∫Ølõ˛AMñiì¬˝é˘ñ_U~˝Ä*-ŒÃ-»I)Rÿ˚#ÛÍ	÷{¢ô{ÊÈfF∆ˆÙº k˘Xu™xú340031Q»ÃKO-.—+®d»ªdJ∂∆ÕÎìÿ7æø<G¿°+¨«¢®85±(9§ËÒjØ›ÌÎkWJÒ\±uÒæŸ,∫g >1~ÁÑ◊txú˚+¸Qx€‰H6nµ\ΩÇ“ç‰4[•‘É¥ÃúT%Ö‰B€““ÃÖ≤ƒ[ .Mù«¶ÆRî	ëVR-Ü®é1 ±2Û“ÚïT5JÚ≥u@:57OdÀa —[!!„ä	xúeé1N√0Üá¢b`Ï¬S§™Òb)ÌV7`c´¢b“◊ƒí„lß¥9DvN¿¿YÿπG¿n*‚-~˛˚ˇ˛èã◊Û˜n¿v≤(⁄∫’$˙ó¡√H’YΩW¶tÏÁæs˝Á¿]ÜSH[nYŒ‘˘~yv’5V…Ω|‘ì±õ¿ä–Ep´ú…ÿGèAòòTüfú1á“’“£≠‹¿".B”3⁄î√ö,DîÅ_ÚtûC@k4iÙ8‹B7À;jßÅÆa:ﬂCèÔ»"¯J Éál⁄ˇ+}Çf†X|jï≈’_∑≤n4&ˇÎ«'˝€p‘3ÒûÛS4äç‘¨ cD°…a Ÿ7Q,Å™xú340031Q»ÃKO-.—+®dË	WﬁSˇ∞÷πÿ√èO´<Í„3Ñ(*NM,JŒ )™ΩYì?√ùÈÀÁÄˇom|ÒRËØm" ê∂Â(Ñ€>xúïëøj√0∆óB@Cóº¿a±¡5M∫Ö∫{Üv(›Ç)ä}±U…—…˘3˘2ÊE˙p]ï‰î¥t™ü§Ô~ﬂ›Áx˝~uu:ﬁÜÜ/kÑË@	◊Âv1…NÉõÓ≈Î„ç°PH ï‹2I0ÚoÿœΩ≤™	'cÑ\Á’´AΩ&Î∏pER´Í0Çï“‡Ú“k:À@¨†F∫≥‡.cÃJù”~Fp”ôo⁄h!èJ#òäKP{oÂΩJS9#7≠–XÙÌ+´‡ûØõÉø¯m+
+œù±ïÍ4†CÕïî…íãA9∑ò.zÆ÷\ñHÈ‚Ÿ˝C“jóƒÄæ2Aî≈ ,7J€ksik¬‹YŒœrh£(-Ã!ùNbÅ“>twNùE}fó¶AYÑò‰õ»è…M…π—›ˆW]‘BÂˇßwFg¸ñ€∫_öSùóoÛçsYÉÌîlyÕ∞&¸µû'eßOmm»⁄¥≤Û8y≠√à}tl÷ñ‡íZxúP Øˇê…hmc\ÏH˙Û#yÆ”Ôbë›qááÓDª6pøátgÛgí`üÔ‡pìbWétúÈÖÿL¡kÕ4NÙNxÏ¬6GìÕ#Í1&F´xú340031QàèœÃÀ,âè◊+®dh;Â‡†¯˝ÿ/	πÔ'ﬂ6€z€˜œƒ 2KRãKÚãäÿSNfÁ˙˚ÀHßÆªf∂¯–yw€	ó j
+äÚ+*.ü:∆y'ëÈÛm√=ró]?IäÀ  Ë0+?¶xú340031QHŒ/Jç/I-.)÷+®d∞| æÁ5{dr¸_.ﬂCÍak¥ Bfñ§%ñ‰!oˇ6}Ô≈ÏM9çç«À8µn{_t› jÜ"œkÅ(xú˚¿|ÇyÉ-„‰T∆n ‰1„ïxúc úˇ»&100644 .gitignore /xœ[fQO%ŸØ_=≠ÛﬁÁ™müë&£vBïYµj(ﬂ·´E5rz◊™–ˇë›`ìeTu1
+	/NˆﬁÂ[–`JÏf6ˆDÃìÕ#Ê¬+Ä7xú”“+®LÊ‚ úπ´xú340031QàèœÃÀ,âè◊+®dp›|á;∑»ªl{ñiuÓ¬◊Î'¸o61 ÖÃí‘¢ƒí¸¢b6—:é3koµËWØ∏¡{°b˝åY∑2 j
+äÚ+*.ü:∆y'ëÈÛm√=ró]?IäÀ  ÃÇ+bßxú340031QàèœÃÀ,âè◊+®d8∂‡{Ëó^≠ò5ïú~ó'Xı ÂêÏÑÃWxúªg”`≥!ã}≤á»‰◊Ï2ì_pLŒg∑ﬁlœ!/ ôk	j¶xú340031QHŒ/Jç/I-.)÷+®dòÍ.ﬂ ¬ﬂ6èµÌ}¡"?´∂ÿçfCà¬Ãí‘¢ƒí¸"Ñbûâ«Ñ,RS‰Ω“œÕﬂ∞g”ÆàB ˝$T·Å´Fxúõi{ù{É	Û‰Ã,â≈≈ì∑≤Bº&‹ WràÔ»':âO"∑ü™∫û ∞ÄjìÇäÏµÑ0ÊJô≥Aö,/W c4%®x340031Q–Kœ,…LœÀ/Je–Ø8ùËØ vs}ºÌ⁄œ˜ûØ ùoQÂ„ÈÏÍÏ pwnóe‹—Ω+^sˆùøÊÔ≥#<”†JÇ\]|]ırS¨Â?†n±◊¥eg≠éKŒ˛6w PH≠HÃ-»I-f`QŸ-c{«¸ÏÜ=Èwﬂ‹xq++‘ú‘™¯‚‘í“ΩÇJªEœ“?æ]v>ƒ-äÎÃ˘˚_€ó±%CL*( Ø®d∏,|ÍÁùD¶œ∑˜»]Rt˝$).ïØLLN.Õ-Õ…gpÀ\#…Ê|¸vmXˇä?:üÿ‹˚ÿ?CÌ*J-,Õ,JÕMÕ+)÷+©(aÿô/ÆjÛOl—πw¸“_Ω3ˆNÁÑ©-»’ÕÃ+.IÃ…—-N. ,(—+Œ`p>˘Â›ëÛÓˇeÔŸ
+…∞±˛	’ ÙEIf^z1»#>F
++4WE-~æÎ¨váÒ¡£:j  û][*·QÏ«Ú2U`CZÙûˆã,Äx¶$µ∏§ò°‘∞ûãSﬂÔ€Ωß—ºﬁ§ô}s95£¥$3dMp≥Ô‹∂&˚> ˇÿÎ<qãBÎÆwú ¡¬¬•xú340031QHÃKÃ©,…L.÷+®dxíù˝∆X˘˘2;¡Ü”å∂¬”÷4ZB‘•‰'«ß&%gÄ∆O0˘⁄cµiRê˚r.≈«˜úû]UòôWíZTúö\íôóü	d'ñ‰ÅÙ»=‹^ÒÌÁÀI.›˜ŸN•›í`ˇp≤™ß(5=µ…x∑»"ÌÉvøπøØ˛„#∑FH˝t|Ò®“‚Ã‹ÇúTê¢º€ÎµK¬è~12Z»ú”∏lıßﬂ*ô Ø9Vt‡Ñÿ|xúk‰∆∑°ûyrs¬Ê_ÃÌÃ 8oq´xú340031QàèœÃÀ,âè◊+®d∏1{≈≈xU'õ9?uæËøPˇzs”ƒ-&@†êYíZîXí_TÃp7&œîWV·¬YﬂìQu{πøãW9œ iÉ‰Äˆxú{iw¬n√~Ê…ßò&en⁄‹ƒÚ\
+ i*	gßxú340031QàèœÃÀ,âè◊+®d¯ì¸üIPXﬁÈﬂæù!_^<∂‡ik 
+4èláxúk∞˘jΩAãy≥)Ûi) !	ökòHxú;"›-Ω·8◊&Ó#L _äÔÖtxú{¡¸ÇyBîHü”çz≠≠´&·üÎ§∫¶äÛÿ—9•Û™Â∂QÏü@xú˚(rócC3£,ó≤≤Bhqbz™ÇkEbnANj1WPiûBIFjqÍ‰GÏ⁄°~˘%© ÆB*TÅBbqqin™H∞†(ø¢R°8µ®,µH!≥X°®4//3/]!?O!ƒ9@° ø®D¡‘¿¿“L!?M!'?91'#ø∏Ñkr£Ÿd~±ÕÑ€0m‰ÄxúªÀÒñc√BFé‰¸‹‹ƒºî‚…µ'À3˘Üïe*ßñîdÊ•ÎT*(+$g$Ê•ß*îd§ß¬•JÚrKí3*ÛKã
+äÚ+*<¸ÉCÙ¸ÉBÄ&*ÑªÈ8á˚πlNg˙∆ ¨å)Âà(xú{¡|êyBî˘/Œc[}òﬁ}—\=qNDÊÙ˙3cMÄ@!µ"1∑ 'µò¡À!…jÅN˜™√JœÍû^?í(∞L}‚ƒÀìªcBW0•xú340031QHÃKÃ©,…L.÷+®dÿ≥Ø≠ÛxÛƒkQ€yoí|˜™≠#ÒÉ!D]J~r|qjbQrHa@ˇÑy”Ásxo)W¥-_wqÜa˘g®¬Ãºí‘¢‚‘‰íÃºÙ¯L ;±$ø§GTkbäˇıÔÎ÷m◊Â›øLÓËäSP=E©È©H∆:Ïà|X+¸Ÿm_Û˘Ã†Ÿ≥¯f@ïgÊ‰§Ç…ûÎ‰≤ûÙËﬂ„äÔìnÑ/|ÚjRö
+ kûY%l°dxúªƒ˜áw√{ÊÕÆ,ºÃ %¢òlÑÁxú{Œ?ë√{ÊÕÆ,ãò#∑⁄·Ñﬂgxúk‰ü¿∑°ûyrsÇ@r~^ûÇ≠ÇcrriniNæ∆ÊEf æT
+∏lÑ›uxúõÀ{úgCÛÊKÃßô !á‡Ç	xú;»|êyC£àÈõDÜ	:°´^Æ7÷∑®l˘Pi¶6πé— —è‰ûHxú;"›.ΩAÅKƒJ_?=≥$£4I/9?W?´ƒÃ»–p≤9◊ÑM‹áô ◊úµÔ]xú ‡ˇ¡¡êZßDO˘`=–œÃ∂L[ØYÎÉí‡±4±nSB_ÈÖxúªÀqÄmBœƒAìı36g0}adS .. ÑR*ÔÄ.xú;»|êyBî»ˆö∂s∫Ûôf7[v=Ãpøı«e√∆º`F ⁄3fPxú;¿÷«8° çt™xú340031Q»ÃKO-.—+®d`yù*pzÀì
+˚Ú≠¨jBÔﬁ˙˜˝1Ñ(*NM,JŒ )íR˚~U<≤†S#oÍ°˚ª ˆŸ˚ ‡GËönxú˚(¸[x√AfŒ‘äƒ‹Çú‘bΩÕôÿπ Ç@’Êö-xúõ«≥úg√AfŒ‘äƒ‹Çú‘bΩÕôcô b,>™xú340031Q»ÃKO-.—+®dõ¯‚«≥UyèÀ≤£|ÏÔÎÛù+>eQTúöXîúR§ÿÁô}¯ÛeÀﬂ◊6ù_¸|—õ•O.  I!x·úxú˚(‹.≤· 3gjEbnANj±ﬁÊÉÃéLZ••ô)ö\
+@ê´WPZ¢ëúf´î™§£ê\h´§ slÅ∏4UìkÚN6È…Xe'[≤)Úî‰gÉ’Ä¥oneÀaf‰ ´Ïúxúué1N1EÖ¢Xà3ÆlieAã¥P”P§çV»ÒNÇ%3^<^†„°Œê8AÓ@ÕYX{iôfûÊè˛ˇá≥èÛœ„‚ﬂÏ”êÕ◊qÒs"∆—˜-¨ª˝ayqÀŒR≤¥Cn◊´≤ß¯⁄Jñ`•,u◊Äœòléizª£â]ˆ¥€/Øﬁ´•±√Ä‘+4ÓY·∑êTï4‹¿ÂµÄi∂1AxâÃ∆f˜¯PJ®l7¯ßP1˙kTPWßB‡WTÅ;=gîíß\íÃã„¨Õwy!!è!Û‰3R/Ö®u\àåJã_B3k0ÊÑÊQxúk‰Ô‚ﬂpêô3µ"1∑ 'µXoÛAÊÃ ^©nøxúUäM
+Ä ˜û‚[≈≥å6¥Ì·∂Q–èüiAÕj`FiªE+Ω“˘Ãê±X ä ±;ƒZﬁJ„Ä6[IŒ—@§ı°¨Agp ∫/ë&Q˘ü˝ß1v¡!:±‰xÕ\[S€H~ÁWÙ*ò-èò⁄á…ñvŸp…`3©)6•íÂTcKé$ú‘¸˜˝Œiµ‘›íå!fvx _ZÁ|Á;óÓ>jÒÍoØóyˆz'ØeÚE,V≈]öÏºßq$ì\NEëä‚Nä·"ågîﬁ˜a&≈q∫L¶aßâËG«{oe&“Dä4Û4ì•Ië≈ìeÅèfJ†o3)Á2)r_àëî,˝¸b|rx$n‚ô”8WA˘}\‹ANqÁ‚>Õ~7êNß1)g"N¡\¡»‰mòM„‰j´,æΩ+Dzü»,øã>§å…å—±Fí+±¨F˛ñ.KsK˙‚Wà![¸7ê‘£!^˘•∑˜O±¬≈Ûp%í¥Àúl`ñ,"π( ®ÊãY&ë¨ÕíögpA HF:)BŸëﬁ0A•.;Ø Ä~ÓäbÒˆıÎ˚˚{?dÁ¯iv˚∫§9}
+BœGG?0b\rïÃdûãL~^∆®ù¨D∏ †(úÄÙYxO~cÁ∞œÅ‡>Õ…m_‰•”!≈téÚ8Q°—¡hs ¯
+·G‚d‰âw√—…®O∆ˇæ∏ãè√ÀÀ·˘¯‰h$..≈·≈˘œ'„ìãsº;√Ûﬂƒ˚ìÛü˚B"XÚaë~ÄåâG9%óÍ¯— (<PæêQ|G∞+π]Ü∑R‹¶_dñPt,d6èsÚfxSHô≈Û∏‡  ç(e˙;;PòfplÖÃãÍÉ≈*å¢Â|9Kwn≤té‰—Ô	#]Úwı≈<ç~◊ù·µ;‹_dÈ√ /ä’BÊz‡I!≥ô3B8Àæ¯fEŒﬁÀU_åVy!Á*C˙bL^¨?ÿŸŸâf!Ëñ «¿›”¯ÙÓ0ÃÂﬁ€ä§©º¡≠,¬ iQÇır9ª)«–8˙F*ô==tpŒ åeÈq~%Üì¡=ÁÀYzã  áËÖW]ô…bôQ™$…Nç8gxy&–9[Œì‹≈FP}X,≥‚ËÛxzÁ®E}√'~S∆ıßΩXS¬µA„!+ÏAÔq8èg´Å›x}`ú˝=à2ô·£œﬁû¯Ùò:q≠Æ•·ü∂™1—
+5|2¨>@Ü
+ùÌÅõt6KÔëAAòe·Íqx‰∏ˇæWub¯Æ‰≠uC√ëÆ 	6‹¶ë††¥hƒJ«Ï÷∏ØÉÇÜñ°ÏìDŒ≥º#™U»„|œ¡óp∂î∏(óEÔ⁄+ˆAâWÔΩO%r î8c•&˛«îÅD·l&ßÕöΩ2µÍKõÒ›8Ö8µIe>˘ &∂≈*ã<bâÎi5∫ºé≥•TH-ºﬁ|≈ÔΩö”Ω¶|UH⁄¯ÑÁöbö‘¢>π≥Aaî…∞ê*2›zf`*ëcû»€Îmô∆¿ı*^L§-Võ‰ôí7"SS4éÁråiœ?;9==ÌëÈ«	º©ú…-≥¶DÆcÕR˙Ü¥5ŸhEèùZôL¬˘v„Bâ\g°•¥≤(yœ˘–ë+Ü‰Õ¨µE⁄ñ” #√:Mv§É^√tÆ7≤f·»¸"UB◊}Á&Å˜∞˙Íµû&»¨.µñ6ÍqÕ˙¿ötÅPoUCœnÃçkäR”£*54ÇVs’íâ!wïÍø±yÔ:√\H&–œÛπΩfr±´9aÅı‹Z≥´ñâµ÷'–K€£'ále_›∏Ís{‹`æ‘õíFQ/GE≥õÕÍ€J∏Yæ'a›∂:sY2P_ãË%ô•ˆûóΩŸwÀ _”3
+Æ1$tÈoÀíJHÌÑ“:ãÉ∂KØ°’àòÚ2&•mxc*¶˝Ñ[sòΩúπG1∏·`Ï.©%l8új¬à7zñ]¥·~r∫V~G¿√sÃ>áxSÚ≥ã	v®ˆﬂXó7R
+›ù%•cChµÁULÙhJx1‚Øééfäv_µÆ4îø√éXã*5'¥T_dqä\_ˆ±Ì£mµÇ=ñ%GªÊê‰v£˝›æ`±ª	Ω8DRÀ|Ìè=◊Z‡õ3¡eÁÿÊqØ	wcœNïOD√^è∫Uh–h(HrˆR5Åp&=’—§ê~XiÅ˘'ÁNHU§‘∑Ó˜ÿcY•Ã•p‘`ãVóv$<…©Ï	ãMÃ«Bò„ã”«má8 Eµí™ßÆ∆⁄¢Wß6æ’GçØR$ßéeÚ∑j0}‚üˇsÿØ®œNŒüçáÁT“ò-◊Ù™ÍˆŸ˝∂~¨{K€˜T?«XÊv…∑#-ìsÙÁ∂Ì%UsÿÙÃÏbLel=ø6ﬁM˘µÂ⁄º÷ùíﬂe£cCÅR6âw\çëË=ˆ≤Ù~‡Ö·dE∞ÊÒ¶òÜe `÷;÷›$ÌkMb„Üv£˛ﬂ(0÷çqfü‘øº¯^úœËœ/W√S˙˚+vôè¢j#zü*ûπU˚aÓJˆ|ˇD¢ç÷Ëpq«6|‡íé"Ωâkô«⁄/g·√ezﬂÍrª4VÇ–ãq|Ω	≈˘pY‹ÂÙÒóõ^Ù‚¿√“<Ø‚àr"N¢Ÿr*™% ˘ª…$Òù‘ﬂu˜ò}hW∞€º÷Ví⁄qPC°¬‡ïÍ≠*ä]Iåù{÷Ú5¿ùÜ‡f∂ÃÔ∂‰™Âwﬂ‰0ôìPÌØ:∞±4¶‰∫^∆S“zXJ‘ü∞ç{üÏdËÇm∏ïd◊öÃ ≤QmÍéoªÑm˜≠∏FdÏ*~˝á£cdµmQ4ùö´∆m†$ôôÌÎ≤©á[Ÿw˚óªnß)zπW◊Ù¨≤DıÊX°GøπÌ]póv€.µ∫ï‰ıﬁiëiõ<≈
+5`˝î∆äìıSk…´∞uX]ÎT6∑€iI⁄¿JwŸÀùw≤¨k#ˆT”H`ee%ﬂ≥&ºk6àk$iFç¨mc(∏äoÄ´Gò¡m+[c~}y£™±F∫D/lPv`« 1Pa«&È´∫ã˙›9¿˜˝Ëé∫ÇW¿0¥ƒkkòÄ.0:?öUﬂ†Û§CÌ.ë|Dí∞MâÕÕï4¯e8ÉÙn¬úêsßÂö˙¶j%t.££æ √Vè3hvöa…®6¢€Œ"»˘.yÄ}tyøKayK“›[1…c[êTôÂ Ò/èÜ„£`<|wz‘Amõ˛M®Ì78⁄Ï@Õ‰óÙwŸûÛ˝_âwÌÔ‡±K7ë?_^|ÆFGóÌ,∂´&çÜ.õ√ª01!ªã=+—iE[s@à(%ÙÑ“é∞õ÷—o£Ò—Y-œL˙Dœ$‘’b‘2ßß≠pÁnïo|ÎÍÖüoß}®jJGºv‡®h5V”é@ˇ›’È˚‡‰Ï√≈Â∏ùeñÌ^•6ôw¨i∫·i\ﬂ∫n≤µ⁄1\Êﬁë™§;Êt∞⁄ÖdZ9E◊T’VõEÔgöZmV)Ç_àRàÓ‡”™ŒﬁVßîY 7a˙_t™Ø=tõ»æõaGõQ(ÿæŒJAª…	∑vêG,Ø#xÖF¿`ΩHmÙË7öj∆¬ﬂ,≠ïÙıÑ’	ﬁ&ÿé@8mãÛ¶€§·∞™©∞‚Œûèùè“QgÉ2o1z8ﬁ™O∫ÜÂ±F_>Ñ8*s?ßS°“7ÏÒ—“˝ÄQ¸’Ï\9ƒ÷x€»e“t3ø≠õ¥E`FÙÚ4Wí„Œrº	4L›“¬ñƒ÷\¥oTøy∏ÌıV‡Nò–ªK£ÉIª≥Å¥
+˝ˆ·@hÛG”µ(É?’o5HÍã6ÏvJîÌ˚˙™-1´‰÷‹Íº®ëCeÇ„(|ƒP_—’˚Œ‡r∑Íäﬁå2Wûæ§]6	^{@òèîËC5öñ*7®O≈rz‹ŸUgR∏ëkﬂqŒp {`úÌ0ªæ”'xqâü8˝\€ø~h∫(ÛÖí÷∆á–UÊsˆÊ¿hï=	⁄{}+ÑG‡˛Ï& çã®°Ø/Î \ÉÏnÉ?4DªÍ–ìyFÉﬁY2<W˚æi={∂+êJÂ—ª&,+Í„Ìx—πõÖNÑfËëÿ3›
+Ä÷=±M¸l1]öGüÈ\yßÕ†Bçx!ÛŸÎà˚ñ(QYíˇöËÓÎóNáQ—´Ø[…«Á‰1˜ÈÄÚ≥_„<ûƒXt‚)¿ÿJÑµh££Â@`j˚˙`Ê\G≈˘˛H≈E>ÿÛÛ,˛Ø§8_åŸcæP†V^ÿÎïSÙÈÛ4á¥÷@∑L√˜Nü]∂UX’è¡4Î∏^'7gËµUÚπD<°F˛?ËiIÕÌQ÷,2Oú‘ü5’¥•Û_Ö⁄f’{XôUÔ{ÊÒW∂VŸ?'í7®±!ß‘eßü”üXÇÈ¯¶;+:˛ROMÍ∂¡fõ"á‡€ûzS§k µÿµ$ú¢NÔ◊›‹ À}1˜1t›^áNIÃ}u‘Çû/"}’«≈≤¯Né¯ üD◊5£^ùVk*=·£ù3¿∆åÂUsF∏>‰'+Ø¯$ã˝|ÂÊK®æ®£kˇ<Ãœ⁄iı}C Ÿl¿;—Ó»¬r+¸éÀ§É˝ŸfæèÒL∞À7mÂ·˙Œ£–öQﬁÚ´]<EJÀc≤˙Ü4ˆP∞ÙH´£Ê©£Ôf|±p˜1€jó5Å√Vêü$˙:È12‚è_†ÏÕqƒlé∆D∂¬™è'™ôD´`û~ƒ[b?]‚—·|ºª‘)ÄÕ
+uNFY≤i£BçæX–…yhŒ`Œ,,xgC1⁄Ø~†ü˙√eFiÇÎú¯ı„”ï»~}IŸT†‡-≥gﬂŒ£á˜’ÏÌN¨G<zêR+lÇjÂJ;ù[¥O«˘)[ZsÃW‚ﬂéÂ0ı¿πéf“ö1’'∆¨n∏ÕûÇ ‰;âÎËô+ëœ„⁄©=ÙmtB¢∫ÛﬁßJ[“ŸÁì~⁄»⁄±ıÖ—Ù2]Õ≠E€ÙgõÚàé“´¨iÉ¿_w@0.}àVlîuÓX#Y‚<`9S.GüæˇÇk¨¿?åHpäT«ä%ı}¸ø=Ïâè9ÿ¢Rj;≤‹`{æTuƒ∞àj÷V>!.çs-è"©À[«© F4oÙ≥≥C Á∏Û”+UVˇB}àˇrÅˇ
+–3)A ±ÙMÏ™ˇQ˚Ÿë'LÁ3úqxú;ÿ√8a„~€…≈≈xäR”2+4äSs“4≠&3≤ä(y˚ÂÁ•j%Ê•ßÍ•ÂÁ‰‰ógÊ•C’©´kjrÅî©·WSëñU*ÂÈ((‡Vú
+S\‰ôòÄ4ÄDc*,‘u∏ê N3PtôCŸ`GÄıß§¶)î§óƒ ˚ntëÇ-ÿhÓTΩòW'OTˆ,ˆÃ+.IÃKN’(“Åÿ>˘°ëó:–CEz≈E˘Â e¸!E•@z≈ôy…9•)© 1}hÈ•UAùÅl¬*∞KÒY«CjZôJÿ T¸V¢∫,™ÃÕ-1ßÏ®:¡s¯ßÑ[!KaIaHé¬t¸f^[N M
+hΩ◊xΩZ˚o«˛ù≈ñA ≤•Or⁄®
+êUmÀ©H«‹Ä8ó‚’«;˙ˆ(â	Úø˜õô}›ëîc'© õ‰>ÊÒÌºvÓæ¯√Ò∆‘«7yy¨À;µﬁ6À™Ï}°^Êô.çû´¶RÕR´≥uö·cR-ö˚¥÷Í¢⁄îÛ¥…´RŒ&CÖü∫VU©UU´UUk…™≤©ÛõMÉ°B™Ù∂÷z•À∆$JM¥fÍWØßóÁœ’"/¥öÁF6Å˘}ﬁ,AßYÊF›Wı{µ •t>œâqZ®ºƒ¿Jƒ®ımZœÛÚl◊€:ø]6™∫/umñ˘:ï)©1πpí!À<°‰˜’∆Í©kQ©Ô@Üt˝*9•-È€…˛ÔjãÕ´t´ ™QC:A`¶¨2Ωn (§Z≠ã<-3‘“g`AçÍ¶I±<e5Tµ`Ä,/ï6Ω/  ˝-õf}z||ü§|8IUﬂ[òÕÒK z5y˛Ñ%∆ñ7e°çQµ˛∞…k@{≥UÈeÈ@/“{:7>>sHp_ÊÚv§å=tPâGNú†p“AÈxJK’?õ®ÀI_=;õ\NF†Òˆr˙œ◊o¶ÍÌŸııŸ’ÙÚ˘DΩæVÁØØæπú^ææ¬ØuvıΩzqyıÕHiò K?¨kíBÊÑ£û”ë:˚qêyê@f≠≥|ëg–´º›§∑Z›Vw∫.…:÷∫^ÂÜN”@º9®˘*oÿàLdñf“Î-Íj≤uæ¿AÆ÷U›¿ñËW<ì4uZûtk&Uˆ^l—‘mk[◊USe,‹Ú;áı§YÛ≠∑B≠∑iñmVõ¢J∞„aÎñüŸQ,ÿ
+·Ó“§i∂km‹éIññÁU±Yï#%üo÷o=R4ÛzMgFÍÖﬁé‘≥¥…ñ≠·iæ“Sê©∑0]˚ıó¯ë¬˝'∫![ÍYucµÇﬁÖŒò£ØLWzﬁl÷Öﬁ—Ü¯Ø ≥‘h«∑◊;◊E°∆*Ùi®?R˝∫∫WŸBeTvß£Ó“¢?ÏıÊz°f∑∫ôh>É0 ≈iÜß=Ú<;™Wàw<îÉ»|{ÕªxíybôDÉx5Mö√1Ü~õÃ&ÿyëÆÚbãu¯˛Ó$+˛ΩIX><F=˝AA∂Bó§¿P˝C=U∫@ÑÚí”V˙√4ÈâX≤÷Â|`2·_ÎfSS‚YgÅÛ©Óqú≥¥Æ”Ì ∏Yd¿
+?
+v7∆˛‘ˇœIü5"ˆ;+XF>Ø∑¸≥§˚}Ÿ~ÕQ÷
+≥0XFK.~/œÊÂz”ö'Í61Gv‚â•w)V¡yH≤«ÇÚÜED u1’˚WÜîñ¿#“Ñ}`±)ŸBOæMÎ&O|Uk|OÒ5]ë ß^j$úm˜Í93=∞N˘±+Sä6]ÂDqØÔt– }ÏL8£i“’Z!SF"p‚Ì%O∆Í©=ªG˝]nÚõº»¿{àD{Ÿ8‡`çÇÿ¥÷÷…Rb.ÿÍc\¬™ÉL¸í]÷cc‡ù õO[ôÔê¶ÿqê(MÓ3B»zPÍı≤"Ef{µë4®n˛ãËgÕûÉ—,/Ûf6],FähÑ„4$¥Å€ådç5√dÊ∂7rpöHD2¸œgÓá7ÎÑF¥‚)‚˜±,≥≈¯ËhÑH)wc2©b¶˝Áô‹ÃÊ∫–çÊÒXJbnπ∏sŒ1E“E'¡yúA≈ÿ8∆ŸF9ŒÓ¿€Y˘∏A^Ç =∆ˇ#%På{qÜÎÇÚ5
+˝Qà=:Ñˇ`fï5@CÙ7 ƒ}sòä…À¨ÿÃıxZoÙhó§$µ'©=Iù9í⁄ì‘1I¿Îâä∞r{L ,£c Up“Ù—ô@2ƒx∂Ë‡·›·;æÎ#ëÇHc:√Vrö≥_#ÈI,Ç≥Ù—ﬁ
+phº+ê‚·éXÄçá;bCÓäÂ •πñXdˇM5Cqsaü
+.GπïÀ-[C%bT¡’ÍÒ∑n.È¸M~ß±ûΩœkÓ¨äVÎùumQh1Ç¶P :Aö±º¿‚¶«~!ªçı*‹Ò-;º„avºÂg2÷ò†ßïåråLZ€∂•A±o`•oìÙ«Ô¥&õh”‡∫J”∫•a8ùÄ¬≤¬|∫a≈éÔ*≥iKË{T·jwı≠÷ÅòW’ÊÉ∫ÁŸRM∑√≤˝º ËéåÀUî—JW	Ï…∏ã£¥oË∂7¬=Ûa∂“∏•o«OO˛¯Ù‰´øåpUjtômg+3˛3çùúHê≠6ç}ÌÜñµNÁ˚‚ŒI(dO"3†?FeuY˙»];m˘ZñIÜ´^Ÿ$ò6⁄¬($EuõµZóèî|%:uΩöØÃ8(Ï≈(ÂQ£VW˚â,"*8%ê_≤¢¢ r¨.R‘µ“ééé‘jÉÄÛµ\Åv›‚]Ü∆˝û“ªQX≈‰Ë¨–“òaá‹AmŒ%
+ƒŒ‰fûi«#“e˝sn7‡ÆÜ[NZíc2ú‘≈ACAdÄÈ¶„¥…ê,)<˛Ù≥"√ÇtU!A⁄ºx}btŸ”M—∞ÑJã áa¢`Hs≥øãù∫;YY¬:'3~IY-öÊ´çTÎÇ·AÇø/Äø» ≠ΩÓ’Í'”)AÍ™°ü≠öd§ãe7€|Ó¡3±=ß~XË¿ﬁùD$OW∂]≈yô¯aÎLª&‡≠fGıë{Æs±Û˜2îõWèÑ∫eeöqø®≤¥†Ø∏ÍS[f¸ı……ﬂ˛:¢˛\=>™´™AEªFÂç∆‚||d4bqhÇárŸŸèîXéˇ«\ËA?ﬂ„I¶∏
+ÍπL•Iîÿœ	,Úv£*i	Å`ßîtz/C|±Q Ôîahìsµ≤’1ãÇÏ–A”élûWR°–m^P}«°Lyπu–âå‘OGÓ0épcñcâù„∞ﬁ≤&≤Zäæ3Nz¶kª6„æk8âr§kâÜùS ñ≤QƒF∑#¶:”X'KlvçL∆≤à…ÚÆÁaS+ÉEÇK¬—YÚ]Í1YYŒÚ ∂#ﬂ@îÎ“%Ø._æºúD‹‰ŒÙãπ…Ú‹"≤µ¶∂[ãlUÃÇë*ı=ãä5íΩª<ˆêDFîÛGJùù4JYé5:öÒîßpÅ$CR?ò;&;”‹zå$• JaœÔË”⁄KÛÜŒÖÀÏÜZ¶6ΩDmüjeC“ÆXÏÓíÛÊ6e∏£ (°e…ø#Y)Å∏·∂Á:˚t≥âøÒÑà—n◊ëÇv]|ÚAÁûg∑äq‹:EÖÛGø/íÜ]‘OPQ‚ zä˛>ET◊5û°ä°Œ¥ì⁄çwÑfõqçÊ”¬€√ÚŒ∏à†XÃ¡A>d-ríﬁîŸŒÚá/ngdûDi§.≠h∂Õ≠&È,≤¥4¬
+f±C'nù&íPs‹©‡ åB˛ûs8PúZç=ßÍK”ˇíHGQÑé∫Ì”˛m˜Ì"◊âJ7Õ“}w"∫ﬂ7õÖ…îﬁ‘-a∏$ˇn]e*y‘ˇùÄØ}ê1`≤íÛì`ÍËí;wC›∞ˇëAº…	‰037bÜHƒÆG‘Ò¸“áí¯*D¬an_∞∑:ŒÕ)£Yà“~≈œ6X|â∞à`óêE2 ﬂ¡˙—/7+wüíûŸG‡YÁ9”ÅSÄÎ∫c ı9AÑèÖÛ˜=èˆ…qd∞R≈Á¸˝íû¶SÊcÆl‹§#É∞ïXâ[€ãΩ·‚}“≠PS √≥X"íÿœ6ZπÕu1W‘ÖËÑûıPæ˙^/ûÓÚ\‹Óç∆B«◊˙¶/pœ7ëmƒ¡çB∂ìﬁGÿï1.78µNúS…g†M$ÈØÊ86°ûG\\¥ô-ˇGà-€ƒw$±∑Ω'¥"~õŒãım∂¡∑‹99ƒœ∑>–ÕÒ˘.mQ◊´bkBúõÀç∂p£∆1«ˇQäà±îù◊nc´ƒE8€C˘ê6ﬁ/ÒI•≠ÉM—T›‡rgÊò´êês©ˆ∆.ù¿æFüËN`ÔbÙG¯ç«¯Ô
+¥ªÑí˜·5tA≈cƒ`∫q(∑ûã¥s·»“ÛRª'–¶ºDf‹€∏∆πíN≈=À∞MM˚ì⁄}çg>*’´Ù·⁄≤ÏòÄÀ¶†P-Q1)¸oG©®UœP§œB´¬ﬁãv
+}◊ ∑=õœ©ZóˆöÙ¬ÿñ˘E4˚¯±l©—«CüL\òØ´¥§wGR©leü¯@≥∞'™®®ÇˇÓ$?˝˝ü{t÷∏§èuVŒ/|k™sñq´.äÄtß∑÷&◊{w•èÃ&ˆ^A˝%ılﬁ∏≠éSá@∞Ïy]≠gNË”“√‘#[„é—î®ë€„{¥ÿSï"tDQáeúë’Wu˛c´À+∫±CD¨Z»,È‘Ht∂K†ëê	¯êÁÉ√¨#û{‘√˛_¿7“ıwOº7≥5ç^Õ¬ãVmC¿˚W€XUﬁ>·›ﬂ˙∑¥xs[O¢q≠ı]ı^>[ŸˇÈ|ó©˘4¶{ çOg,0s;Ñ≤Õ’åTH;`O©√ı(÷1°`YÚ_)ÇP˘\˛œ`ˇ!|ÆîöﬁGl˜ ë’xÏÄùc”$Ïq∂Õ∫¯ùkbÅ'&x‚á˜B›v1ø‘0£.[ƒjèÜ†qﬁ&—·
+ú9÷≠:q~¥30å#£Îc.∂¯
+|⁄UJèX∆©◊æ_≈à‡+~üïÒy⁄.Ñ‰=¨[· wÉãvJÔ«“˚nÚ~lW}O0Êªîhr˛8–~vÿ˚[m≤√ë‚“àÒ/zçæVÿ$5∫WÜ¬4
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/packed-refs pyaccumulo-new/.git/packed-refs
--- pyaccumulo/.git/packed-refs	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/packed-refs	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1,22 @@
+# pack-refs with: peeled fully-peeled 
+aa1f78f490dfcf43c32671136edab844aca4eac7 refs/remotes/origin/1.4
+27c522a03e4ff1cd3430e774465b4ba8ade6096e refs/remotes/origin/develop
+8adcf535bb82ba69c749efce785c9efc487e85de refs/remotes/origin/master
+02f8e16e4d1650322a576c34148da820c90b6ea8 refs/tags/1.5.0-SNAPSHOT.1
+^e710ff1e9064363439b75e38f29421774a7a4049
+2ab822d935da545ac6a179462ce375021d973d71 refs/tags/1.5.0.2
+^e710ff1e9064363439b75e38f29421774a7a4049
+cde92f6ec4570acf88bbe9bb256de829513a096a refs/tags/1.5.0.3
+^b402af3da4f2ecb5adcc8d68334ec29926cdba18
+8aa71d80a1366f3b46bc061c3e3c04c48d564415 refs/tags/1.5.0.4
+^89a4d86a35f1582c85bfeb451d17466fbd2310d5
+c49da29aeb9814ab4121206cbc01a67a29cf442d refs/tags/1.5.0.5
+^df1afe9add5dcacb0d547fd36b00e9719c717f91
+3cb729d1c506424d560c1b65dc6974dc85967043 refs/tags/1.5.0.6
+^5217012ae5b55e6c715dc92464482ad3fca88b4c
+aba618556b21d16b4a370837f89a43a6d462b2b6 refs/tags/1.5.0.7
+^a2c85b8d635e34e2f1a7c8ac874e83d53abe0bff
+3625b4a432db962ba0d8bb0fa04278f549ad9b65 refs/tags/1.5.0.8
+^0bbfd8a55bb2aa082c315f38a6affd8ecd94b9a0
+6d5c5bcbb7c2316e6a5fceea75c4e9cef9a1f267 refs/tags/1.5.0.9
+^a75dc75e0e31e5242084c972860c022920464206
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/refs/heads/master pyaccumulo-new/.git/refs/heads/master
--- pyaccumulo/.git/refs/heads/master	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/refs/heads/master	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1 @@
+8adcf535bb82ba69c749efce785c9efc487e85de
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/.git/refs/remotes/origin/HEAD pyaccumulo-new/.git/refs/remotes/origin/HEAD
--- pyaccumulo/.git/refs/remotes/origin/HEAD	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/.git/refs/remotes/origin/HEAD	2017-03-15 22:26:09.678584651 +0000
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/__init__.py pyaccumulo-new/pyaccumulo/__init__.py
--- pyaccumulo/pyaccumulo/__init__.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/__init__.py	2017-03-15 23:32:47.887403005 +0000
@@ -26,6 +26,8 @@
 from collections import namedtuple
 from pyaccumulo.iterators import BaseIterator
 
+from array import array
+
 Cell = namedtuple("Cell", "row cf cq cv ts val")
 
 def _get_scan_columns(cols):
@@ -52,6 +54,7 @@
     :param key: the key to be followed
     :return: a key that immediately follows the input key
     """
+    #import pdb; pdb.set_trace()
     if key.timestamp is not None:
         key.timestamp -= 1
     elif key.colVisibility is not None:
@@ -94,6 +97,27 @@
         self.ets = ets
         self.einclude = einclude
 
+    @staticmethod
+    def followingPrefix(prefix):
+        """Returns a String that sorts just after all Strings beginning with a prefix"""
+        prefixBytes = array('B', prefix)
+
+        changeIndex = len(prefixBytes) - 1
+        while (changeIndex >= 0 and prefixBytes[changeIndex] == 0xff ):
+            changeIndex = changeIndex - 1;
+        if(changeIndex < 0):
+            return None
+        newBytes = array('B', prefix[0:changeIndex + 1])
+        newBytes[changeIndex] = newBytes[changeIndex] + 1
+        return newBytes.tostring()
+
+    @staticmethod
+    def prefix(rowPrefix):
+        """Returns a Range that covers all rows beginning with a prefix"""
+        fp = Range.followingPrefix(rowPrefix)
+        return Range(srow=rowPrefix, sinclude=True, erow=fp, einclude=False)
+
+
     def to_range(self):
         r = proxy.ttypes.Range()
         r.startInclusive = self.sinclude
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/iterators/__init__.py pyaccumulo-new/pyaccumulo/iterators/__init__.py
--- pyaccumulo/pyaccumulo/iterators/__init__.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/iterators/__init__.py	2017-03-15 22:32:50.690584651 +0000
@@ -15,6 +15,8 @@
 # limitations under the License.
 
 from pyaccumulo.proxy.ttypes import IteratorSetting, IteratorScope
+import base64
+
 
 class BaseIterator(object):
     """docstring for BaseIterator"""
@@ -167,11 +169,11 @@
         return props
 
     def _encode_columns(self, cols):
-        return "".join([ col.encode("base64") for col in cols ]).rstrip()
+        return "".join([ base64.b64encode(col.encode("utf-8")).decode("utf-8") for col in cols ]).rstrip()
 
     def _encode_not_flags(self, flags):
         if flags:
-            return "".join( [self._convert_flag(flag) for flag in flags]).encode("base64")
+            return base64.b64encode("".join( [self._convert_flag(flag) for flag in flags]).encode("utf-8")).decode("utf-8")
         else:
             return None
     
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/AccumuloProxy.py pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy.py
--- pyaccumulo/pyaccumulo/proxy/AccumuloProxy.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy.py	2017-03-15 22:32:50.598584651 +0000
@@ -1,80 +1,8507 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TException, TApplicationException
-from ttypes import *
+from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+from thrift.protocol.TProtocol import TProtocolException
+import sys
+import logging
+from .ttypes import *
 from thrift.Thrift import TProcessor
 from thrift.transport import TTransport
-from thrift.protocol import TBinaryProtocol, TProtocol
-try:
-  from thrift.protocol import fastbinary
-except:
-  fastbinary = None
 
 
-class Iface:
-  def login(self, principal, loginProperties):
+class Iface(object):
+    def login(self, principal, loginProperties):
+        """
+        Parameters:
+         - principal
+         - loginProperties
+        """
+        pass
+
+    def addConstraint(self, login, tableName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraintClassName
+        """
+        pass
+
+    def addSplits(self, login, tableName, splits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - splits
+        """
+        pass
+
+    def attachIterator(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        pass
+
+    def checkIteratorConflicts(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        pass
+
+    def clearLocatorCache(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+        """
+        Parameters:
+         - login
+         - tableName
+         - newTableName
+         - flush
+         - propertiesToSet
+         - propertiesToExclude
+        """
+        pass
+
+    def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - iterators
+         - flush
+         - wait
+         - compactionStrategy
+        """
+        pass
+
+    def cancelCompaction(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def createTable(self, login, tableName, versioningIter, type):
+        """
+        Parameters:
+         - login
+         - tableName
+         - versioningIter
+         - type
+        """
+        pass
+
+    def deleteTable(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def deleteRows(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        pass
+
+    def exportTable(self, login, tableName, exportDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - exportDir
+        """
+        pass
+
+    def flushTable(self, login, tableName, startRow, endRow, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - wait
+        """
+        pass
+
+    def getDiskUsage(self, login, tables):
+        """
+        Parameters:
+         - login
+         - tables
+        """
+        pass
+
+    def getLocalityGroups(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def getIteratorSetting(self, login, tableName, iteratorName, scope):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iteratorName
+         - scope
+        """
+        pass
+
+    def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+        """
+        Parameters:
+         - login
+         - tableName
+         - auths
+         - startRow
+         - startInclusive
+         - endRow
+         - endInclusive
+        """
+        pass
+
+    def getTableProperties(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def importDirectory(self, login, tableName, importDir, failureDir, setTime):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+         - failureDir
+         - setTime
+        """
+        pass
+
+    def importTable(self, login, tableName, importDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+        """
+        pass
+
+    def listSplits(self, login, tableName, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - maxSplits
+        """
+        pass
+
+    def listTables(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def listIterators(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def listConstraints(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def mergeTablets(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        pass
+
+    def offlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        pass
+
+    def onlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        pass
+
+    def removeConstraint(self, login, tableName, constraint):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraint
+        """
+        pass
+
+    def removeIterator(self, login, tableName, iterName, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iterName
+         - scopes
+        """
+        pass
+
+    def removeTableProperty(self, login, tableName, property):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+        """
+        pass
+
+    def renameTable(self, login, oldTableName, newTableName):
+        """
+        Parameters:
+         - login
+         - oldTableName
+         - newTableName
+        """
+        pass
+
+    def setLocalityGroups(self, login, tableName, groups):
+        """
+        Parameters:
+         - login
+         - tableName
+         - groups
+        """
+        pass
+
+    def setTableProperty(self, login, tableName, property, value):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+         - value
+        """
+        pass
+
+    def splitRangeByTablets(self, login, tableName, range, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - range
+         - maxSplits
+        """
+        pass
+
+    def tableExists(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def tableIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def testTableClassLoad(self, login, tableName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - className
+         - asTypeName
+        """
+        pass
+
+    def pingTabletServer(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        pass
+
+    def getActiveScans(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        pass
+
+    def getActiveCompactions(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        pass
+
+    def getSiteConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def getSystemConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def getTabletServers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def removeProperty(self, login, property):
+        """
+        Parameters:
+         - login
+         - property
+        """
+        pass
+
+    def setProperty(self, login, property, value):
+        """
+        Parameters:
+         - login
+         - property
+         - value
+        """
+        pass
+
+    def testClassLoad(self, login, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - className
+         - asTypeName
+        """
+        pass
+
+    def authenticateUser(self, login, user, properties):
+        """
+        Parameters:
+         - login
+         - user
+         - properties
+        """
+        pass
+
+    def changeUserAuthorizations(self, login, user, authorizations):
+        """
+        Parameters:
+         - login
+         - user
+         - authorizations
+        """
+        pass
+
+    def changeLocalUserPassword(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        pass
+
+    def createLocalUser(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        pass
+
+    def dropLocalUser(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        pass
+
+    def getUserAuthorizations(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        pass
+
+    def grantSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        pass
+
+    def grantTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        pass
+
+    def hasSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        pass
+
+    def hasTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        pass
+
+    def listLocalUsers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def revokeSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        pass
+
+    def revokeTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        pass
+
+    def grantNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        pass
+
+    def hasNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        pass
+
+    def revokeNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        pass
+
+    def createBatchScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        pass
+
+    def createScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        pass
+
+    def hasNext(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        pass
+
+    def nextEntry(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        pass
+
+    def nextK(self, scanner, k):
+        """
+        Parameters:
+         - scanner
+         - k
+        """
+        pass
+
+    def closeScanner(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        pass
+
+    def updateAndFlush(self, login, tableName, cells):
+        """
+        Parameters:
+         - login
+         - tableName
+         - cells
+        """
+        pass
+
+    def createWriter(self, login, tableName, opts):
+        """
+        Parameters:
+         - login
+         - tableName
+         - opts
+        """
+        pass
+
+    def update(self, writer, cells):
+        """
+        Parameters:
+         - writer
+         - cells
+        """
+        pass
+
+    def flush(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        pass
+
+    def closeWriter(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        pass
+
+    def updateRowConditionally(self, login, tableName, row, updates):
+        """
+        Parameters:
+         - login
+         - tableName
+         - row
+         - updates
+        """
+        pass
+
+    def createConditionalWriter(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        pass
+
+    def updateRowsConditionally(self, conditionalWriter, updates):
+        """
+        Parameters:
+         - conditionalWriter
+         - updates
+        """
+        pass
+
+    def closeConditionalWriter(self, conditionalWriter):
+        """
+        Parameters:
+         - conditionalWriter
+        """
+        pass
+
+    def getRowRange(self, row):
+        """
+        Parameters:
+         - row
+        """
+        pass
+
+    def getFollowing(self, key, part):
+        """
+        Parameters:
+         - key
+         - part
+        """
+        pass
+
+    def systemNamespace(self):
+        pass
+
+    def defaultNamespace(self):
+        pass
+
+    def listNamespaces(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def namespaceExists(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def createNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def deleteNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def renameNamespace(self, login, oldNamespaceName, newNamespaceName):
+        """
+        Parameters:
+         - login
+         - oldNamespaceName
+         - newNamespaceName
+        """
+        pass
+
+    def setNamespaceProperty(self, login, namespaceName, property, value):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+         - value
+        """
+        pass
+
+    def removeNamespaceProperty(self, login, namespaceName, property):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+        """
+        pass
+
+    def getNamespaceProperties(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def namespaceIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def attachNamespaceIterator(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        pass
+
+    def removeNamespaceIterator(self, login, namespaceName, name, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scopes
+        """
+        pass
+
+    def getNamespaceIteratorSetting(self, login, namespaceName, name, scope):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scope
+        """
+        pass
+
+    def listNamespaceIterators(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def checkNamespaceIteratorConflicts(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        pass
+
+    def addNamespaceConstraint(self, login, namespaceName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - constraintClassName
+        """
+        pass
+
+    def removeNamespaceConstraint(self, login, namespaceName, id):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - id
+        """
+        pass
+
+    def listNamespaceConstraints(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def testNamespaceClassLoad(self, login, namespaceName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - className
+         - asTypeName
+        """
+        pass
+
+
+class Client(Iface):
+    def __init__(self, iprot, oprot=None):
+        self._iprot = self._oprot = iprot
+        if oprot is not None:
+            self._oprot = oprot
+        self._seqid = 0
+
+    def login(self, principal, loginProperties):
+        """
+        Parameters:
+         - principal
+         - loginProperties
+        """
+        self.send_login(principal, loginProperties)
+        return self.recv_login()
+
+    def send_login(self, principal, loginProperties):
+        self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
+        args = login_args()
+        args.principal = principal
+        args.loginProperties = loginProperties
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_login(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = login_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result")
+
+    def addConstraint(self, login, tableName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraintClassName
+        """
+        self.send_addConstraint(login, tableName, constraintClassName)
+        return self.recv_addConstraint()
+
+    def send_addConstraint(self, login, tableName, constraintClassName):
+        self._oprot.writeMessageBegin('addConstraint', TMessageType.CALL, self._seqid)
+        args = addConstraint_args()
+        args.login = login
+        args.tableName = tableName
+        args.constraintClassName = constraintClassName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_addConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = addConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "addConstraint failed: unknown result")
+
+    def addSplits(self, login, tableName, splits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - splits
+        """
+        self.send_addSplits(login, tableName, splits)
+        self.recv_addSplits()
+
+    def send_addSplits(self, login, tableName, splits):
+        self._oprot.writeMessageBegin('addSplits', TMessageType.CALL, self._seqid)
+        args = addSplits_args()
+        args.login = login
+        args.tableName = tableName
+        args.splits = splits
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_addSplits(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = addSplits_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def attachIterator(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        self.send_attachIterator(login, tableName, setting, scopes)
+        self.recv_attachIterator()
+
+    def send_attachIterator(self, login, tableName, setting, scopes):
+        self._oprot.writeMessageBegin('attachIterator', TMessageType.CALL, self._seqid)
+        args = attachIterator_args()
+        args.login = login
+        args.tableName = tableName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_attachIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = attachIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def checkIteratorConflicts(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        self.send_checkIteratorConflicts(login, tableName, setting, scopes)
+        self.recv_checkIteratorConflicts()
+
+    def send_checkIteratorConflicts(self, login, tableName, setting, scopes):
+        self._oprot.writeMessageBegin('checkIteratorConflicts', TMessageType.CALL, self._seqid)
+        args = checkIteratorConflicts_args()
+        args.login = login
+        args.tableName = tableName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_checkIteratorConflicts(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = checkIteratorConflicts_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def clearLocatorCache(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_clearLocatorCache(login, tableName)
+        self.recv_clearLocatorCache()
+
+    def send_clearLocatorCache(self, login, tableName):
+        self._oprot.writeMessageBegin('clearLocatorCache', TMessageType.CALL, self._seqid)
+        args = clearLocatorCache_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_clearLocatorCache(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = clearLocatorCache_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        return
+
+    def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+        """
+        Parameters:
+         - login
+         - tableName
+         - newTableName
+         - flush
+         - propertiesToSet
+         - propertiesToExclude
+        """
+        self.send_cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude)
+        self.recv_cloneTable()
+
+    def send_cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+        self._oprot.writeMessageBegin('cloneTable', TMessageType.CALL, self._seqid)
+        args = cloneTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.newTableName = newTableName
+        args.flush = flush
+        args.propertiesToSet = propertiesToSet
+        args.propertiesToExclude = propertiesToExclude
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_cloneTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = cloneTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - iterators
+         - flush
+         - wait
+         - compactionStrategy
+        """
+        self.send_compactTable(login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy)
+        self.recv_compactTable()
+
+    def send_compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy):
+        self._oprot.writeMessageBegin('compactTable', TMessageType.CALL, self._seqid)
+        args = compactTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.iterators = iterators
+        args.flush = flush
+        args.wait = wait
+        args.compactionStrategy = compactionStrategy
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_compactTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = compactTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def cancelCompaction(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_cancelCompaction(login, tableName)
+        self.recv_cancelCompaction()
+
+    def send_cancelCompaction(self, login, tableName):
+        self._oprot.writeMessageBegin('cancelCompaction', TMessageType.CALL, self._seqid)
+        args = cancelCompaction_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_cancelCompaction(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = cancelCompaction_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def createTable(self, login, tableName, versioningIter, type):
+        """
+        Parameters:
+         - login
+         - tableName
+         - versioningIter
+         - type
+        """
+        self.send_createTable(login, tableName, versioningIter, type)
+        self.recv_createTable()
+
+    def send_createTable(self, login, tableName, versioningIter, type):
+        self._oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
+        args = createTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.versioningIter = versioningIter
+        args.type = type
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def deleteTable(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_deleteTable(login, tableName)
+        self.recv_deleteTable()
+
+    def send_deleteTable(self, login, tableName):
+        self._oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
+        args = deleteTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_deleteTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = deleteTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def deleteRows(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        self.send_deleteRows(login, tableName, startRow, endRow)
+        self.recv_deleteRows()
+
+    def send_deleteRows(self, login, tableName, startRow, endRow):
+        self._oprot.writeMessageBegin('deleteRows', TMessageType.CALL, self._seqid)
+        args = deleteRows_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_deleteRows(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = deleteRows_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def exportTable(self, login, tableName, exportDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - exportDir
+        """
+        self.send_exportTable(login, tableName, exportDir)
+        self.recv_exportTable()
+
+    def send_exportTable(self, login, tableName, exportDir):
+        self._oprot.writeMessageBegin('exportTable', TMessageType.CALL, self._seqid)
+        args = exportTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.exportDir = exportDir
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_exportTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = exportTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def flushTable(self, login, tableName, startRow, endRow, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - wait
+        """
+        self.send_flushTable(login, tableName, startRow, endRow, wait)
+        self.recv_flushTable()
+
+    def send_flushTable(self, login, tableName, startRow, endRow, wait):
+        self._oprot.writeMessageBegin('flushTable', TMessageType.CALL, self._seqid)
+        args = flushTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.wait = wait
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_flushTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = flushTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def getDiskUsage(self, login, tables):
+        """
+        Parameters:
+         - login
+         - tables
+        """
+        self.send_getDiskUsage(login, tables)
+        return self.recv_getDiskUsage()
+
+    def send_getDiskUsage(self, login, tables):
+        self._oprot.writeMessageBegin('getDiskUsage', TMessageType.CALL, self._seqid)
+        args = getDiskUsage_args()
+        args.login = login
+        args.tables = tables
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getDiskUsage(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getDiskUsage_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDiskUsage failed: unknown result")
+
+    def getLocalityGroups(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_getLocalityGroups(login, tableName)
+        return self.recv_getLocalityGroups()
+
+    def send_getLocalityGroups(self, login, tableName):
+        self._oprot.writeMessageBegin('getLocalityGroups', TMessageType.CALL, self._seqid)
+        args = getLocalityGroups_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getLocalityGroups(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getLocalityGroups_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLocalityGroups failed: unknown result")
+
+    def getIteratorSetting(self, login, tableName, iteratorName, scope):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iteratorName
+         - scope
+        """
+        self.send_getIteratorSetting(login, tableName, iteratorName, scope)
+        return self.recv_getIteratorSetting()
+
+    def send_getIteratorSetting(self, login, tableName, iteratorName, scope):
+        self._oprot.writeMessageBegin('getIteratorSetting', TMessageType.CALL, self._seqid)
+        args = getIteratorSetting_args()
+        args.login = login
+        args.tableName = tableName
+        args.iteratorName = iteratorName
+        args.scope = scope
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getIteratorSetting(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getIteratorSetting_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getIteratorSetting failed: unknown result")
+
+    def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+        """
+        Parameters:
+         - login
+         - tableName
+         - auths
+         - startRow
+         - startInclusive
+         - endRow
+         - endInclusive
+        """
+        self.send_getMaxRow(login, tableName, auths, startRow, startInclusive, endRow, endInclusive)
+        return self.recv_getMaxRow()
+
+    def send_getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+        self._oprot.writeMessageBegin('getMaxRow', TMessageType.CALL, self._seqid)
+        args = getMaxRow_args()
+        args.login = login
+        args.tableName = tableName
+        args.auths = auths
+        args.startRow = startRow
+        args.startInclusive = startInclusive
+        args.endRow = endRow
+        args.endInclusive = endInclusive
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getMaxRow(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getMaxRow_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMaxRow failed: unknown result")
+
+    def getTableProperties(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_getTableProperties(login, tableName)
+        return self.recv_getTableProperties()
+
+    def send_getTableProperties(self, login, tableName):
+        self._oprot.writeMessageBegin('getTableProperties', TMessageType.CALL, self._seqid)
+        args = getTableProperties_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getTableProperties(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getTableProperties_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableProperties failed: unknown result")
+
+    def importDirectory(self, login, tableName, importDir, failureDir, setTime):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+         - failureDir
+         - setTime
+        """
+        self.send_importDirectory(login, tableName, importDir, failureDir, setTime)
+        self.recv_importDirectory()
+
+    def send_importDirectory(self, login, tableName, importDir, failureDir, setTime):
+        self._oprot.writeMessageBegin('importDirectory', TMessageType.CALL, self._seqid)
+        args = importDirectory_args()
+        args.login = login
+        args.tableName = tableName
+        args.importDir = importDir
+        args.failureDir = failureDir
+        args.setTime = setTime
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_importDirectory(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = importDirectory_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def importTable(self, login, tableName, importDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+        """
+        self.send_importTable(login, tableName, importDir)
+        self.recv_importTable()
+
+    def send_importTable(self, login, tableName, importDir):
+        self._oprot.writeMessageBegin('importTable', TMessageType.CALL, self._seqid)
+        args = importTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.importDir = importDir
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_importTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = importTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def listSplits(self, login, tableName, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - maxSplits
+        """
+        self.send_listSplits(login, tableName, maxSplits)
+        return self.recv_listSplits()
+
+    def send_listSplits(self, login, tableName, maxSplits):
+        self._oprot.writeMessageBegin('listSplits', TMessageType.CALL, self._seqid)
+        args = listSplits_args()
+        args.login = login
+        args.tableName = tableName
+        args.maxSplits = maxSplits
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listSplits(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listSplits_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listSplits failed: unknown result")
+
+    def listTables(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_listTables(login)
+        return self.recv_listTables()
+
+    def send_listTables(self, login):
+        self._oprot.writeMessageBegin('listTables', TMessageType.CALL, self._seqid)
+        args = listTables_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listTables(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listTables_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result")
+
+    def listIterators(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_listIterators(login, tableName)
+        return self.recv_listIterators()
+
+    def send_listIterators(self, login, tableName):
+        self._oprot.writeMessageBegin('listIterators', TMessageType.CALL, self._seqid)
+        args = listIterators_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listIterators(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listIterators_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listIterators failed: unknown result")
+
+    def listConstraints(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_listConstraints(login, tableName)
+        return self.recv_listConstraints()
+
+    def send_listConstraints(self, login, tableName):
+        self._oprot.writeMessageBegin('listConstraints', TMessageType.CALL, self._seqid)
+        args = listConstraints_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listConstraints(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listConstraints_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listConstraints failed: unknown result")
+
+    def mergeTablets(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        self.send_mergeTablets(login, tableName, startRow, endRow)
+        self.recv_mergeTablets()
+
+    def send_mergeTablets(self, login, tableName, startRow, endRow):
+        self._oprot.writeMessageBegin('mergeTablets', TMessageType.CALL, self._seqid)
+        args = mergeTablets_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_mergeTablets(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = mergeTablets_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def offlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        self.send_offlineTable(login, tableName, wait)
+        self.recv_offlineTable()
+
+    def send_offlineTable(self, login, tableName, wait):
+        self._oprot.writeMessageBegin('offlineTable', TMessageType.CALL, self._seqid)
+        args = offlineTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.wait = wait
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_offlineTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = offlineTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def onlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        self.send_onlineTable(login, tableName, wait)
+        self.recv_onlineTable()
+
+    def send_onlineTable(self, login, tableName, wait):
+        self._oprot.writeMessageBegin('onlineTable', TMessageType.CALL, self._seqid)
+        args = onlineTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.wait = wait
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_onlineTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = onlineTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeConstraint(self, login, tableName, constraint):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraint
+        """
+        self.send_removeConstraint(login, tableName, constraint)
+        self.recv_removeConstraint()
+
+    def send_removeConstraint(self, login, tableName, constraint):
+        self._oprot.writeMessageBegin('removeConstraint', TMessageType.CALL, self._seqid)
+        args = removeConstraint_args()
+        args.login = login
+        args.tableName = tableName
+        args.constraint = constraint
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeIterator(self, login, tableName, iterName, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iterName
+         - scopes
+        """
+        self.send_removeIterator(login, tableName, iterName, scopes)
+        self.recv_removeIterator()
+
+    def send_removeIterator(self, login, tableName, iterName, scopes):
+        self._oprot.writeMessageBegin('removeIterator', TMessageType.CALL, self._seqid)
+        args = removeIterator_args()
+        args.login = login
+        args.tableName = tableName
+        args.iterName = iterName
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeTableProperty(self, login, tableName, property):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+        """
+        self.send_removeTableProperty(login, tableName, property)
+        self.recv_removeTableProperty()
+
+    def send_removeTableProperty(self, login, tableName, property):
+        self._oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
+        args = removeTableProperty_args()
+        args.login = login
+        args.tableName = tableName
+        args.property = property
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeTableProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeTableProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def renameTable(self, login, oldTableName, newTableName):
+        """
+        Parameters:
+         - login
+         - oldTableName
+         - newTableName
+        """
+        self.send_renameTable(login, oldTableName, newTableName)
+        self.recv_renameTable()
+
+    def send_renameTable(self, login, oldTableName, newTableName):
+        self._oprot.writeMessageBegin('renameTable', TMessageType.CALL, self._seqid)
+        args = renameTable_args()
+        args.login = login
+        args.oldTableName = oldTableName
+        args.newTableName = newTableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_renameTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = renameTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def setLocalityGroups(self, login, tableName, groups):
+        """
+        Parameters:
+         - login
+         - tableName
+         - groups
+        """
+        self.send_setLocalityGroups(login, tableName, groups)
+        self.recv_setLocalityGroups()
+
+    def send_setLocalityGroups(self, login, tableName, groups):
+        self._oprot.writeMessageBegin('setLocalityGroups', TMessageType.CALL, self._seqid)
+        args = setLocalityGroups_args()
+        args.login = login
+        args.tableName = tableName
+        args.groups = groups
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setLocalityGroups(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setLocalityGroups_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def setTableProperty(self, login, tableName, property, value):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+         - value
+        """
+        self.send_setTableProperty(login, tableName, property, value)
+        self.recv_setTableProperty()
+
+    def send_setTableProperty(self, login, tableName, property, value):
+        self._oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
+        args = setTableProperty_args()
+        args.login = login
+        args.tableName = tableName
+        args.property = property
+        args.value = value
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setTableProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setTableProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def splitRangeByTablets(self, login, tableName, range, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - range
+         - maxSplits
+        """
+        self.send_splitRangeByTablets(login, tableName, range, maxSplits)
+        return self.recv_splitRangeByTablets()
+
+    def send_splitRangeByTablets(self, login, tableName, range, maxSplits):
+        self._oprot.writeMessageBegin('splitRangeByTablets', TMessageType.CALL, self._seqid)
+        args = splitRangeByTablets_args()
+        args.login = login
+        args.tableName = tableName
+        args.range = range
+        args.maxSplits = maxSplits
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_splitRangeByTablets(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = splitRangeByTablets_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "splitRangeByTablets failed: unknown result")
+
+    def tableExists(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_tableExists(login, tableName)
+        return self.recv_tableExists()
+
+    def send_tableExists(self, login, tableName):
+        self._oprot.writeMessageBegin('tableExists', TMessageType.CALL, self._seqid)
+        args = tableExists_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_tableExists(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = tableExists_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableExists failed: unknown result")
+
+    def tableIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_tableIdMap(login)
+        return self.recv_tableIdMap()
+
+    def send_tableIdMap(self, login):
+        self._oprot.writeMessageBegin('tableIdMap', TMessageType.CALL, self._seqid)
+        args = tableIdMap_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_tableIdMap(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = tableIdMap_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIdMap failed: unknown result")
+
+    def testTableClassLoad(self, login, tableName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - className
+         - asTypeName
+        """
+        self.send_testTableClassLoad(login, tableName, className, asTypeName)
+        return self.recv_testTableClassLoad()
+
+    def send_testTableClassLoad(self, login, tableName, className, asTypeName):
+        self._oprot.writeMessageBegin('testTableClassLoad', TMessageType.CALL, self._seqid)
+        args = testTableClassLoad_args()
+        args.login = login
+        args.tableName = tableName
+        args.className = className
+        args.asTypeName = asTypeName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_testTableClassLoad(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = testTableClassLoad_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "testTableClassLoad failed: unknown result")
+
+    def pingTabletServer(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        self.send_pingTabletServer(login, tserver)
+        self.recv_pingTabletServer()
+
+    def send_pingTabletServer(self, login, tserver):
+        self._oprot.writeMessageBegin('pingTabletServer', TMessageType.CALL, self._seqid)
+        args = pingTabletServer_args()
+        args.login = login
+        args.tserver = tserver
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_pingTabletServer(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = pingTabletServer_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def getActiveScans(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        self.send_getActiveScans(login, tserver)
+        return self.recv_getActiveScans()
+
+    def send_getActiveScans(self, login, tserver):
+        self._oprot.writeMessageBegin('getActiveScans', TMessageType.CALL, self._seqid)
+        args = getActiveScans_args()
+        args.login = login
+        args.tserver = tserver
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getActiveScans(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getActiveScans_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveScans failed: unknown result")
+
+    def getActiveCompactions(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        self.send_getActiveCompactions(login, tserver)
+        return self.recv_getActiveCompactions()
+
+    def send_getActiveCompactions(self, login, tserver):
+        self._oprot.writeMessageBegin('getActiveCompactions', TMessageType.CALL, self._seqid)
+        args = getActiveCompactions_args()
+        args.login = login
+        args.tserver = tserver
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getActiveCompactions(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getActiveCompactions_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveCompactions failed: unknown result")
+
+    def getSiteConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_getSiteConfiguration(login)
+        return self.recv_getSiteConfiguration()
+
+    def send_getSiteConfiguration(self, login):
+        self._oprot.writeMessageBegin('getSiteConfiguration', TMessageType.CALL, self._seqid)
+        args = getSiteConfiguration_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getSiteConfiguration(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getSiteConfiguration_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSiteConfiguration failed: unknown result")
+
+    def getSystemConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_getSystemConfiguration(login)
+        return self.recv_getSystemConfiguration()
+
+    def send_getSystemConfiguration(self, login):
+        self._oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
+        args = getSystemConfiguration_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getSystemConfiguration(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getSystemConfiguration_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSystemConfiguration failed: unknown result")
+
+    def getTabletServers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_getTabletServers(login)
+        return self.recv_getTabletServers()
+
+    def send_getTabletServers(self, login):
+        self._oprot.writeMessageBegin('getTabletServers', TMessageType.CALL, self._seqid)
+        args = getTabletServers_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getTabletServers(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getTabletServers_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTabletServers failed: unknown result")
+
+    def removeProperty(self, login, property):
+        """
+        Parameters:
+         - login
+         - property
+        """
+        self.send_removeProperty(login, property)
+        self.recv_removeProperty()
+
+    def send_removeProperty(self, login, property):
+        self._oprot.writeMessageBegin('removeProperty', TMessageType.CALL, self._seqid)
+        args = removeProperty_args()
+        args.login = login
+        args.property = property
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def setProperty(self, login, property, value):
+        """
+        Parameters:
+         - login
+         - property
+         - value
+        """
+        self.send_setProperty(login, property, value)
+        self.recv_setProperty()
+
+    def send_setProperty(self, login, property, value):
+        self._oprot.writeMessageBegin('setProperty', TMessageType.CALL, self._seqid)
+        args = setProperty_args()
+        args.login = login
+        args.property = property
+        args.value = value
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def testClassLoad(self, login, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - className
+         - asTypeName
+        """
+        self.send_testClassLoad(login, className, asTypeName)
+        return self.recv_testClassLoad()
+
+    def send_testClassLoad(self, login, className, asTypeName):
+        self._oprot.writeMessageBegin('testClassLoad', TMessageType.CALL, self._seqid)
+        args = testClassLoad_args()
+        args.login = login
+        args.className = className
+        args.asTypeName = asTypeName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_testClassLoad(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = testClassLoad_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "testClassLoad failed: unknown result")
+
+    def authenticateUser(self, login, user, properties):
+        """
+        Parameters:
+         - login
+         - user
+         - properties
+        """
+        self.send_authenticateUser(login, user, properties)
+        return self.recv_authenticateUser()
+
+    def send_authenticateUser(self, login, user, properties):
+        self._oprot.writeMessageBegin('authenticateUser', TMessageType.CALL, self._seqid)
+        args = authenticateUser_args()
+        args.login = login
+        args.user = user
+        args.properties = properties
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_authenticateUser(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = authenticateUser_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateUser failed: unknown result")
+
+    def changeUserAuthorizations(self, login, user, authorizations):
+        """
+        Parameters:
+         - login
+         - user
+         - authorizations
+        """
+        self.send_changeUserAuthorizations(login, user, authorizations)
+        self.recv_changeUserAuthorizations()
+
+    def send_changeUserAuthorizations(self, login, user, authorizations):
+        self._oprot.writeMessageBegin('changeUserAuthorizations', TMessageType.CALL, self._seqid)
+        args = changeUserAuthorizations_args()
+        args.login = login
+        args.user = user
+        args.authorizations = authorizations
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_changeUserAuthorizations(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = changeUserAuthorizations_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def changeLocalUserPassword(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        self.send_changeLocalUserPassword(login, user, password)
+        self.recv_changeLocalUserPassword()
+
+    def send_changeLocalUserPassword(self, login, user, password):
+        self._oprot.writeMessageBegin('changeLocalUserPassword', TMessageType.CALL, self._seqid)
+        args = changeLocalUserPassword_args()
+        args.login = login
+        args.user = user
+        args.password = password
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_changeLocalUserPassword(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = changeLocalUserPassword_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def createLocalUser(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        self.send_createLocalUser(login, user, password)
+        self.recv_createLocalUser()
+
+    def send_createLocalUser(self, login, user, password):
+        self._oprot.writeMessageBegin('createLocalUser', TMessageType.CALL, self._seqid)
+        args = createLocalUser_args()
+        args.login = login
+        args.user = user
+        args.password = password
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createLocalUser(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createLocalUser_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def dropLocalUser(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        self.send_dropLocalUser(login, user)
+        self.recv_dropLocalUser()
+
+    def send_dropLocalUser(self, login, user):
+        self._oprot.writeMessageBegin('dropLocalUser', TMessageType.CALL, self._seqid)
+        args = dropLocalUser_args()
+        args.login = login
+        args.user = user
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_dropLocalUser(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = dropLocalUser_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def getUserAuthorizations(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        self.send_getUserAuthorizations(login, user)
+        return self.recv_getUserAuthorizations()
+
+    def send_getUserAuthorizations(self, login, user):
+        self._oprot.writeMessageBegin('getUserAuthorizations', TMessageType.CALL, self._seqid)
+        args = getUserAuthorizations_args()
+        args.login = login
+        args.user = user
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getUserAuthorizations(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getUserAuthorizations_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserAuthorizations failed: unknown result")
+
+    def grantSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        self.send_grantSystemPermission(login, user, perm)
+        self.recv_grantSystemPermission()
+
+    def send_grantSystemPermission(self, login, user, perm):
+        self._oprot.writeMessageBegin('grantSystemPermission', TMessageType.CALL, self._seqid)
+        args = grantSystemPermission_args()
+        args.login = login
+        args.user = user
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_grantSystemPermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = grantSystemPermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def grantTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        self.send_grantTablePermission(login, user, table, perm)
+        self.recv_grantTablePermission()
+
+    def send_grantTablePermission(self, login, user, table, perm):
+        self._oprot.writeMessageBegin('grantTablePermission', TMessageType.CALL, self._seqid)
+        args = grantTablePermission_args()
+        args.login = login
+        args.user = user
+        args.table = table
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_grantTablePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = grantTablePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def hasSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        self.send_hasSystemPermission(login, user, perm)
+        return self.recv_hasSystemPermission()
+
+    def send_hasSystemPermission(self, login, user, perm):
+        self._oprot.writeMessageBegin('hasSystemPermission', TMessageType.CALL, self._seqid)
+        args = hasSystemPermission_args()
+        args.login = login
+        args.user = user
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasSystemPermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasSystemPermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasSystemPermission failed: unknown result")
+
+    def hasTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        self.send_hasTablePermission(login, user, table, perm)
+        return self.recv_hasTablePermission()
+
+    def send_hasTablePermission(self, login, user, table, perm):
+        self._oprot.writeMessageBegin('hasTablePermission', TMessageType.CALL, self._seqid)
+        args = hasTablePermission_args()
+        args.login = login
+        args.user = user
+        args.table = table
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasTablePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasTablePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasTablePermission failed: unknown result")
+
+    def listLocalUsers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_listLocalUsers(login)
+        return self.recv_listLocalUsers()
+
+    def send_listLocalUsers(self, login):
+        self._oprot.writeMessageBegin('listLocalUsers', TMessageType.CALL, self._seqid)
+        args = listLocalUsers_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listLocalUsers(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listLocalUsers_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listLocalUsers failed: unknown result")
+
+    def revokeSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        self.send_revokeSystemPermission(login, user, perm)
+        self.recv_revokeSystemPermission()
+
+    def send_revokeSystemPermission(self, login, user, perm):
+        self._oprot.writeMessageBegin('revokeSystemPermission', TMessageType.CALL, self._seqid)
+        args = revokeSystemPermission_args()
+        args.login = login
+        args.user = user
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_revokeSystemPermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = revokeSystemPermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def revokeTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        self.send_revokeTablePermission(login, user, table, perm)
+        self.recv_revokeTablePermission()
+
+    def send_revokeTablePermission(self, login, user, table, perm):
+        self._oprot.writeMessageBegin('revokeTablePermission', TMessageType.CALL, self._seqid)
+        args = revokeTablePermission_args()
+        args.login = login
+        args.user = user
+        args.table = table
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_revokeTablePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = revokeTablePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def grantNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        self.send_grantNamespacePermission(login, user, namespaceName, perm)
+        self.recv_grantNamespacePermission()
+
+    def send_grantNamespacePermission(self, login, user, namespaceName, perm):
+        self._oprot.writeMessageBegin('grantNamespacePermission', TMessageType.CALL, self._seqid)
+        args = grantNamespacePermission_args()
+        args.login = login
+        args.user = user
+        args.namespaceName = namespaceName
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_grantNamespacePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = grantNamespacePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def hasNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        self.send_hasNamespacePermission(login, user, namespaceName, perm)
+        return self.recv_hasNamespacePermission()
+
+    def send_hasNamespacePermission(self, login, user, namespaceName, perm):
+        self._oprot.writeMessageBegin('hasNamespacePermission', TMessageType.CALL, self._seqid)
+        args = hasNamespacePermission_args()
+        args.login = login
+        args.user = user
+        args.namespaceName = namespaceName
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasNamespacePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasNamespacePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNamespacePermission failed: unknown result")
+
+    def revokeNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        self.send_revokeNamespacePermission(login, user, namespaceName, perm)
+        self.recv_revokeNamespacePermission()
+
+    def send_revokeNamespacePermission(self, login, user, namespaceName, perm):
+        self._oprot.writeMessageBegin('revokeNamespacePermission', TMessageType.CALL, self._seqid)
+        args = revokeNamespacePermission_args()
+        args.login = login
+        args.user = user
+        args.namespaceName = namespaceName
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_revokeNamespacePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = revokeNamespacePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def createBatchScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        self.send_createBatchScanner(login, tableName, options)
+        return self.recv_createBatchScanner()
+
+    def send_createBatchScanner(self, login, tableName, options):
+        self._oprot.writeMessageBegin('createBatchScanner', TMessageType.CALL, self._seqid)
+        args = createBatchScanner_args()
+        args.login = login
+        args.tableName = tableName
+        args.options = options
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createBatchScanner(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createBatchScanner_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createBatchScanner failed: unknown result")
+
+    def createScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        self.send_createScanner(login, tableName, options)
+        return self.recv_createScanner()
+
+    def send_createScanner(self, login, tableName, options):
+        self._oprot.writeMessageBegin('createScanner', TMessageType.CALL, self._seqid)
+        args = createScanner_args()
+        args.login = login
+        args.tableName = tableName
+        args.options = options
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createScanner(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createScanner_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createScanner failed: unknown result")
+
+    def hasNext(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        self.send_hasNext(scanner)
+        return self.recv_hasNext()
+
+    def send_hasNext(self, scanner):
+        self._oprot.writeMessageBegin('hasNext', TMessageType.CALL, self._seqid)
+        args = hasNext_args()
+        args.scanner = scanner
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasNext(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasNext_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNext failed: unknown result")
+
+    def nextEntry(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        self.send_nextEntry(scanner)
+        return self.recv_nextEntry()
+
+    def send_nextEntry(self, scanner):
+        self._oprot.writeMessageBegin('nextEntry', TMessageType.CALL, self._seqid)
+        args = nextEntry_args()
+        args.scanner = scanner
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_nextEntry(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = nextEntry_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "nextEntry failed: unknown result")
+
+    def nextK(self, scanner, k):
+        """
+        Parameters:
+         - scanner
+         - k
+        """
+        self.send_nextK(scanner, k)
+        return self.recv_nextK()
+
+    def send_nextK(self, scanner, k):
+        self._oprot.writeMessageBegin('nextK', TMessageType.CALL, self._seqid)
+        args = nextK_args()
+        args.scanner = scanner
+        args.k = k
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_nextK(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = nextK_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "nextK failed: unknown result")
+
+    def closeScanner(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        self.send_closeScanner(scanner)
+        self.recv_closeScanner()
+
+    def send_closeScanner(self, scanner):
+        self._oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
+        args = closeScanner_args()
+        args.scanner = scanner
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_closeScanner(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = closeScanner_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        return
+
+    def updateAndFlush(self, login, tableName, cells):
+        """
+        Parameters:
+         - login
+         - tableName
+         - cells
+        """
+        self.send_updateAndFlush(login, tableName, cells)
+        self.recv_updateAndFlush()
+
+    def send_updateAndFlush(self, login, tableName, cells):
+        self._oprot.writeMessageBegin('updateAndFlush', TMessageType.CALL, self._seqid)
+        args = updateAndFlush_args()
+        args.login = login
+        args.tableName = tableName
+        args.cells = cells
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_updateAndFlush(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = updateAndFlush_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.outch1 is not None:
+            raise result.outch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def createWriter(self, login, tableName, opts):
+        """
+        Parameters:
+         - login
+         - tableName
+         - opts
+        """
+        self.send_createWriter(login, tableName, opts)
+        return self.recv_createWriter()
+
+    def send_createWriter(self, login, tableName, opts):
+        self._oprot.writeMessageBegin('createWriter', TMessageType.CALL, self._seqid)
+        args = createWriter_args()
+        args.login = login
+        args.tableName = tableName
+        args.opts = opts
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.outch1 is not None:
+            raise result.outch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createWriter failed: unknown result")
+
+    def update(self, writer, cells):
+        """
+        Parameters:
+         - writer
+         - cells
+        """
+        self.send_update(writer, cells)
+
+    def send_update(self, writer, cells):
+        self._oprot.writeMessageBegin('update', TMessageType.ONEWAY, self._seqid)
+        args = update_args()
+        args.writer = writer
+        args.cells = cells
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def flush(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        self.send_flush(writer)
+        self.recv_flush()
+
+    def send_flush(self, writer):
+        self._oprot.writeMessageBegin('flush', TMessageType.CALL, self._seqid)
+        args = flush_args()
+        args.writer = writer
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_flush(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = flush_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def closeWriter(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        self.send_closeWriter(writer)
+        self.recv_closeWriter()
+
+    def send_closeWriter(self, writer):
+        self._oprot.writeMessageBegin('closeWriter', TMessageType.CALL, self._seqid)
+        args = closeWriter_args()
+        args.writer = writer
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_closeWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = closeWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def updateRowConditionally(self, login, tableName, row, updates):
+        """
+        Parameters:
+         - login
+         - tableName
+         - row
+         - updates
+        """
+        self.send_updateRowConditionally(login, tableName, row, updates)
+        return self.recv_updateRowConditionally()
+
+    def send_updateRowConditionally(self, login, tableName, row, updates):
+        self._oprot.writeMessageBegin('updateRowConditionally', TMessageType.CALL, self._seqid)
+        args = updateRowConditionally_args()
+        args.login = login
+        args.tableName = tableName
+        args.row = row
+        args.updates = updates
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_updateRowConditionally(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = updateRowConditionally_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRowConditionally failed: unknown result")
+
+    def createConditionalWriter(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        self.send_createConditionalWriter(login, tableName, options)
+        return self.recv_createConditionalWriter()
+
+    def send_createConditionalWriter(self, login, tableName, options):
+        self._oprot.writeMessageBegin('createConditionalWriter', TMessageType.CALL, self._seqid)
+        args = createConditionalWriter_args()
+        args.login = login
+        args.tableName = tableName
+        args.options = options
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createConditionalWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createConditionalWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createConditionalWriter failed: unknown result")
+
+    def updateRowsConditionally(self, conditionalWriter, updates):
+        """
+        Parameters:
+         - conditionalWriter
+         - updates
+        """
+        self.send_updateRowsConditionally(conditionalWriter, updates)
+        return self.recv_updateRowsConditionally()
+
+    def send_updateRowsConditionally(self, conditionalWriter, updates):
+        self._oprot.writeMessageBegin('updateRowsConditionally', TMessageType.CALL, self._seqid)
+        args = updateRowsConditionally_args()
+        args.conditionalWriter = conditionalWriter
+        args.updates = updates
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_updateRowsConditionally(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = updateRowsConditionally_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRowsConditionally failed: unknown result")
+
+    def closeConditionalWriter(self, conditionalWriter):
+        """
+        Parameters:
+         - conditionalWriter
+        """
+        self.send_closeConditionalWriter(conditionalWriter)
+        self.recv_closeConditionalWriter()
+
+    def send_closeConditionalWriter(self, conditionalWriter):
+        self._oprot.writeMessageBegin('closeConditionalWriter', TMessageType.CALL, self._seqid)
+        args = closeConditionalWriter_args()
+        args.conditionalWriter = conditionalWriter
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_closeConditionalWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = closeConditionalWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        return
+
+    def getRowRange(self, row):
+        """
+        Parameters:
+         - row
+        """
+        self.send_getRowRange(row)
+        return self.recv_getRowRange()
+
+    def send_getRowRange(self, row):
+        self._oprot.writeMessageBegin('getRowRange', TMessageType.CALL, self._seqid)
+        args = getRowRange_args()
+        args.row = row
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getRowRange(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getRowRange_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRowRange failed: unknown result")
+
+    def getFollowing(self, key, part):
+        """
+        Parameters:
+         - key
+         - part
+        """
+        self.send_getFollowing(key, part)
+        return self.recv_getFollowing()
+
+    def send_getFollowing(self, key, part):
+        self._oprot.writeMessageBegin('getFollowing', TMessageType.CALL, self._seqid)
+        args = getFollowing_args()
+        args.key = key
+        args.part = part
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getFollowing(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getFollowing_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFollowing failed: unknown result")
+
+    def systemNamespace(self):
+        self.send_systemNamespace()
+        return self.recv_systemNamespace()
+
+    def send_systemNamespace(self):
+        self._oprot.writeMessageBegin('systemNamespace', TMessageType.CALL, self._seqid)
+        args = systemNamespace_args()
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_systemNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = systemNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "systemNamespace failed: unknown result")
+
+    def defaultNamespace(self):
+        self.send_defaultNamespace()
+        return self.recv_defaultNamespace()
+
+    def send_defaultNamespace(self):
+        self._oprot.writeMessageBegin('defaultNamespace', TMessageType.CALL, self._seqid)
+        args = defaultNamespace_args()
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_defaultNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = defaultNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "defaultNamespace failed: unknown result")
+
+    def listNamespaces(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_listNamespaces(login)
+        return self.recv_listNamespaces()
+
+    def send_listNamespaces(self, login):
+        self._oprot.writeMessageBegin('listNamespaces', TMessageType.CALL, self._seqid)
+        args = listNamespaces_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listNamespaces(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listNamespaces_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaces failed: unknown result")
+
+    def namespaceExists(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_namespaceExists(login, namespaceName)
+        return self.recv_namespaceExists()
+
+    def send_namespaceExists(self, login, namespaceName):
+        self._oprot.writeMessageBegin('namespaceExists', TMessageType.CALL, self._seqid)
+        args = namespaceExists_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_namespaceExists(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = namespaceExists_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespaceExists failed: unknown result")
+
+    def createNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_createNamespace(login, namespaceName)
+        self.recv_createNamespace()
+
+    def send_createNamespace(self, login, namespaceName):
+        self._oprot.writeMessageBegin('createNamespace', TMessageType.CALL, self._seqid)
+        args = createNamespace_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def deleteNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_deleteNamespace(login, namespaceName)
+        self.recv_deleteNamespace()
+
+    def send_deleteNamespace(self, login, namespaceName):
+        self._oprot.writeMessageBegin('deleteNamespace', TMessageType.CALL, self._seqid)
+        args = deleteNamespace_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_deleteNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = deleteNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def renameNamespace(self, login, oldNamespaceName, newNamespaceName):
+        """
+        Parameters:
+         - login
+         - oldNamespaceName
+         - newNamespaceName
+        """
+        self.send_renameNamespace(login, oldNamespaceName, newNamespaceName)
+        self.recv_renameNamespace()
+
+    def send_renameNamespace(self, login, oldNamespaceName, newNamespaceName):
+        self._oprot.writeMessageBegin('renameNamespace', TMessageType.CALL, self._seqid)
+        args = renameNamespace_args()
+        args.login = login
+        args.oldNamespaceName = oldNamespaceName
+        args.newNamespaceName = newNamespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_renameNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = renameNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def setNamespaceProperty(self, login, namespaceName, property, value):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+         - value
+        """
+        self.send_setNamespaceProperty(login, namespaceName, property, value)
+        self.recv_setNamespaceProperty()
+
+    def send_setNamespaceProperty(self, login, namespaceName, property, value):
+        self._oprot.writeMessageBegin('setNamespaceProperty', TMessageType.CALL, self._seqid)
+        args = setNamespaceProperty_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.property = property
+        args.value = value
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setNamespaceProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setNamespaceProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeNamespaceProperty(self, login, namespaceName, property):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+        """
+        self.send_removeNamespaceProperty(login, namespaceName, property)
+        self.recv_removeNamespaceProperty()
+
+    def send_removeNamespaceProperty(self, login, namespaceName, property):
+        self._oprot.writeMessageBegin('removeNamespaceProperty', TMessageType.CALL, self._seqid)
+        args = removeNamespaceProperty_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.property = property
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeNamespaceProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeNamespaceProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def getNamespaceProperties(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_getNamespaceProperties(login, namespaceName)
+        return self.recv_getNamespaceProperties()
+
+    def send_getNamespaceProperties(self, login, namespaceName):
+        self._oprot.writeMessageBegin('getNamespaceProperties', TMessageType.CALL, self._seqid)
+        args = getNamespaceProperties_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getNamespaceProperties(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getNamespaceProperties_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNamespaceProperties failed: unknown result")
+
+    def namespaceIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_namespaceIdMap(login)
+        return self.recv_namespaceIdMap()
+
+    def send_namespaceIdMap(self, login):
+        self._oprot.writeMessageBegin('namespaceIdMap', TMessageType.CALL, self._seqid)
+        args = namespaceIdMap_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_namespaceIdMap(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = namespaceIdMap_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespaceIdMap failed: unknown result")
+
+    def attachNamespaceIterator(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        self.send_attachNamespaceIterator(login, namespaceName, setting, scopes)
+        self.recv_attachNamespaceIterator()
+
+    def send_attachNamespaceIterator(self, login, namespaceName, setting, scopes):
+        self._oprot.writeMessageBegin('attachNamespaceIterator', TMessageType.CALL, self._seqid)
+        args = attachNamespaceIterator_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_attachNamespaceIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = attachNamespaceIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeNamespaceIterator(self, login, namespaceName, name, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scopes
+        """
+        self.send_removeNamespaceIterator(login, namespaceName, name, scopes)
+        self.recv_removeNamespaceIterator()
+
+    def send_removeNamespaceIterator(self, login, namespaceName, name, scopes):
+        self._oprot.writeMessageBegin('removeNamespaceIterator', TMessageType.CALL, self._seqid)
+        args = removeNamespaceIterator_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.name = name
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeNamespaceIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeNamespaceIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def getNamespaceIteratorSetting(self, login, namespaceName, name, scope):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scope
+        """
+        self.send_getNamespaceIteratorSetting(login, namespaceName, name, scope)
+        return self.recv_getNamespaceIteratorSetting()
+
+    def send_getNamespaceIteratorSetting(self, login, namespaceName, name, scope):
+        self._oprot.writeMessageBegin('getNamespaceIteratorSetting', TMessageType.CALL, self._seqid)
+        args = getNamespaceIteratorSetting_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.name = name
+        args.scope = scope
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getNamespaceIteratorSetting(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getNamespaceIteratorSetting_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNamespaceIteratorSetting failed: unknown result")
+
+    def listNamespaceIterators(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_listNamespaceIterators(login, namespaceName)
+        return self.recv_listNamespaceIterators()
+
+    def send_listNamespaceIterators(self, login, namespaceName):
+        self._oprot.writeMessageBegin('listNamespaceIterators', TMessageType.CALL, self._seqid)
+        args = listNamespaceIterators_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listNamespaceIterators(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listNamespaceIterators_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaceIterators failed: unknown result")
+
+    def checkNamespaceIteratorConflicts(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        self.send_checkNamespaceIteratorConflicts(login, namespaceName, setting, scopes)
+        self.recv_checkNamespaceIteratorConflicts()
+
+    def send_checkNamespaceIteratorConflicts(self, login, namespaceName, setting, scopes):
+        self._oprot.writeMessageBegin('checkNamespaceIteratorConflicts', TMessageType.CALL, self._seqid)
+        args = checkNamespaceIteratorConflicts_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_checkNamespaceIteratorConflicts(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = checkNamespaceIteratorConflicts_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def addNamespaceConstraint(self, login, namespaceName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - constraintClassName
+        """
+        self.send_addNamespaceConstraint(login, namespaceName, constraintClassName)
+        return self.recv_addNamespaceConstraint()
+
+    def send_addNamespaceConstraint(self, login, namespaceName, constraintClassName):
+        self._oprot.writeMessageBegin('addNamespaceConstraint', TMessageType.CALL, self._seqid)
+        args = addNamespaceConstraint_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.constraintClassName = constraintClassName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_addNamespaceConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = addNamespaceConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "addNamespaceConstraint failed: unknown result")
+
+    def removeNamespaceConstraint(self, login, namespaceName, id):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - id
+        """
+        self.send_removeNamespaceConstraint(login, namespaceName, id)
+        self.recv_removeNamespaceConstraint()
+
+    def send_removeNamespaceConstraint(self, login, namespaceName, id):
+        self._oprot.writeMessageBegin('removeNamespaceConstraint', TMessageType.CALL, self._seqid)
+        args = removeNamespaceConstraint_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.id = id
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeNamespaceConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeNamespaceConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def listNamespaceConstraints(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_listNamespaceConstraints(login, namespaceName)
+        return self.recv_listNamespaceConstraints()
+
+    def send_listNamespaceConstraints(self, login, namespaceName):
+        self._oprot.writeMessageBegin('listNamespaceConstraints', TMessageType.CALL, self._seqid)
+        args = listNamespaceConstraints_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listNamespaceConstraints(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listNamespaceConstraints_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaceConstraints failed: unknown result")
+
+    def testNamespaceClassLoad(self, login, namespaceName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - className
+         - asTypeName
+        """
+        self.send_testNamespaceClassLoad(login, namespaceName, className, asTypeName)
+        return self.recv_testNamespaceClassLoad()
+
+    def send_testNamespaceClassLoad(self, login, namespaceName, className, asTypeName):
+        self._oprot.writeMessageBegin('testNamespaceClassLoad', TMessageType.CALL, self._seqid)
+        args = testNamespaceClassLoad_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.className = className
+        args.asTypeName = asTypeName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_testNamespaceClassLoad(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = testNamespaceClassLoad_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "testNamespaceClassLoad failed: unknown result")
+
+
+class Processor(Iface, TProcessor):
+    def __init__(self, handler):
+        self._handler = handler
+        self._processMap = {}
+        self._processMap["login"] = Processor.process_login
+        self._processMap["addConstraint"] = Processor.process_addConstraint
+        self._processMap["addSplits"] = Processor.process_addSplits
+        self._processMap["attachIterator"] = Processor.process_attachIterator
+        self._processMap["checkIteratorConflicts"] = Processor.process_checkIteratorConflicts
+        self._processMap["clearLocatorCache"] = Processor.process_clearLocatorCache
+        self._processMap["cloneTable"] = Processor.process_cloneTable
+        self._processMap["compactTable"] = Processor.process_compactTable
+        self._processMap["cancelCompaction"] = Processor.process_cancelCompaction
+        self._processMap["createTable"] = Processor.process_createTable
+        self._processMap["deleteTable"] = Processor.process_deleteTable
+        self._processMap["deleteRows"] = Processor.process_deleteRows
+        self._processMap["exportTable"] = Processor.process_exportTable
+        self._processMap["flushTable"] = Processor.process_flushTable
+        self._processMap["getDiskUsage"] = Processor.process_getDiskUsage
+        self._processMap["getLocalityGroups"] = Processor.process_getLocalityGroups
+        self._processMap["getIteratorSetting"] = Processor.process_getIteratorSetting
+        self._processMap["getMaxRow"] = Processor.process_getMaxRow
+        self._processMap["getTableProperties"] = Processor.process_getTableProperties
+        self._processMap["importDirectory"] = Processor.process_importDirectory
+        self._processMap["importTable"] = Processor.process_importTable
+        self._processMap["listSplits"] = Processor.process_listSplits
+        self._processMap["listTables"] = Processor.process_listTables
+        self._processMap["listIterators"] = Processor.process_listIterators
+        self._processMap["listConstraints"] = Processor.process_listConstraints
+        self._processMap["mergeTablets"] = Processor.process_mergeTablets
+        self._processMap["offlineTable"] = Processor.process_offlineTable
+        self._processMap["onlineTable"] = Processor.process_onlineTable
+        self._processMap["removeConstraint"] = Processor.process_removeConstraint
+        self._processMap["removeIterator"] = Processor.process_removeIterator
+        self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
+        self._processMap["renameTable"] = Processor.process_renameTable
+        self._processMap["setLocalityGroups"] = Processor.process_setLocalityGroups
+        self._processMap["setTableProperty"] = Processor.process_setTableProperty
+        self._processMap["splitRangeByTablets"] = Processor.process_splitRangeByTablets
+        self._processMap["tableExists"] = Processor.process_tableExists
+        self._processMap["tableIdMap"] = Processor.process_tableIdMap
+        self._processMap["testTableClassLoad"] = Processor.process_testTableClassLoad
+        self._processMap["pingTabletServer"] = Processor.process_pingTabletServer
+        self._processMap["getActiveScans"] = Processor.process_getActiveScans
+        self._processMap["getActiveCompactions"] = Processor.process_getActiveCompactions
+        self._processMap["getSiteConfiguration"] = Processor.process_getSiteConfiguration
+        self._processMap["getSystemConfiguration"] = Processor.process_getSystemConfiguration
+        self._processMap["getTabletServers"] = Processor.process_getTabletServers
+        self._processMap["removeProperty"] = Processor.process_removeProperty
+        self._processMap["setProperty"] = Processor.process_setProperty
+        self._processMap["testClassLoad"] = Processor.process_testClassLoad
+        self._processMap["authenticateUser"] = Processor.process_authenticateUser
+        self._processMap["changeUserAuthorizations"] = Processor.process_changeUserAuthorizations
+        self._processMap["changeLocalUserPassword"] = Processor.process_changeLocalUserPassword
+        self._processMap["createLocalUser"] = Processor.process_createLocalUser
+        self._processMap["dropLocalUser"] = Processor.process_dropLocalUser
+        self._processMap["getUserAuthorizations"] = Processor.process_getUserAuthorizations
+        self._processMap["grantSystemPermission"] = Processor.process_grantSystemPermission
+        self._processMap["grantTablePermission"] = Processor.process_grantTablePermission
+        self._processMap["hasSystemPermission"] = Processor.process_hasSystemPermission
+        self._processMap["hasTablePermission"] = Processor.process_hasTablePermission
+        self._processMap["listLocalUsers"] = Processor.process_listLocalUsers
+        self._processMap["revokeSystemPermission"] = Processor.process_revokeSystemPermission
+        self._processMap["revokeTablePermission"] = Processor.process_revokeTablePermission
+        self._processMap["grantNamespacePermission"] = Processor.process_grantNamespacePermission
+        self._processMap["hasNamespacePermission"] = Processor.process_hasNamespacePermission
+        self._processMap["revokeNamespacePermission"] = Processor.process_revokeNamespacePermission
+        self._processMap["createBatchScanner"] = Processor.process_createBatchScanner
+        self._processMap["createScanner"] = Processor.process_createScanner
+        self._processMap["hasNext"] = Processor.process_hasNext
+        self._processMap["nextEntry"] = Processor.process_nextEntry
+        self._processMap["nextK"] = Processor.process_nextK
+        self._processMap["closeScanner"] = Processor.process_closeScanner
+        self._processMap["updateAndFlush"] = Processor.process_updateAndFlush
+        self._processMap["createWriter"] = Processor.process_createWriter
+        self._processMap["update"] = Processor.process_update
+        self._processMap["flush"] = Processor.process_flush
+        self._processMap["closeWriter"] = Processor.process_closeWriter
+        self._processMap["updateRowConditionally"] = Processor.process_updateRowConditionally
+        self._processMap["createConditionalWriter"] = Processor.process_createConditionalWriter
+        self._processMap["updateRowsConditionally"] = Processor.process_updateRowsConditionally
+        self._processMap["closeConditionalWriter"] = Processor.process_closeConditionalWriter
+        self._processMap["getRowRange"] = Processor.process_getRowRange
+        self._processMap["getFollowing"] = Processor.process_getFollowing
+        self._processMap["systemNamespace"] = Processor.process_systemNamespace
+        self._processMap["defaultNamespace"] = Processor.process_defaultNamespace
+        self._processMap["listNamespaces"] = Processor.process_listNamespaces
+        self._processMap["namespaceExists"] = Processor.process_namespaceExists
+        self._processMap["createNamespace"] = Processor.process_createNamespace
+        self._processMap["deleteNamespace"] = Processor.process_deleteNamespace
+        self._processMap["renameNamespace"] = Processor.process_renameNamespace
+        self._processMap["setNamespaceProperty"] = Processor.process_setNamespaceProperty
+        self._processMap["removeNamespaceProperty"] = Processor.process_removeNamespaceProperty
+        self._processMap["getNamespaceProperties"] = Processor.process_getNamespaceProperties
+        self._processMap["namespaceIdMap"] = Processor.process_namespaceIdMap
+        self._processMap["attachNamespaceIterator"] = Processor.process_attachNamespaceIterator
+        self._processMap["removeNamespaceIterator"] = Processor.process_removeNamespaceIterator
+        self._processMap["getNamespaceIteratorSetting"] = Processor.process_getNamespaceIteratorSetting
+        self._processMap["listNamespaceIterators"] = Processor.process_listNamespaceIterators
+        self._processMap["checkNamespaceIteratorConflicts"] = Processor.process_checkNamespaceIteratorConflicts
+        self._processMap["addNamespaceConstraint"] = Processor.process_addNamespaceConstraint
+        self._processMap["removeNamespaceConstraint"] = Processor.process_removeNamespaceConstraint
+        self._processMap["listNamespaceConstraints"] = Processor.process_listNamespaceConstraints
+        self._processMap["testNamespaceClassLoad"] = Processor.process_testNamespaceClassLoad
+
+    def process(self, iprot, oprot):
+        (name, type, seqid) = iprot.readMessageBegin()
+        if name not in self._processMap:
+            iprot.skip(TType.STRUCT)
+            iprot.readMessageEnd()
+            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
+            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
+            x.write(oprot)
+            oprot.writeMessageEnd()
+            oprot.trans.flush()
+            return
+        else:
+            self._processMap[name](self, seqid, iprot, oprot)
+        return True
+
+    def process_login(self, seqid, iprot, oprot):
+        args = login_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = login_result()
+        try:
+            result.success = self._handler.login(args.principal, args.loginProperties)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("login", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_addConstraint(self, seqid, iprot, oprot):
+        args = addConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = addConstraint_result()
+        try:
+            result.success = self._handler.addConstraint(args.login, args.tableName, args.constraintClassName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("addConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_addSplits(self, seqid, iprot, oprot):
+        args = addSplits_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = addSplits_result()
+        try:
+            self._handler.addSplits(args.login, args.tableName, args.splits)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("addSplits", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_attachIterator(self, seqid, iprot, oprot):
+        args = attachIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = attachIterator_result()
+        try:
+            self._handler.attachIterator(args.login, args.tableName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("attachIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_checkIteratorConflicts(self, seqid, iprot, oprot):
+        args = checkIteratorConflicts_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = checkIteratorConflicts_result()
+        try:
+            self._handler.checkIteratorConflicts(args.login, args.tableName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("checkIteratorConflicts", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_clearLocatorCache(self, seqid, iprot, oprot):
+        args = clearLocatorCache_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = clearLocatorCache_result()
+        try:
+            self._handler.clearLocatorCache(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except TableNotFoundException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("clearLocatorCache", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_cloneTable(self, seqid, iprot, oprot):
+        args = cloneTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = cloneTable_result()
+        try:
+            self._handler.cloneTable(args.login, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except TableExistsException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("cloneTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_compactTable(self, seqid, iprot, oprot):
+        args = compactTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = compactTable_result()
+        try:
+            self._handler.compactTable(args.login, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait, args.compactionStrategy)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except TableNotFoundException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("compactTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_cancelCompaction(self, seqid, iprot, oprot):
+        args = cancelCompaction_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = cancelCompaction_result()
+        try:
+            self._handler.cancelCompaction(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except TableNotFoundException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("cancelCompaction", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createTable(self, seqid, iprot, oprot):
+        args = createTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createTable_result()
+        try:
+            self._handler.createTable(args.login, args.tableName, args.versioningIter, args.type)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableExistsException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_deleteTable(self, seqid, iprot, oprot):
+        args = deleteTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = deleteTable_result()
+        try:
+            self._handler.deleteTable(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("deleteTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_deleteRows(self, seqid, iprot, oprot):
+        args = deleteRows_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = deleteRows_result()
+        try:
+            self._handler.deleteRows(args.login, args.tableName, args.startRow, args.endRow)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("deleteRows", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_exportTable(self, seqid, iprot, oprot):
+        args = exportTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = exportTable_result()
+        try:
+            self._handler.exportTable(args.login, args.tableName, args.exportDir)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("exportTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_flushTable(self, seqid, iprot, oprot):
+        args = flushTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = flushTable_result()
+        try:
+            self._handler.flushTable(args.login, args.tableName, args.startRow, args.endRow, args.wait)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("flushTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getDiskUsage(self, seqid, iprot, oprot):
+        args = getDiskUsage_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getDiskUsage_result()
+        try:
+            result.success = self._handler.getDiskUsage(args.login, args.tables)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getDiskUsage", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getLocalityGroups(self, seqid, iprot, oprot):
+        args = getLocalityGroups_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getLocalityGroups_result()
+        try:
+            result.success = self._handler.getLocalityGroups(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getLocalityGroups", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getIteratorSetting(self, seqid, iprot, oprot):
+        args = getIteratorSetting_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getIteratorSetting_result()
+        try:
+            result.success = self._handler.getIteratorSetting(args.login, args.tableName, args.iteratorName, args.scope)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getIteratorSetting", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getMaxRow(self, seqid, iprot, oprot):
+        args = getMaxRow_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getMaxRow_result()
+        try:
+            result.success = self._handler.getMaxRow(args.login, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getMaxRow", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getTableProperties(self, seqid, iprot, oprot):
+        args = getTableProperties_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getTableProperties_result()
+        try:
+            result.success = self._handler.getTableProperties(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getTableProperties", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_importDirectory(self, seqid, iprot, oprot):
+        args = importDirectory_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = importDirectory_result()
+        try:
+            self._handler.importDirectory(args.login, args.tableName, args.importDir, args.failureDir, args.setTime)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except TableNotFoundException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except AccumuloSecurityException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("importDirectory", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_importTable(self, seqid, iprot, oprot):
+        args = importTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = importTable_result()
+        try:
+            self._handler.importTable(args.login, args.tableName, args.importDir)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except TableExistsException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("importTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listSplits(self, seqid, iprot, oprot):
+        args = listSplits_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listSplits_result()
+        try:
+            result.success = self._handler.listSplits(args.login, args.tableName, args.maxSplits)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listSplits", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listTables(self, seqid, iprot, oprot):
+        args = listTables_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listTables_result()
+        try:
+            result.success = self._handler.listTables(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listTables", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listIterators(self, seqid, iprot, oprot):
+        args = listIterators_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listIterators_result()
+        try:
+            result.success = self._handler.listIterators(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listIterators", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listConstraints(self, seqid, iprot, oprot):
+        args = listConstraints_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listConstraints_result()
+        try:
+            result.success = self._handler.listConstraints(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listConstraints", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_mergeTablets(self, seqid, iprot, oprot):
+        args = mergeTablets_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = mergeTablets_result()
+        try:
+            self._handler.mergeTablets(args.login, args.tableName, args.startRow, args.endRow)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("mergeTablets", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_offlineTable(self, seqid, iprot, oprot):
+        args = offlineTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = offlineTable_result()
+        try:
+            self._handler.offlineTable(args.login, args.tableName, args.wait)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("offlineTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_onlineTable(self, seqid, iprot, oprot):
+        args = onlineTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = onlineTable_result()
+        try:
+            self._handler.onlineTable(args.login, args.tableName, args.wait)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("onlineTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeConstraint(self, seqid, iprot, oprot):
+        args = removeConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeConstraint_result()
+        try:
+            self._handler.removeConstraint(args.login, args.tableName, args.constraint)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeIterator(self, seqid, iprot, oprot):
+        args = removeIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeIterator_result()
+        try:
+            self._handler.removeIterator(args.login, args.tableName, args.iterName, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeTableProperty(self, seqid, iprot, oprot):
+        args = removeTableProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeTableProperty_result()
+        try:
+            self._handler.removeTableProperty(args.login, args.tableName, args.property)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeTableProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_renameTable(self, seqid, iprot, oprot):
+        args = renameTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = renameTable_result()
+        try:
+            self._handler.renameTable(args.login, args.oldTableName, args.newTableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except TableExistsException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("renameTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setLocalityGroups(self, seqid, iprot, oprot):
+        args = setLocalityGroups_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setLocalityGroups_result()
+        try:
+            self._handler.setLocalityGroups(args.login, args.tableName, args.groups)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setLocalityGroups", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setTableProperty(self, seqid, iprot, oprot):
+        args = setTableProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setTableProperty_result()
+        try:
+            self._handler.setTableProperty(args.login, args.tableName, args.property, args.value)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setTableProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_splitRangeByTablets(self, seqid, iprot, oprot):
+        args = splitRangeByTablets_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = splitRangeByTablets_result()
+        try:
+            result.success = self._handler.splitRangeByTablets(args.login, args.tableName, args.range, args.maxSplits)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("splitRangeByTablets", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_tableExists(self, seqid, iprot, oprot):
+        args = tableExists_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = tableExists_result()
+        try:
+            result.success = self._handler.tableExists(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("tableExists", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_tableIdMap(self, seqid, iprot, oprot):
+        args = tableIdMap_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = tableIdMap_result()
+        try:
+            result.success = self._handler.tableIdMap(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("tableIdMap", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_testTableClassLoad(self, seqid, iprot, oprot):
+        args = testTableClassLoad_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = testTableClassLoad_result()
+        try:
+            result.success = self._handler.testTableClassLoad(args.login, args.tableName, args.className, args.asTypeName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("testTableClassLoad", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_pingTabletServer(self, seqid, iprot, oprot):
+        args = pingTabletServer_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = pingTabletServer_result()
+        try:
+            self._handler.pingTabletServer(args.login, args.tserver)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("pingTabletServer", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getActiveScans(self, seqid, iprot, oprot):
+        args = getActiveScans_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getActiveScans_result()
+        try:
+            result.success = self._handler.getActiveScans(args.login, args.tserver)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getActiveScans", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getActiveCompactions(self, seqid, iprot, oprot):
+        args = getActiveCompactions_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getActiveCompactions_result()
+        try:
+            result.success = self._handler.getActiveCompactions(args.login, args.tserver)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getActiveCompactions", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getSiteConfiguration(self, seqid, iprot, oprot):
+        args = getSiteConfiguration_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getSiteConfiguration_result()
+        try:
+            result.success = self._handler.getSiteConfiguration(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getSiteConfiguration", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getSystemConfiguration(self, seqid, iprot, oprot):
+        args = getSystemConfiguration_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getSystemConfiguration_result()
+        try:
+            result.success = self._handler.getSystemConfiguration(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getSystemConfiguration", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getTabletServers(self, seqid, iprot, oprot):
+        args = getTabletServers_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getTabletServers_result()
+        try:
+            result.success = self._handler.getTabletServers(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getTabletServers", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeProperty(self, seqid, iprot, oprot):
+        args = removeProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeProperty_result()
+        try:
+            self._handler.removeProperty(args.login, args.property)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setProperty(self, seqid, iprot, oprot):
+        args = setProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setProperty_result()
+        try:
+            self._handler.setProperty(args.login, args.property, args.value)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_testClassLoad(self, seqid, iprot, oprot):
+        args = testClassLoad_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = testClassLoad_result()
+        try:
+            result.success = self._handler.testClassLoad(args.login, args.className, args.asTypeName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("testClassLoad", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_authenticateUser(self, seqid, iprot, oprot):
+        args = authenticateUser_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = authenticateUser_result()
+        try:
+            result.success = self._handler.authenticateUser(args.login, args.user, args.properties)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("authenticateUser", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_changeUserAuthorizations(self, seqid, iprot, oprot):
+        args = changeUserAuthorizations_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = changeUserAuthorizations_result()
+        try:
+            self._handler.changeUserAuthorizations(args.login, args.user, args.authorizations)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("changeUserAuthorizations", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_changeLocalUserPassword(self, seqid, iprot, oprot):
+        args = changeLocalUserPassword_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = changeLocalUserPassword_result()
+        try:
+            self._handler.changeLocalUserPassword(args.login, args.user, args.password)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("changeLocalUserPassword", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createLocalUser(self, seqid, iprot, oprot):
+        args = createLocalUser_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createLocalUser_result()
+        try:
+            self._handler.createLocalUser(args.login, args.user, args.password)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createLocalUser", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_dropLocalUser(self, seqid, iprot, oprot):
+        args = dropLocalUser_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = dropLocalUser_result()
+        try:
+            self._handler.dropLocalUser(args.login, args.user)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("dropLocalUser", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getUserAuthorizations(self, seqid, iprot, oprot):
+        args = getUserAuthorizations_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getUserAuthorizations_result()
+        try:
+            result.success = self._handler.getUserAuthorizations(args.login, args.user)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getUserAuthorizations", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_grantSystemPermission(self, seqid, iprot, oprot):
+        args = grantSystemPermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = grantSystemPermission_result()
+        try:
+            self._handler.grantSystemPermission(args.login, args.user, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("grantSystemPermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_grantTablePermission(self, seqid, iprot, oprot):
+        args = grantTablePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = grantTablePermission_result()
+        try:
+            self._handler.grantTablePermission(args.login, args.user, args.table, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("grantTablePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasSystemPermission(self, seqid, iprot, oprot):
+        args = hasSystemPermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasSystemPermission_result()
+        try:
+            result.success = self._handler.hasSystemPermission(args.login, args.user, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasSystemPermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasTablePermission(self, seqid, iprot, oprot):
+        args = hasTablePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasTablePermission_result()
+        try:
+            result.success = self._handler.hasTablePermission(args.login, args.user, args.table, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasTablePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listLocalUsers(self, seqid, iprot, oprot):
+        args = listLocalUsers_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listLocalUsers_result()
+        try:
+            result.success = self._handler.listLocalUsers(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listLocalUsers", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_revokeSystemPermission(self, seqid, iprot, oprot):
+        args = revokeSystemPermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = revokeSystemPermission_result()
+        try:
+            self._handler.revokeSystemPermission(args.login, args.user, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("revokeSystemPermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_revokeTablePermission(self, seqid, iprot, oprot):
+        args = revokeTablePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = revokeTablePermission_result()
+        try:
+            self._handler.revokeTablePermission(args.login, args.user, args.table, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("revokeTablePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_grantNamespacePermission(self, seqid, iprot, oprot):
+        args = grantNamespacePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = grantNamespacePermission_result()
+        try:
+            self._handler.grantNamespacePermission(args.login, args.user, args.namespaceName, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("grantNamespacePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasNamespacePermission(self, seqid, iprot, oprot):
+        args = hasNamespacePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasNamespacePermission_result()
+        try:
+            result.success = self._handler.hasNamespacePermission(args.login, args.user, args.namespaceName, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasNamespacePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_revokeNamespacePermission(self, seqid, iprot, oprot):
+        args = revokeNamespacePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = revokeNamespacePermission_result()
+        try:
+            self._handler.revokeNamespacePermission(args.login, args.user, args.namespaceName, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("revokeNamespacePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createBatchScanner(self, seqid, iprot, oprot):
+        args = createBatchScanner_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createBatchScanner_result()
+        try:
+            result.success = self._handler.createBatchScanner(args.login, args.tableName, args.options)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createBatchScanner", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createScanner(self, seqid, iprot, oprot):
+        args = createScanner_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createScanner_result()
+        try:
+            result.success = self._handler.createScanner(args.login, args.tableName, args.options)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createScanner", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasNext(self, seqid, iprot, oprot):
+        args = hasNext_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasNext_result()
+        try:
+            result.success = self._handler.hasNext(args.scanner)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownScanner as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasNext", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_nextEntry(self, seqid, iprot, oprot):
+        args = nextEntry_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = nextEntry_result()
+        try:
+            result.success = self._handler.nextEntry(args.scanner)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except NoMoreEntriesException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except UnknownScanner as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("nextEntry", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_nextK(self, seqid, iprot, oprot):
+        args = nextK_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = nextK_result()
+        try:
+            result.success = self._handler.nextK(args.scanner, args.k)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except NoMoreEntriesException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except UnknownScanner as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("nextK", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_closeScanner(self, seqid, iprot, oprot):
+        args = closeScanner_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = closeScanner_result()
+        try:
+            self._handler.closeScanner(args.scanner)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownScanner as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("closeScanner", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_updateAndFlush(self, seqid, iprot, oprot):
+        args = updateAndFlush_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = updateAndFlush_result()
+        try:
+            self._handler.updateAndFlush(args.login, args.tableName, args.cells)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as outch1:
+            msg_type = TMessageType.REPLY
+            result.outch1 = outch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except MutationsRejectedException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("updateAndFlush", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createWriter(self, seqid, iprot, oprot):
+        args = createWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createWriter_result()
+        try:
+            result.success = self._handler.createWriter(args.login, args.tableName, args.opts)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as outch1:
+            msg_type = TMessageType.REPLY
+            result.outch1 = outch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_update(self, seqid, iprot, oprot):
+        args = update_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        try:
+            self._handler.update(args.writer, args.cells)
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except:
+            pass
+
+    def process_flush(self, seqid, iprot, oprot):
+        args = flush_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = flush_result()
+        try:
+            self._handler.flush(args.writer)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownWriter as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except MutationsRejectedException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("flush", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_closeWriter(self, seqid, iprot, oprot):
+        args = closeWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = closeWriter_result()
+        try:
+            self._handler.closeWriter(args.writer)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownWriter as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except MutationsRejectedException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("closeWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_updateRowConditionally(self, seqid, iprot, oprot):
+        args = updateRowConditionally_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = updateRowConditionally_result()
+        try:
+            result.success = self._handler.updateRowConditionally(args.login, args.tableName, args.row, args.updates)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("updateRowConditionally", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createConditionalWriter(self, seqid, iprot, oprot):
+        args = createConditionalWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createConditionalWriter_result()
+        try:
+            result.success = self._handler.createConditionalWriter(args.login, args.tableName, args.options)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createConditionalWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_updateRowsConditionally(self, seqid, iprot, oprot):
+        args = updateRowsConditionally_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = updateRowsConditionally_result()
+        try:
+            result.success = self._handler.updateRowsConditionally(args.conditionalWriter, args.updates)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownWriter as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("updateRowsConditionally", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_closeConditionalWriter(self, seqid, iprot, oprot):
+        args = closeConditionalWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = closeConditionalWriter_result()
+        try:
+            self._handler.closeConditionalWriter(args.conditionalWriter)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("closeConditionalWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getRowRange(self, seqid, iprot, oprot):
+        args = getRowRange_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getRowRange_result()
+        try:
+            result.success = self._handler.getRowRange(args.row)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getRowRange", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getFollowing(self, seqid, iprot, oprot):
+        args = getFollowing_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getFollowing_result()
+        try:
+            result.success = self._handler.getFollowing(args.key, args.part)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getFollowing", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_systemNamespace(self, seqid, iprot, oprot):
+        args = systemNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = systemNamespace_result()
+        try:
+            result.success = self._handler.systemNamespace()
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("systemNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_defaultNamespace(self, seqid, iprot, oprot):
+        args = defaultNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = defaultNamespace_result()
+        try:
+            result.success = self._handler.defaultNamespace()
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("defaultNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listNamespaces(self, seqid, iprot, oprot):
+        args = listNamespaces_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listNamespaces_result()
+        try:
+            result.success = self._handler.listNamespaces(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listNamespaces", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_namespaceExists(self, seqid, iprot, oprot):
+        args = namespaceExists_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = namespaceExists_result()
+        try:
+            result.success = self._handler.namespaceExists(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("namespaceExists", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createNamespace(self, seqid, iprot, oprot):
+        args = createNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createNamespace_result()
+        try:
+            self._handler.createNamespace(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceExistsException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_deleteNamespace(self, seqid, iprot, oprot):
+        args = deleteNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = deleteNamespace_result()
+        try:
+            self._handler.deleteNamespace(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except NamespaceNotEmptyException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("deleteNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_renameNamespace(self, seqid, iprot, oprot):
+        args = renameNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = renameNamespace_result()
+        try:
+            self._handler.renameNamespace(args.login, args.oldNamespaceName, args.newNamespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except NamespaceExistsException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("renameNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setNamespaceProperty(self, seqid, iprot, oprot):
+        args = setNamespaceProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setNamespaceProperty_result()
+        try:
+            self._handler.setNamespaceProperty(args.login, args.namespaceName, args.property, args.value)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setNamespaceProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeNamespaceProperty(self, seqid, iprot, oprot):
+        args = removeNamespaceProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeNamespaceProperty_result()
+        try:
+            self._handler.removeNamespaceProperty(args.login, args.namespaceName, args.property)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeNamespaceProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getNamespaceProperties(self, seqid, iprot, oprot):
+        args = getNamespaceProperties_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getNamespaceProperties_result()
+        try:
+            result.success = self._handler.getNamespaceProperties(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getNamespaceProperties", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_namespaceIdMap(self, seqid, iprot, oprot):
+        args = namespaceIdMap_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = namespaceIdMap_result()
+        try:
+            result.success = self._handler.namespaceIdMap(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("namespaceIdMap", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_attachNamespaceIterator(self, seqid, iprot, oprot):
+        args = attachNamespaceIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = attachNamespaceIterator_result()
+        try:
+            self._handler.attachNamespaceIterator(args.login, args.namespaceName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("attachNamespaceIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeNamespaceIterator(self, seqid, iprot, oprot):
+        args = removeNamespaceIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeNamespaceIterator_result()
+        try:
+            self._handler.removeNamespaceIterator(args.login, args.namespaceName, args.name, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeNamespaceIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getNamespaceIteratorSetting(self, seqid, iprot, oprot):
+        args = getNamespaceIteratorSetting_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getNamespaceIteratorSetting_result()
+        try:
+            result.success = self._handler.getNamespaceIteratorSetting(args.login, args.namespaceName, args.name, args.scope)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getNamespaceIteratorSetting", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listNamespaceIterators(self, seqid, iprot, oprot):
+        args = listNamespaceIterators_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listNamespaceIterators_result()
+        try:
+            result.success = self._handler.listNamespaceIterators(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listNamespaceIterators", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_checkNamespaceIteratorConflicts(self, seqid, iprot, oprot):
+        args = checkNamespaceIteratorConflicts_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = checkNamespaceIteratorConflicts_result()
+        try:
+            self._handler.checkNamespaceIteratorConflicts(args.login, args.namespaceName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("checkNamespaceIteratorConflicts", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_addNamespaceConstraint(self, seqid, iprot, oprot):
+        args = addNamespaceConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = addNamespaceConstraint_result()
+        try:
+            result.success = self._handler.addNamespaceConstraint(args.login, args.namespaceName, args.constraintClassName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("addNamespaceConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeNamespaceConstraint(self, seqid, iprot, oprot):
+        args = removeNamespaceConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeNamespaceConstraint_result()
+        try:
+            self._handler.removeNamespaceConstraint(args.login, args.namespaceName, args.id)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeNamespaceConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listNamespaceConstraints(self, seqid, iprot, oprot):
+        args = listNamespaceConstraints_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listNamespaceConstraints_result()
+        try:
+            result.success = self._handler.listNamespaceConstraints(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listNamespaceConstraints", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_testNamespaceClassLoad(self, seqid, iprot, oprot):
+        args = testNamespaceClassLoad_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = testNamespaceClassLoad_result()
+        try:
+            result.success = self._handler.testNamespaceClassLoad(args.login, args.namespaceName, args.className, args.asTypeName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("testNamespaceClassLoad", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+# HELPER FUNCTIONS AND STRUCTURES
+
+
+class login_args(object):
     """
-    Parameters:
+    Attributes:
      - principal
      - loginProperties
     """
-    pass
 
-  def addConstraint(self, login, tableName, constraintClassName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'principal', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'loginProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
+    )
+
+    def __init__(self, principal=None, loginProperties=None,):
+        self.principal = principal
+        self.loginProperties = loginProperties
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.principal = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.loginProperties = {}
+                    (_ktype145, _vtype146, _size144) = iprot.readMapBegin()
+                    for _i148 in range(_size144):
+                        _key149 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val150 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.loginProperties[_key149] = _val150
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('login_args')
+        if self.principal is not None:
+            oprot.writeFieldBegin('principal', TType.STRING, 1)
+            oprot.writeString(self.principal.encode('utf-8') if sys.version_info[0] == 2 else self.principal)
+            oprot.writeFieldEnd()
+        if self.loginProperties is not None:
+            oprot.writeFieldBegin('loginProperties', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.loginProperties))
+            for kiter151, viter152 in list(self.loginProperties.items()):
+                oprot.writeString(kiter151.encode('utf-8') if sys.version_info[0] == 2 else kiter151)
+                oprot.writeString(viter152.encode('utf-8') if sys.version_info[0] == 2 else viter152)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class login_result(object):
+    """
+    Attributes:
+     - success
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
+        (1, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, success=None, ouch2=None,):
+        self.success = success
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('login_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeBinary(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 1)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addConstraint_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - constraintClassName
     """
-    pass
 
-  def addSplits(self, login, tableName, splits):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'constraintClassName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, constraintClassName=None,):
+        self.login = login
+        self.tableName = tableName
+        self.constraintClassName = constraintClassName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.constraintClassName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.constraintClassName is not None:
+            oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
+            oprot.writeString(self.constraintClassName.encode('utf-8') if sys.version_info[0] == 2 else self.constraintClassName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addConstraint_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.I32, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addConstraint_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addSplits_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - splits
     """
-    pass
 
-  def attachIterator(self, login, tableName, setting, scopes):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.SET, 'splits', (TType.STRING, 'BINARY', False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, splits=None,):
+        self.login = login
+        self.tableName = tableName
+        self.splits = splits
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.SET:
+                    self.splits = set()
+                    (_etype156, _size153) = iprot.readSetBegin()
+                    for _i157 in range(_size153):
+                        _elem158 = iprot.readBinary()
+                        self.splits.add(_elem158)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addSplits_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.splits is not None:
+            oprot.writeFieldBegin('splits', TType.SET, 3)
+            oprot.writeSetBegin(TType.STRING, len(self.splits))
+            for iter159 in self.splits:
+                oprot.writeBinary(iter159)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addSplits_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addSplits_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class attachIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - setting
      - scopes
     """
-    pass
 
-  def checkIteratorConflicts(self, login, tableName, setting, scopes):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
+        self.login = login
+        self.tableName = tableName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype163, _size160) = iprot.readSetBegin()
+                    for _i164 in range(_size160):
+                        _elem165 = iprot.readI32()
+                        self.scopes.add(_elem165)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter166 in self.scopes:
+                oprot.writeI32(iter166)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class attachIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class checkIteratorConflicts_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - setting
      - scopes
     """
-    pass
 
-  def clearLocatorCache(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
+        self.login = login
+        self.tableName = tableName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype170, _size167) = iprot.readSetBegin()
+                    for _i171 in range(_size167):
+                        _elem172 = iprot.readI32()
+                        self.scopes.add(_elem172)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkIteratorConflicts_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter173 in self.scopes:
+                oprot.writeI32(iter173)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class checkIteratorConflicts_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkIteratorConflicts_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class clearLocatorCache_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('clearLocatorCache_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class clearLocatorCache_result(object):
+    """
+    Attributes:
+     - ouch1
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, ouch1=None,):
+        self.ouch1 = ouch1
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = TableNotFoundException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('clearLocatorCache_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cloneTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - newTableName
@@ -82,11 +8509,237 @@
      - propertiesToSet
      - propertiesToExclude
     """
-    pass
 
-  def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'newTableName', 'UTF8', None, ),  # 3
+        (4, TType.BOOL, 'flush', None, None, ),  # 4
+        (5, TType.MAP, 'propertiesToSet', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
+        (6, TType.SET, 'propertiesToExclude', (TType.STRING, 'UTF8', False), None, ),  # 6
+    )
+
+    def __init__(self, login=None, tableName=None, newTableName=None, flush=None, propertiesToSet=None, propertiesToExclude=None,):
+        self.login = login
+        self.tableName = tableName
+        self.newTableName = newTableName
+        self.flush = flush
+        self.propertiesToSet = propertiesToSet
+        self.propertiesToExclude = propertiesToExclude
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.newTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.BOOL:
+                    self.flush = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.MAP:
+                    self.propertiesToSet = {}
+                    (_ktype175, _vtype176, _size174) = iprot.readMapBegin()
+                    for _i178 in range(_size174):
+                        _key179 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val180 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.propertiesToSet[_key179] = _val180
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.SET:
+                    self.propertiesToExclude = set()
+                    (_etype184, _size181) = iprot.readSetBegin()
+                    for _i185 in range(_size181):
+                        _elem186 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.propertiesToExclude.add(_elem186)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cloneTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.newTableName is not None:
+            oprot.writeFieldBegin('newTableName', TType.STRING, 3)
+            oprot.writeString(self.newTableName.encode('utf-8') if sys.version_info[0] == 2 else self.newTableName)
+            oprot.writeFieldEnd()
+        if self.flush is not None:
+            oprot.writeFieldBegin('flush', TType.BOOL, 4)
+            oprot.writeBool(self.flush)
+            oprot.writeFieldEnd()
+        if self.propertiesToSet is not None:
+            oprot.writeFieldBegin('propertiesToSet', TType.MAP, 5)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.propertiesToSet))
+            for kiter187, viter188 in list(self.propertiesToSet.items()):
+                oprot.writeString(kiter187.encode('utf-8') if sys.version_info[0] == 2 else kiter187)
+                oprot.writeString(viter188.encode('utf-8') if sys.version_info[0] == 2 else viter188)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.propertiesToExclude is not None:
+            oprot.writeFieldBegin('propertiesToExclude', TType.SET, 6)
+            oprot.writeSetBegin(TType.STRING, len(self.propertiesToExclude))
+            for iter189 in self.propertiesToExclude:
+                oprot.writeString(iter189.encode('utf-8') if sys.version_info[0] == 2 else iter189)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cloneTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = TableExistsException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cloneTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class compactTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
@@ -94,86 +8747,1860 @@
      - iterators
      - flush
      - wait
+     - compactionStrategy
     """
-    pass
 
-  def cancelCompaction(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+        (5, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 5
+        (6, TType.BOOL, 'flush', None, None, ),  # 6
+        (7, TType.BOOL, 'wait', None, None, ),  # 7
+        (8, TType.STRUCT, 'compactionStrategy', (CompactionStrategyConfig, CompactionStrategyConfig.thrift_spec), None, ),  # 8
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None, iterators=None, flush=None, wait=None, compactionStrategy=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+        self.iterators = iterators
+        self.flush = flush
+        self.wait = wait
+        self.compactionStrategy = compactionStrategy
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype193, _size190) = iprot.readListBegin()
+                    for _i194 in range(_size190):
+                        _elem195 = IteratorSetting()
+                        _elem195.read(iprot)
+                        self.iterators.append(_elem195)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.BOOL:
+                    self.flush = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.STRUCT:
+                    self.compactionStrategy = CompactionStrategyConfig()
+                    self.compactionStrategy.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('compactTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 5)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter196 in self.iterators:
+                iter196.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.flush is not None:
+            oprot.writeFieldBegin('flush', TType.BOOL, 6)
+            oprot.writeBool(self.flush)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 7)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        if self.compactionStrategy is not None:
+            oprot.writeFieldBegin('compactionStrategy', TType.STRUCT, 8)
+            self.compactionStrategy.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class compactTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = TableNotFoundException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('compactTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cancelCompaction_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def createTable(self, login, tableName, versioningIter, type):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cancelCompaction_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cancelCompaction_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = TableNotFoundException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cancelCompaction_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - versioningIter
      - type
     """
-    pass
 
-  def deleteTable(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.BOOL, 'versioningIter', None, None, ),  # 3
+        (4, TType.I32, 'type', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, versioningIter=None, type=None,):
+        self.login = login
+        self.tableName = tableName
+        self.versioningIter = versioningIter
+        self.type = type
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.BOOL:
+                    self.versioningIter = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.type = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.versioningIter is not None:
+            oprot.writeFieldBegin('versioningIter', TType.BOOL, 3)
+            oprot.writeBool(self.versioningIter)
+            oprot.writeFieldEnd()
+        if self.type is not None:
+            oprot.writeFieldBegin('type', TType.I32, 4)
+            oprot.writeI32(self.type)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableExistsException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def deleteRows(self, login, tableName, startRow, endRow):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteRows_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
      - endRow
     """
-    pass
 
-  def exportTable(self, login, tableName, exportDir):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteRows_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteRows_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteRows_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class exportTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - exportDir
     """
-    pass
 
-  def flushTable(self, login, tableName, startRow, endRow, wait):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'exportDir', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, exportDir=None,):
+        self.login = login
+        self.tableName = tableName
+        self.exportDir = exportDir
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.exportDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('exportTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.exportDir is not None:
+            oprot.writeFieldBegin('exportDir', TType.STRING, 3)
+            oprot.writeString(self.exportDir.encode('utf-8') if sys.version_info[0] == 2 else self.exportDir)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class exportTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('exportTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flushTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
      - endRow
      - wait
     """
-    pass
 
-  def getLocalityGroups(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+        (5, TType.BOOL, 'wait', None, None, ),  # 5
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None, wait=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+        self.wait = wait
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flushTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 5)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flushTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flushTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getDiskUsage_args(object):
+    """
+    Attributes:
+     - login
+     - tables
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.SET, 'tables', (TType.STRING, 'UTF8', False), None, ),  # 2
+    )
+
+    def __init__(self, login=None, tables=None,):
+        self.login = login
+        self.tables = tables
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.SET:
+                    self.tables = set()
+                    (_etype200, _size197) = iprot.readSetBegin()
+                    for _i201 in range(_size197):
+                        _elem202 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.tables.add(_elem202)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getDiskUsage_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tables is not None:
+            oprot.writeFieldBegin('tables', TType.SET, 2)
+            oprot.writeSetBegin(TType.STRING, len(self.tables))
+            for iter203 in self.tables:
+                oprot.writeString(iter203.encode('utf-8') if sys.version_info[0] == 2 else iter203)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getDiskUsage_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRUCT, (DiskUsage, DiskUsage.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype207, _size204) = iprot.readListBegin()
+                    for _i208 in range(_size204):
+                        _elem209 = DiskUsage()
+                        _elem209.read(iprot)
+                        self.success.append(_elem209)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getDiskUsage_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRUCT, len(self.success))
+            for iter210 in self.success:
+                iter210.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getLocalityGroups_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def getIteratorSetting(self, login, tableName, iteratorName, scope):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getLocalityGroups_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getLocalityGroups_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype212, _vtype213, _size211) = iprot.readMapBegin()
+                    for _i215 in range(_size211):
+                        _key216 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val217 = set()
+                        (_etype221, _size218) = iprot.readSetBegin()
+                        for _i222 in range(_size218):
+                            _elem223 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                            _val217.add(_elem223)
+                        iprot.readSetEnd()
+                        self.success[_key216] = _val217
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getLocalityGroups_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
+            for kiter224, viter225 in list(self.success.items()):
+                oprot.writeString(kiter224.encode('utf-8') if sys.version_info[0] == 2 else kiter224)
+                oprot.writeSetBegin(TType.STRING, len(viter225))
+                for iter226 in viter225:
+                    oprot.writeString(iter226.encode('utf-8') if sys.version_info[0] == 2 else iter226)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getIteratorSetting_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - iteratorName
      - scope
     """
-    pass
 
-  def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'iteratorName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'scope', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, iteratorName=None, scope=None,):
+        self.login = login
+        self.tableName = tableName
+        self.iteratorName = iteratorName
+        self.scope = scope
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.iteratorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.scope = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getIteratorSetting_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.iteratorName is not None:
+            oprot.writeFieldBegin('iteratorName', TType.STRING, 3)
+            oprot.writeString(self.iteratorName.encode('utf-8') if sys.version_info[0] == 2 else self.iteratorName)
+            oprot.writeFieldEnd()
+        if self.scope is not None:
+            oprot.writeFieldBegin('scope', TType.I32, 4)
+            oprot.writeI32(self.scope)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getIteratorSetting_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = IteratorSetting()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getIteratorSetting_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getMaxRow_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - auths
@@ -182,16013 +10609,13842 @@
      - endRow
      - endInclusive
     """
-    pass
 
-  def getTableProperties(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    pass
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.SET, 'auths', (TType.STRING, 'BINARY', False), None, ),  # 3
+        (4, TType.STRING, 'startRow', 'BINARY', None, ),  # 4
+        (5, TType.BOOL, 'startInclusive', None, None, ),  # 5
+        (6, TType.STRING, 'endRow', 'BINARY', None, ),  # 6
+        (7, TType.BOOL, 'endInclusive', None, None, ),  # 7
+    )
+
+    def __init__(self, login=None, tableName=None, auths=None, startRow=None, startInclusive=None, endRow=None, endInclusive=None,):
+        self.login = login
+        self.tableName = tableName
+        self.auths = auths
+        self.startRow = startRow
+        self.startInclusive = startInclusive
+        self.endRow = endRow
+        self.endInclusive = endInclusive
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.SET:
+                    self.auths = set()
+                    (_etype230, _size227) = iprot.readSetBegin()
+                    for _i231 in range(_size227):
+                        _elem232 = iprot.readBinary()
+                        self.auths.add(_elem232)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.BOOL:
+                    self.startInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.BOOL:
+                    self.endInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getMaxRow_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.auths is not None:
+            oprot.writeFieldBegin('auths', TType.SET, 3)
+            oprot.writeSetBegin(TType.STRING, len(self.auths))
+            for iter233 in self.auths:
+                oprot.writeBinary(iter233)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 4)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.startInclusive is not None:
+            oprot.writeFieldBegin('startInclusive', TType.BOOL, 5)
+            oprot.writeBool(self.startInclusive)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 6)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.endInclusive is not None:
+            oprot.writeFieldBegin('endInclusive', TType.BOOL, 7)
+            oprot.writeBool(self.endInclusive)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getMaxRow_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getMaxRow_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeBinary(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def getSplits(self, login, tableName, maxSplits):
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTableProperties_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
-     - maxSplits
     """
-    pass
 
-  def importDirectory(self, login, tableName, importDir, failureDir, setTime):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTableProperties_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTableProperties_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype235, _vtype236, _size234) = iprot.readMapBegin()
+                    for _i238 in range(_size234):
+                        _key239 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val240 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key239] = _val240
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTableProperties_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter241, viter242 in list(self.success.items()):
+                oprot.writeString(kiter241.encode('utf-8') if sys.version_info[0] == 2 else kiter241)
+                oprot.writeString(viter242.encode('utf-8') if sys.version_info[0] == 2 else viter242)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importDirectory_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - importDir
      - failureDir
      - setTime
     """
-    pass
 
-  def importTable(self, login, tableName, importDir):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'importDir', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'failureDir', 'UTF8', None, ),  # 4
+        (5, TType.BOOL, 'setTime', None, None, ),  # 5
+    )
+
+    def __init__(self, login=None, tableName=None, importDir=None, failureDir=None, setTime=None,):
+        self.login = login
+        self.tableName = tableName
+        self.importDir = importDir
+        self.failureDir = failureDir
+        self.setTime = setTime
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.importDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.failureDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.BOOL:
+                    self.setTime = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importDirectory_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.importDir is not None:
+            oprot.writeFieldBegin('importDir', TType.STRING, 3)
+            oprot.writeString(self.importDir.encode('utf-8') if sys.version_info[0] == 2 else self.importDir)
+            oprot.writeFieldEnd()
+        if self.failureDir is not None:
+            oprot.writeFieldBegin('failureDir', TType.STRING, 4)
+            oprot.writeString(self.failureDir.encode('utf-8') if sys.version_info[0] == 2 else self.failureDir)
+            oprot.writeFieldEnd()
+        if self.setTime is not None:
+            oprot.writeFieldBegin('setTime', TType.BOOL, 5)
+            oprot.writeBool(self.setTime)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importDirectory_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch4', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = TableNotFoundException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = AccumuloSecurityException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importDirectory_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 2)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 3)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - importDir
     """
-    pass
 
-  def listTables(self, login):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'importDir', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, importDir=None,):
+        self.login = login
+        self.tableName = tableName
+        self.importDir = importDir
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.importDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.importDir is not None:
+            oprot.writeFieldBegin('importDir', TType.STRING, 3)
+            oprot.writeString(self.importDir.encode('utf-8') if sys.version_info[0] == 2 else self.importDir)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = TableExistsException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listSplits_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - tableName
+     - maxSplits
     """
-    pass
 
-  def listIterators(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'maxSplits', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, maxSplits=None,):
+        self.login = login
+        self.tableName = tableName
+        self.maxSplits = maxSplits
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.maxSplits = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listSplits_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.maxSplits is not None:
+            oprot.writeFieldBegin('maxSplits', TType.I32, 3)
+            oprot.writeI32(self.maxSplits)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listSplits_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'BINARY', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype246, _size243) = iprot.readListBegin()
+                    for _i247 in range(_size243):
+                        _elem248 = iprot.readBinary()
+                        self.success.append(_elem248)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listSplits_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter249 in self.success:
+                oprot.writeBinary(iter249)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listTables_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listTables_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listTables_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.SET:
+                    self.success = set()
+                    (_etype253, _size250) = iprot.readSetBegin()
+                    for _i254 in range(_size250):
+                        _elem255 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.add(_elem255)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listTables_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.SET, 0)
+            oprot.writeSetBegin(TType.STRING, len(self.success))
+            for iter256 in self.success:
+                oprot.writeString(iter256.encode('utf-8') if sys.version_info[0] == 2 else iter256)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listIterators_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def listConstraints(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listIterators_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listIterators_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.I32, None, False), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype258, _vtype259, _size257) = iprot.readMapBegin()
+                    for _i261 in range(_size257):
+                        _key262 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val263 = set()
+                        (_etype267, _size264) = iprot.readSetBegin()
+                        for _i268 in range(_size264):
+                            _elem269 = iprot.readI32()
+                            _val263.add(_elem269)
+                        iprot.readSetEnd()
+                        self.success[_key262] = _val263
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listIterators_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
+            for kiter270, viter271 in list(self.success.items()):
+                oprot.writeString(kiter270.encode('utf-8') if sys.version_info[0] == 2 else kiter270)
+                oprot.writeSetBegin(TType.I32, len(viter271))
+                for iter272 in viter271:
+                    oprot.writeI32(iter272)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listConstraints_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def mergeTablets(self, login, tableName, startRow, endRow):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listConstraints_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listConstraints_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype274, _vtype275, _size273) = iprot.readMapBegin()
+                    for _i277 in range(_size273):
+                        _key278 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val279 = iprot.readI32()
+                        self.success[_key278] = _val279
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listConstraints_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
+            for kiter280, viter281 in list(self.success.items()):
+                oprot.writeString(kiter280.encode('utf-8') if sys.version_info[0] == 2 else kiter280)
+                oprot.writeI32(viter281)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class mergeTablets_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
      - endRow
     """
-    pass
 
-  def offlineTable(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('mergeTablets_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class mergeTablets_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('mergeTablets_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class offlineTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
+     - wait
     """
-    pass
 
-  def onlineTable(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.BOOL, 'wait', None, False, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, wait=thrift_spec[3][4],):
+        self.login = login
+        self.tableName = tableName
+        self.wait = wait
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('offlineTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 3)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class offlineTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('offlineTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class onlineTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
+     - wait
     """
-    pass
 
-  def removeConstraint(self, login, tableName, constraint):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.BOOL, 'wait', None, False, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, wait=thrift_spec[3][4],):
+        self.login = login
+        self.tableName = tableName
+        self.wait = wait
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('onlineTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 3)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class onlineTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('onlineTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeConstraint_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - constraint
     """
-    pass
 
-  def removeIterator(self, login, tableName, iterName, scopes):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'constraint', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, constraint=None,):
+        self.login = login
+        self.tableName = tableName
+        self.constraint = constraint
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.constraint = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.constraint is not None:
+            oprot.writeFieldBegin('constraint', TType.I32, 3)
+            oprot.writeI32(self.constraint)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeConstraint_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeConstraint_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - iterName
      - scopes
     """
-    pass
 
-  def removeTableProperty(self, login, tableName, property):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'iterName', 'UTF8', None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, iterName=None, scopes=None,):
+        self.login = login
+        self.tableName = tableName
+        self.iterName = iterName
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.iterName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype285, _size282) = iprot.readSetBegin()
+                    for _i286 in range(_size282):
+                        _elem287 = iprot.readI32()
+                        self.scopes.add(_elem287)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.iterName is not None:
+            oprot.writeFieldBegin('iterName', TType.STRING, 3)
+            oprot.writeString(self.iterName.encode('utf-8') if sys.version_info[0] == 2 else self.iterName)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter288 in self.scopes:
+                oprot.writeI32(iter288)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeTableProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - property
     """
-    pass
 
-  def renameTable(self, login, oldTableName, newTableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, property=None,):
+        self.login = login
+        self.tableName = tableName
+        self.property = property
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeTableProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeTableProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeTableProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - oldTableName
      - newTableName
     """
-    pass
 
-  def setLocalityGroups(self, login, tableName, groups):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'oldTableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'newTableName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, oldTableName=None, newTableName=None,):
+        self.login = login
+        self.oldTableName = oldTableName
+        self.newTableName = newTableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.oldTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.newTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.oldTableName is not None:
+            oprot.writeFieldBegin('oldTableName', TType.STRING, 2)
+            oprot.writeString(self.oldTableName.encode('utf-8') if sys.version_info[0] == 2 else self.oldTableName)
+            oprot.writeFieldEnd()
+        if self.newTableName is not None:
+            oprot.writeFieldBegin('newTableName', TType.STRING, 3)
+            oprot.writeString(self.newTableName.encode('utf-8') if sys.version_info[0] == 2 else self.newTableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = TableExistsException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setLocalityGroups_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - groups
     """
-    pass
 
-  def setTableProperty(self, login, tableName, property, value):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.MAP, 'groups', (TType.STRING, 'UTF8', TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, groups=None,):
+        self.login = login
+        self.tableName = tableName
+        self.groups = groups
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.MAP:
+                    self.groups = {}
+                    (_ktype290, _vtype291, _size289) = iprot.readMapBegin()
+                    for _i293 in range(_size289):
+                        _key294 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val295 = set()
+                        (_etype299, _size296) = iprot.readSetBegin()
+                        for _i300 in range(_size296):
+                            _elem301 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                            _val295.add(_elem301)
+                        iprot.readSetEnd()
+                        self.groups[_key294] = _val295
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setLocalityGroups_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.groups is not None:
+            oprot.writeFieldBegin('groups', TType.MAP, 3)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.groups))
+            for kiter302, viter303 in list(self.groups.items()):
+                oprot.writeString(kiter302.encode('utf-8') if sys.version_info[0] == 2 else kiter302)
+                oprot.writeSetBegin(TType.STRING, len(viter303))
+                for iter304 in viter303:
+                    oprot.writeString(iter304.encode('utf-8') if sys.version_info[0] == 2 else iter304)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setLocalityGroups_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setLocalityGroups_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setTableProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - property
      - value
     """
-    pass
 
-  def splitRangeByTablets(self, login, tableName, range, maxSplits):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, property=None, value=None,):
+        self.login = login
+        self.tableName = tableName
+        self.property = property
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setTableProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 4)
+            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setTableProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setTableProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class splitRangeByTablets_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - range
      - maxSplits
     """
-    pass
 
-  def tableExists(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ),  # 3
+        (4, TType.I32, 'maxSplits', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, range=None, maxSplits=None,):
+        self.login = login
+        self.tableName = tableName
+        self.range = range
+        self.maxSplits = maxSplits
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.range = Range()
+                    self.range.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.maxSplits = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('splitRangeByTablets_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.range is not None:
+            oprot.writeFieldBegin('range', TType.STRUCT, 3)
+            self.range.write(oprot)
+            oprot.writeFieldEnd()
+        if self.maxSplits is not None:
+            oprot.writeFieldBegin('maxSplits', TType.I32, 4)
+            oprot.writeI32(self.maxSplits)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class splitRangeByTablets_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.SET, 'success', (TType.STRUCT, (Range, Range.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.SET:
+                    self.success = set()
+                    (_etype308, _size305) = iprot.readSetBegin()
+                    for _i309 in range(_size305):
+                        _elem310 = Range()
+                        _elem310.read(iprot)
+                        self.success.add(_elem310)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('splitRangeByTablets_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.SET, 0)
+            oprot.writeSetBegin(TType.STRUCT, len(self.success))
+            for iter311 in self.success:
+                iter311.write(oprot)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableExists_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def tableIdMap(self, login):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableExists_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableExists_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableExists_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableIdMap_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableIdMap_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableIdMap_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype313, _vtype314, _size312) = iprot.readMapBegin()
+                    for _i316 in range(_size312):
+                        _key317 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val318 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key317] = _val318
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableIdMap_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter319, viter320 in list(self.success.items()):
+                oprot.writeString(kiter319.encode('utf-8') if sys.version_info[0] == 2 else kiter319)
+                oprot.writeString(viter320.encode('utf-8') if sys.version_info[0] == 2 else viter320)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testTableClassLoad_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - tableName
+     - className
+     - asTypeName
     """
-    pass
 
-  def pingTabletServer(self, login, tserver):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, className=None, asTypeName=None,):
+        self.login = login
+        self.tableName = tableName
+        self.className = className
+        self.asTypeName = asTypeName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.asTypeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testTableClassLoad_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 3)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.asTypeName is not None:
+            oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
+            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testTableClassLoad_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testTableClassLoad_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class pingTabletServer_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tserver
     """
-    pass
 
-  def getActiveScans(self, login, tserver):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tserver=None,):
+        self.login = login
+        self.tserver = tserver
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tserver = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('pingTabletServer_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tserver is not None:
+            oprot.writeFieldBegin('tserver', TType.STRING, 2)
+            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class pingTabletServer_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('pingTabletServer_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveScans_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tserver
     """
-    pass
 
-  def getActiveCompactions(self, login, tserver):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tserver=None,):
+        self.login = login
+        self.tserver = tserver
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tserver = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveScans_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tserver is not None:
+            oprot.writeFieldBegin('tserver', TType.STRING, 2)
+            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveScans_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRUCT, (ActiveScan, ActiveScan.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype324, _size321) = iprot.readListBegin()
+                    for _i325 in range(_size321):
+                        _elem326 = ActiveScan()
+                        _elem326.read(iprot)
+                        self.success.append(_elem326)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveScans_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRUCT, len(self.success))
+            for iter327 in self.success:
+                iter327.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveCompactions_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tserver
     """
-    pass
 
-  def getSiteConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    pass
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tserver=None,):
+        self.login = login
+        self.tserver = tserver
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tserver = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveCompactions_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tserver is not None:
+            oprot.writeFieldBegin('tserver', TType.STRING, 2)
+            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveCompactions_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRUCT, (ActiveCompaction, ActiveCompaction.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype331, _size328) = iprot.readListBegin()
+                    for _i332 in range(_size328):
+                        _elem333 = ActiveCompaction()
+                        _elem333.read(iprot)
+                        self.success.append(_elem333)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveCompactions_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRUCT, len(self.success))
+            for iter334 in self.success:
+                iter334.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSiteConfiguration_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSiteConfiguration_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSiteConfiguration_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype336, _vtype337, _size335) = iprot.readMapBegin()
+                    for _i339 in range(_size335):
+                        _key340 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val341 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key340] = _val341
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSiteConfiguration_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter342, viter343 in list(self.success.items()):
+                oprot.writeString(kiter342.encode('utf-8') if sys.version_info[0] == 2 else kiter342)
+                oprot.writeString(viter343.encode('utf-8') if sys.version_info[0] == 2 else viter343)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSystemConfiguration_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSystemConfiguration_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSystemConfiguration_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype345, _vtype346, _size344) = iprot.readMapBegin()
+                    for _i348 in range(_size344):
+                        _key349 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val350 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key349] = _val350
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSystemConfiguration_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter351, viter352 in list(self.success.items()):
+                oprot.writeString(kiter351.encode('utf-8') if sys.version_info[0] == 2 else kiter351)
+                oprot.writeString(viter352.encode('utf-8') if sys.version_info[0] == 2 else viter352)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTabletServers_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTabletServers_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTabletServers_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype356, _size353) = iprot.readListBegin()
+                    for _i357 in range(_size353):
+                        _elem358 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.append(_elem358)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTabletServers_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter359 in self.success:
+                oprot.writeString(iter359.encode('utf-8') if sys.version_info[0] == 2 else iter359)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def getSystemConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    pass
+    def __ne__(self, other):
+        return not (self == other)
 
-  def getTabletServers(self, login):
-    """
-    Parameters:
-     - login
-    """
-    pass
 
-  def removeProperty(self, login, property):
+class removeProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - property
     """
-    pass
 
-  def setProperty(self, login, property, value):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'property', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, property=None,):
+        self.login = login
+        self.property = property
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 2)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - property
      - value
     """
-    pass
 
-  def testClassLoad(self, login, className, asTypeName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'property', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, property=None, value=None,):
+        self.login = login
+        self.property = property
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 2)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 3)
+            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testClassLoad_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - className
      - asTypeName
     """
-    pass
 
-  def authenticateUser(self, login, user, properties):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, className=None, asTypeName=None,):
+        self.login = login
+        self.className = className
+        self.asTypeName = asTypeName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.asTypeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testClassLoad_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 2)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.asTypeName is not None:
+            oprot.writeFieldBegin('asTypeName', TType.STRING, 3)
+            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testClassLoad_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testClassLoad_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class authenticateUser_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - properties
     """
-    pass
 
-  def changeUserAuthorizations(self, login, user, authorizations):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, properties=None,):
+        self.login = login
+        self.user = user
+        self.properties = properties
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.MAP:
+                    self.properties = {}
+                    (_ktype361, _vtype362, _size360) = iprot.readMapBegin()
+                    for _i364 in range(_size360):
+                        _key365 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val366 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.properties[_key365] = _val366
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('authenticateUser_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.properties is not None:
+            oprot.writeFieldBegin('properties', TType.MAP, 3)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
+            for kiter367, viter368 in list(self.properties.items()):
+                oprot.writeString(kiter367.encode('utf-8') if sys.version_info[0] == 2 else kiter367)
+                oprot.writeString(viter368.encode('utf-8') if sys.version_info[0] == 2 else viter368)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class authenticateUser_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('authenticateUser_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeUserAuthorizations_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - authorizations
     """
-    pass
 
-  def changeLocalUserPassword(self, login, user, password):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, authorizations=None,):
+        self.login = login
+        self.user = user
+        self.authorizations = authorizations
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype372, _size369) = iprot.readSetBegin()
+                    for _i373 in range(_size369):
+                        _elem374 = iprot.readBinary()
+                        self.authorizations.add(_elem374)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeUserAuthorizations_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 3)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter375 in self.authorizations:
+                oprot.writeBinary(iter375)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeUserAuthorizations_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeUserAuthorizations_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeLocalUserPassword_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - password
     """
-    pass
 
-  def createLocalUser(self, login, user, password):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'password', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, password=None,):
+        self.login = login
+        self.user = user
+        self.password = password
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.password = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeLocalUserPassword_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.password is not None:
+            oprot.writeFieldBegin('password', TType.STRING, 3)
+            oprot.writeBinary(self.password)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeLocalUserPassword_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeLocalUserPassword_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createLocalUser_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - password
     """
-    pass
 
-  def dropLocalUser(self, login, user):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'password', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, password=None,):
+        self.login = login
+        self.user = user
+        self.password = password
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.password = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createLocalUser_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.password is not None:
+            oprot.writeFieldBegin('password', TType.STRING, 3)
+            oprot.writeBinary(self.password)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createLocalUser_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createLocalUser_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class dropLocalUser_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
     """
-    pass
 
-  def getUserAuthorizations(self, login, user):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, user=None,):
+        self.login = login
+        self.user = user
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('dropLocalUser_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class dropLocalUser_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('dropLocalUser_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getUserAuthorizations_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
     """
-    pass
 
-  def grantSystemPermission(self, login, user, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, user=None,):
+        self.login = login
+        self.user = user
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getUserAuthorizations_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getUserAuthorizations_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'BINARY', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype379, _size376) = iprot.readListBegin()
+                    for _i380 in range(_size376):
+                        _elem381 = iprot.readBinary()
+                        self.success.append(_elem381)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getUserAuthorizations_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter382 in self.success:
+                oprot.writeBinary(iter382)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantSystemPermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - perm
     """
-    pass
 
-  def grantTablePermission(self, login, user, table, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'perm', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantSystemPermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 3)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantSystemPermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantSystemPermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantTablePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - table
      - perm
     """
-    pass
 
-  def hasSystemPermission(self, login, user, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, table=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.table = table
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantTablePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantTablePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantTablePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasSystemPermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - perm
     """
-    pass
 
-  def hasTablePermission(self, login, user, table, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'perm', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasSystemPermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 3)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasSystemPermission_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasSystemPermission_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasTablePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - table
      - perm
     """
-    pass
 
-  def listLocalUsers(self, login):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, table=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.table = table
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasTablePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasTablePermission_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasTablePermission_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listLocalUsers_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listLocalUsers_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listLocalUsers_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.SET:
+                    self.success = set()
+                    (_etype386, _size383) = iprot.readSetBegin()
+                    for _i387 in range(_size383):
+                        _elem388 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.add(_elem388)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listLocalUsers_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.SET, 0)
+            oprot.writeSetBegin(TType.STRING, len(self.success))
+            for iter389 in self.success:
+                oprot.writeString(iter389.encode('utf-8') if sys.version_info[0] == 2 else iter389)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeSystemPermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - user
+     - perm
     """
-    pass
 
-  def revokeSystemPermission(self, login, user, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'perm', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeSystemPermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 3)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeSystemPermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeSystemPermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeTablePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
+     - table
      - perm
     """
-    pass
 
-  def revokeTablePermission(self, login, user, table, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, table=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.table = table
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeTablePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeTablePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeTablePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantNamespacePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
-     - table
+     - namespaceName
      - perm
     """
-    pass
 
-  def createBatchScanner(self, login, tableName, options):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, namespaceName=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.namespaceName = namespaceName
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantNamespacePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantNamespacePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantNamespacePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNamespacePermission_args(object):
+    """
+    Attributes:
+     - login
+     - user
+     - namespaceName
+     - perm
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, namespaceName=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.namespaceName = namespaceName
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNamespacePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNamespacePermission_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNamespacePermission_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeNamespacePermission_args(object):
+    """
+    Attributes:
+     - login
+     - user
+     - namespaceName
+     - perm
     """
-    Parameters:
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, namespaceName=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.namespaceName = namespaceName
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeNamespacePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeNamespacePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeNamespacePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createBatchScanner_args(object):
+    """
+    Attributes:
      - login
      - tableName
      - options
     """
-    pass
 
-  def createScanner(self, login, tableName, options):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'options', (BatchScanOptions, BatchScanOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, options=None,):
+        self.login = login
+        self.tableName = tableName
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.options = BatchScanOptions()
+                    self.options.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createBatchScanner_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.STRUCT, 3)
+            self.options.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createBatchScanner_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createBatchScanner_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createScanner_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - options
     """
-    pass
 
-  def hasNext(self, scanner):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'options', (ScanOptions, ScanOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, options=None,):
+        self.login = login
+        self.tableName = tableName
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.options = ScanOptions()
+                    self.options.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createScanner_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.STRUCT, 3)
+            self.options.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createScanner_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createScanner_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNext_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
     """
-    pass
 
-  def nextEntry(self, scanner):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, scanner=None,):
+        self.scanner = scanner
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNext_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNext_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, success=None, ouch1=None,):
+        self.success = success
+        self.ouch1 = ouch1
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownScanner()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNext_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextEntry_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
     """
-    pass
 
-  def nextK(self, scanner, k):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, scanner=None,):
+        self.scanner = scanner
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextEntry_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextEntry_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (KeyValueAndPeek, KeyValueAndPeek.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = KeyValueAndPeek()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = NoMoreEntriesException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = UnknownScanner()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextEntry_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextK_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
      - k
     """
-    pass
 
-  def closeScanner(self, scanner):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+        (2, TType.I32, 'k', None, None, ),  # 2
+    )
+
+    def __init__(self, scanner=None, k=None,):
+        self.scanner = scanner
+        self.k = k
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I32:
+                    self.k = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextK_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        if self.k is not None:
+            oprot.writeFieldBegin('k', TType.I32, 2)
+            oprot.writeI32(self.k)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextK_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = ScanResult()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = NoMoreEntriesException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = UnknownScanner()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextK_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeScanner_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
     """
-    pass
 
-  def updateAndFlush(self, login, tableName, cells):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, scanner=None,):
+        self.scanner = scanner
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeScanner_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeScanner_result(object):
+    """
+    Attributes:
+     - ouch1
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, ouch1=None,):
+        self.ouch1 = ouch1
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownScanner()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeScanner_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateAndFlush_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - cells
     """
-    pass
 
-  def createWriter(self, login, tableName, opts):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.MAP, 'cells', (TType.STRING, 'BINARY', TType.LIST, (TType.STRUCT, (ColumnUpdate, ColumnUpdate.thrift_spec), False), False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, cells=None,):
+        self.login = login
+        self.tableName = tableName
+        self.cells = cells
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.MAP:
+                    self.cells = {}
+                    (_ktype391, _vtype392, _size390) = iprot.readMapBegin()
+                    for _i394 in range(_size390):
+                        _key395 = iprot.readBinary()
+                        _val396 = []
+                        (_etype400, _size397) = iprot.readListBegin()
+                        for _i401 in range(_size397):
+                            _elem402 = ColumnUpdate()
+                            _elem402.read(iprot)
+                            _val396.append(_elem402)
+                        iprot.readListEnd()
+                        self.cells[_key395] = _val396
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateAndFlush_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.cells is not None:
+            oprot.writeFieldBegin('cells', TType.MAP, 3)
+            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
+            for kiter403, viter404 in list(self.cells.items()):
+                oprot.writeBinary(kiter403)
+                oprot.writeListBegin(TType.STRUCT, len(viter404))
+                for iter405 in viter404:
+                    iter405.write(oprot)
+                oprot.writeListEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateAndFlush_result(object):
+    """
+    Attributes:
+     - outch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, outch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.outch1 = outch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.outch1 = AccumuloException()
+                    self.outch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = MutationsRejectedException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateAndFlush_result')
+        if self.outch1 is not None:
+            oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
+            self.outch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createWriter_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - opts
     """
-    pass
 
-  def update(self, writer, cells):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'opts', (WriterOptions, WriterOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, opts=None,):
+        self.login = login
+        self.tableName = tableName
+        self.opts = opts
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.opts = WriterOptions()
+                    self.opts.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createWriter_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.opts is not None:
+            oprot.writeFieldBegin('opts', TType.STRUCT, 3)
+            self.opts.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createWriter_result(object):
+    """
+    Attributes:
+     - success
+     - outch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, outch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.outch1 = outch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.outch1 = AccumuloException()
+                    self.outch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createWriter_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.outch1 is not None:
+            oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
+            self.outch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class update_args(object):
     """
-    Parameters:
+    Attributes:
      - writer
      - cells
     """
-    pass
 
-  def flush(self, writer):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'cells', (TType.STRING, 'BINARY', TType.LIST, (TType.STRUCT, (ColumnUpdate, ColumnUpdate.thrift_spec), False), False), None, ),  # 2
+    )
+
+    def __init__(self, writer=None, cells=None,):
+        self.writer = writer
+        self.cells = cells
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.writer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.cells = {}
+                    (_ktype407, _vtype408, _size406) = iprot.readMapBegin()
+                    for _i410 in range(_size406):
+                        _key411 = iprot.readBinary()
+                        _val412 = []
+                        (_etype416, _size413) = iprot.readListBegin()
+                        for _i417 in range(_size413):
+                            _elem418 = ColumnUpdate()
+                            _elem418.read(iprot)
+                            _val412.append(_elem418)
+                        iprot.readListEnd()
+                        self.cells[_key411] = _val412
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('update_args')
+        if self.writer is not None:
+            oprot.writeFieldBegin('writer', TType.STRING, 1)
+            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
+            oprot.writeFieldEnd()
+        if self.cells is not None:
+            oprot.writeFieldBegin('cells', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
+            for kiter419, viter420 in list(self.cells.items()):
+                oprot.writeBinary(kiter419)
+                oprot.writeListBegin(TType.STRUCT, len(viter420))
+                for iter421 in viter420:
+                    iter421.write(oprot)
+                oprot.writeListEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flush_args(object):
     """
-    Parameters:
+    Attributes:
      - writer
     """
-    pass
 
-  def closeWriter(self, writer):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, writer=None,):
+        self.writer = writer
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.writer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flush_args')
+        if self.writer is not None:
+            oprot.writeFieldBegin('writer', TType.STRING, 1)
+            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flush_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownWriter()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = MutationsRejectedException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flush_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeWriter_args(object):
     """
-    Parameters:
+    Attributes:
      - writer
     """
-    pass
 
-  def getRowRange(self, row):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, writer=None,):
+        self.writer = writer
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.writer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeWriter_args')
+        if self.writer is not None:
+            oprot.writeFieldBegin('writer', TType.STRING, 1)
+            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeWriter_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownWriter()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = MutationsRejectedException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeWriter_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowConditionally_args(object):
     """
-    Parameters:
+    Attributes:
+     - login
+     - tableName
      - row
+     - updates
     """
-    pass
 
-  def getFollowing(self, key, part):
-    """
-    Parameters:
-     - key
-     - part
-    """
-    pass
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'row', 'BINARY', None, ),  # 3
+        (4, TType.STRUCT, 'updates', (ConditionalUpdates, ConditionalUpdates.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, row=None, updates=None,):
+        self.login = login
+        self.tableName = tableName
+        self.row = row
+        self.updates = updates
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.row = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.updates = ConditionalUpdates()
+                    self.updates.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowConditionally_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.row is not None:
+            oprot.writeFieldBegin('row', TType.STRING, 3)
+            oprot.writeBinary(self.row)
+            oprot.writeFieldEnd()
+        if self.updates is not None:
+            oprot.writeFieldBegin('updates', TType.STRUCT, 4)
+            self.updates.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowConditionally_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.I32, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowConditionally_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
+    def __ne__(self, other):
+        return not (self == other)
 
-class Client(Iface):
-  def __init__(self, iprot, oprot=None):
-    self._iprot = self._oprot = iprot
-    if oprot is not None:
-      self._oprot = oprot
-    self._seqid = 0
 
-  def login(self, principal, loginProperties):
-    """
-    Parameters:
-     - principal
-     - loginProperties
+class createConditionalWriter_args(object):
     """
-    self.send_login(principal, loginProperties)
-    return self.recv_login()
-
-  def send_login(self, principal, loginProperties):
-    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
-    args = login_args()
-    args.principal = principal
-    args.loginProperties = loginProperties
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_login(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = login_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");
-
-  def addConstraint(self, login, tableName, constraintClassName):
-    """
-    Parameters:
+    Attributes:
      - login
      - tableName
-     - constraintClassName
+     - options
     """
-    self.send_addConstraint(login, tableName, constraintClassName)
-    return self.recv_addConstraint()
 
-  def send_addConstraint(self, login, tableName, constraintClassName):
-    self._oprot.writeMessageBegin('addConstraint', TMessageType.CALL, self._seqid)
-    args = addConstraint_args()
-    args.login = login
-    args.tableName = tableName
-    args.constraintClassName = constraintClassName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_addConstraint(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = addConstraint_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "addConstraint failed: unknown result");
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'options', (ConditionalWriterOptions, ConditionalWriterOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, options=None,):
+        self.login = login
+        self.tableName = tableName
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.options = ConditionalWriterOptions()
+                    self.options.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createConditionalWriter_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.STRUCT, 3)
+            self.options.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createConditionalWriter_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createConditionalWriter_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowsConditionally_args(object):
+    """
+    Attributes:
+     - conditionalWriter
+     - updates
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'conditionalWriter', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'updates', (TType.STRING, 'BINARY', TType.STRUCT, (ConditionalUpdates, ConditionalUpdates.thrift_spec), False), None, ),  # 2
+    )
+
+    def __init__(self, conditionalWriter=None, updates=None,):
+        self.conditionalWriter = conditionalWriter
+        self.updates = updates
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.conditionalWriter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.updates = {}
+                    (_ktype423, _vtype424, _size422) = iprot.readMapBegin()
+                    for _i426 in range(_size422):
+                        _key427 = iprot.readBinary()
+                        _val428 = ConditionalUpdates()
+                        _val428.read(iprot)
+                        self.updates[_key427] = _val428
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowsConditionally_args')
+        if self.conditionalWriter is not None:
+            oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
+            oprot.writeString(self.conditionalWriter.encode('utf-8') if sys.version_info[0] == 2 else self.conditionalWriter)
+            oprot.writeFieldEnd()
+        if self.updates is not None:
+            oprot.writeFieldBegin('updates', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.updates))
+            for kiter429, viter430 in list(self.updates.items()):
+                oprot.writeBinary(kiter429)
+                viter430.write(oprot)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowsConditionally_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'BINARY', TType.I32, None, False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype432, _vtype433, _size431) = iprot.readMapBegin()
+                    for _i435 in range(_size431):
+                        _key436 = iprot.readBinary()
+                        _val437 = iprot.readI32()
+                        self.success[_key436] = _val437
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownWriter()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowsConditionally_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
+            for kiter438, viter439 in list(self.success.items()):
+                oprot.writeBinary(kiter438)
+                oprot.writeI32(viter439)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeConditionalWriter_args(object):
+    """
+    Attributes:
+     - conditionalWriter
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'conditionalWriter', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, conditionalWriter=None,):
+        self.conditionalWriter = conditionalWriter
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.conditionalWriter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeConditionalWriter_args')
+        if self.conditionalWriter is not None:
+            oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
+            oprot.writeString(self.conditionalWriter.encode('utf-8') if sys.version_info[0] == 2 else self.conditionalWriter)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeConditionalWriter_result(object):
+
+    thrift_spec = (
+    )
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeConditionalWriter_result')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def addSplits(self, login, tableName, splits):
-    """
-    Parameters:
-     - login
-     - tableName
-     - splits
-    """
-    self.send_addSplits(login, tableName, splits)
-    self.recv_addSplits()
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_addSplits(self, login, tableName, splits):
-    self._oprot.writeMessageBegin('addSplits', TMessageType.CALL, self._seqid)
-    args = addSplits_args()
-    args.login = login
-    args.tableName = tableName
-    args.splits = splits
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_addSplits(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = addSplits_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def attachIterator(self, login, tableName, setting, scopes):
+class getRowRange_args(object):
     """
-    Parameters:
-     - login
-     - tableName
-     - setting
-     - scopes
+    Attributes:
+     - row
     """
-    self.send_attachIterator(login, tableName, setting, scopes)
-    self.recv_attachIterator()
 
-  def send_attachIterator(self, login, tableName, setting, scopes):
-    self._oprot.writeMessageBegin('attachIterator', TMessageType.CALL, self._seqid)
-    args = attachIterator_args()
-    args.login = login
-    args.tableName = tableName
-    args.setting = setting
-    args.scopes = scopes
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_attachIterator(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = attachIterator_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, row=None,):
+        self.row = row
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.row = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getRowRange_args')
+        if self.row is not None:
+            oprot.writeFieldBegin('row', TType.STRING, 1)
+            oprot.writeBinary(self.row)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getRowRange_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (Range, Range.thrift_spec), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = Range()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getRowRange_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def checkIteratorConflicts(self, login, tableName, setting, scopes):
-    """
-    Parameters:
-     - login
-     - tableName
-     - setting
-     - scopes
-    """
-    self.send_checkIteratorConflicts(login, tableName, setting, scopes)
-    self.recv_checkIteratorConflicts()
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_checkIteratorConflicts(self, login, tableName, setting, scopes):
-    self._oprot.writeMessageBegin('checkIteratorConflicts', TMessageType.CALL, self._seqid)
-    args = checkIteratorConflicts_args()
-    args.login = login
-    args.tableName = tableName
-    args.setting = setting
-    args.scopes = scopes
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_checkIteratorConflicts(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = checkIteratorConflicts_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
 
-  def clearLocatorCache(self, login, tableName):
+class getFollowing_args(object):
     """
-    Parameters:
-     - login
-     - tableName
+    Attributes:
+     - key
+     - part
     """
-    self.send_clearLocatorCache(login, tableName)
-    self.recv_clearLocatorCache()
-
-  def send_clearLocatorCache(self, login, tableName):
-    self._oprot.writeMessageBegin('clearLocatorCache', TMessageType.CALL, self._seqid)
-    args = clearLocatorCache_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_clearLocatorCache(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = clearLocatorCache_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    return
 
-  def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
-    """
-    Parameters:
-     - login
-     - tableName
-     - newTableName
-     - flush
-     - propertiesToSet
-     - propertiesToExclude
-    """
-    self.send_cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude)
-    self.recv_cloneTable()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ),  # 1
+        (2, TType.I32, 'part', None, None, ),  # 2
+    )
+
+    def __init__(self, key=None, part=None,):
+        self.key = key
+        self.part = part
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.key = Key()
+                    self.key.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I32:
+                    self.part = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getFollowing_args')
+        if self.key is not None:
+            oprot.writeFieldBegin('key', TType.STRUCT, 1)
+            self.key.write(oprot)
+            oprot.writeFieldEnd()
+        if self.part is not None:
+            oprot.writeFieldBegin('part', TType.I32, 2)
+            oprot.writeI32(self.part)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getFollowing_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (Key, Key.thrift_spec), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = Key()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getFollowing_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class systemNamespace_args(object):
+
+    thrift_spec = (
+    )
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('systemNamespace_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class systemNamespace_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('systemNamespace_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class defaultNamespace_args(object):
+
+    thrift_spec = (
+    )
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('defaultNamespace_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class defaultNamespace_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('defaultNamespace_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaces_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaces_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaces_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype443, _size440) = iprot.readListBegin()
+                    for _i444 in range(_size440):
+                        _elem445 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.append(_elem445)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaces_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter446 in self.success:
+                oprot.writeString(iter446.encode('utf-8') if sys.version_info[0] == 2 else iter446)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceExists_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceExists_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceExists_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceExists_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createNamespace_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createNamespace_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createNamespace_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceExistsException, NamespaceExistsException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceExistsException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createNamespace_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteNamespace_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteNamespace_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteNamespace_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (NamespaceNotEmptyException, NamespaceNotEmptyException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = NamespaceNotEmptyException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteNamespace_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameNamespace_args(object):
+    """
+    Attributes:
+     - login
+     - oldNamespaceName
+     - newNamespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'oldNamespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'newNamespaceName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, oldNamespaceName=None, newNamespaceName=None,):
+        self.login = login
+        self.oldNamespaceName = oldNamespaceName
+        self.newNamespaceName = newNamespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.oldNamespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.newNamespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameNamespace_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.oldNamespaceName is not None:
+            oprot.writeFieldBegin('oldNamespaceName', TType.STRING, 2)
+            oprot.writeString(self.oldNamespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.oldNamespaceName)
+            oprot.writeFieldEnd()
+        if self.newNamespaceName is not None:
+            oprot.writeFieldBegin('newNamespaceName', TType.STRING, 3)
+            oprot.writeString(self.newNamespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.newNamespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameNamespace_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (NamespaceExistsException, NamespaceExistsException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = NamespaceExistsException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameNamespace_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
-    self._oprot.writeMessageBegin('cloneTable', TMessageType.CALL, self._seqid)
-    args = cloneTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.newTableName = newTableName
-    args.flush = flush
-    args.propertiesToSet = propertiesToSet
-    args.propertiesToExclude = propertiesToExclude
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_cloneTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = cloneTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    if result.ouch4 is not None:
-      raise result.ouch4
-    return
 
-  def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
+class setNamespaceProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - startRow
-     - endRow
-     - iterators
-     - flush
-     - wait
+     - namespaceName
+     - property
+     - value
     """
-    self.send_compactTable(login, tableName, startRow, endRow, iterators, flush, wait)
-    self.recv_compactTable()
 
-  def send_compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
-    self._oprot.writeMessageBegin('compactTable', TMessageType.CALL, self._seqid)
-    args = compactTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.iterators = iterators
-    args.flush = flush
-    args.wait = wait
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_compactTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = compactTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def cancelCompaction(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_cancelCompaction(login, tableName)
-    self.recv_cancelCompaction()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, property=None, value=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.property = property
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setNamespaceProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 4)
+            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setNamespaceProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setNamespaceProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_cancelCompaction(self, login, tableName):
-    self._oprot.writeMessageBegin('cancelCompaction', TMessageType.CALL, self._seqid)
-    args = cancelCompaction_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_cancelCompaction(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = cancelCompaction_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def createTable(self, login, tableName, versioningIter, type):
+class removeNamespaceProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - versioningIter
-     - type
+     - namespaceName
+     - property
     """
-    self.send_createTable(login, tableName, versioningIter, type)
-    self.recv_createTable()
-
-  def send_createTable(self, login, tableName, versioningIter, type):
-    self._oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
-    args = createTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.versioningIter = versioningIter
-    args.type = type
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def deleteTable(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_deleteTable(login, tableName)
-    self.recv_deleteTable()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, namespaceName=None, property=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.property = property
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getNamespaceProperties_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceProperties_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getNamespaceProperties_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype448, _vtype449, _size447) = iprot.readMapBegin()
+                    for _i451 in range(_size447):
+                        _key452 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val453 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key452] = _val453
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceProperties_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter454, viter455 in list(self.success.items()):
+                oprot.writeString(kiter454.encode('utf-8') if sys.version_info[0] == 2 else kiter454)
+                oprot.writeString(viter455.encode('utf-8') if sys.version_info[0] == 2 else viter455)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceIdMap_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceIdMap_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceIdMap_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype457, _vtype458, _size456) = iprot.readMapBegin()
+                    for _i460 in range(_size456):
+                        _key461 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val462 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key461] = _val462
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceIdMap_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter463, viter464 in list(self.success.items()):
+                oprot.writeString(kiter463.encode('utf-8') if sys.version_info[0] == 2 else kiter463)
+                oprot.writeString(viter464.encode('utf-8') if sys.version_info[0] == 2 else viter464)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_deleteTable(self, login, tableName):
-    self._oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
-    args = deleteTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_deleteTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = deleteTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def deleteRows(self, login, tableName, startRow, endRow):
+class attachNamespaceIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - startRow
-     - endRow
+     - namespaceName
+     - setting
+     - scopes
     """
-    self.send_deleteRows(login, tableName, startRow, endRow)
-    self.recv_deleteRows()
-
-  def send_deleteRows(self, login, tableName, startRow, endRow):
-    self._oprot.writeMessageBegin('deleteRows', TMessageType.CALL, self._seqid)
-    args = deleteRows_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_deleteRows(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = deleteRows_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def exportTable(self, login, tableName, exportDir):
-    """
-    Parameters:
-     - login
-     - tableName
-     - exportDir
-    """
-    self.send_exportTable(login, tableName, exportDir)
-    self.recv_exportTable()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, setting=None, scopes=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype468, _size465) = iprot.readSetBegin()
+                    for _i469 in range(_size465):
+                        _elem470 = iprot.readI32()
+                        self.scopes.add(_elem470)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachNamespaceIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter471 in self.scopes:
+                oprot.writeI32(iter471)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class attachNamespaceIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachNamespaceIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_exportTable(self, login, tableName, exportDir):
-    self._oprot.writeMessageBegin('exportTable', TMessageType.CALL, self._seqid)
-    args = exportTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.exportDir = exportDir
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_exportTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = exportTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def flushTable(self, login, tableName, startRow, endRow, wait):
+class removeNamespaceIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - startRow
-     - endRow
-     - wait
+     - namespaceName
+     - name
+     - scopes
     """
-    self.send_flushTable(login, tableName, startRow, endRow, wait)
-    self.recv_flushTable()
 
-  def send_flushTable(self, login, tableName, startRow, endRow, wait):
-    self._oprot.writeMessageBegin('flushTable', TMessageType.CALL, self._seqid)
-    args = flushTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.wait = wait
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_flushTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = flushTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, name=None, scopes=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.name = name
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype475, _size472) = iprot.readSetBegin()
+                    for _i476 in range(_size472):
+                        _elem477 = iprot.readI32()
+                        self.scopes.add(_elem477)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 3)
+            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter478 in self.scopes:
+                oprot.writeI32(iter478)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def getLocalityGroups(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_getLocalityGroups(login, tableName)
-    return self.recv_getLocalityGroups()
 
-  def send_getLocalityGroups(self, login, tableName):
-    self._oprot.writeMessageBegin('getLocalityGroups', TMessageType.CALL, self._seqid)
-    args = getLocalityGroups_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getLocalityGroups(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getLocalityGroups_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLocalityGroups failed: unknown result");
-
-  def getIteratorSetting(self, login, tableName, iteratorName, scope):
+class getNamespaceIteratorSetting_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - iteratorName
+     - namespaceName
+     - name
      - scope
     """
-    self.send_getIteratorSetting(login, tableName, iteratorName, scope)
-    return self.recv_getIteratorSetting()
-
-  def send_getIteratorSetting(self, login, tableName, iteratorName, scope):
-    self._oprot.writeMessageBegin('getIteratorSetting', TMessageType.CALL, self._seqid)
-    args = getIteratorSetting_args()
-    args.login = login
-    args.tableName = tableName
-    args.iteratorName = iteratorName
-    args.scope = scope
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getIteratorSetting(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getIteratorSetting_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getIteratorSetting failed: unknown result");
-
-  def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
-    """
-    Parameters:
-     - login
-     - tableName
-     - auths
-     - startRow
-     - startInclusive
-     - endRow
-     - endInclusive
-    """
-    self.send_getMaxRow(login, tableName, auths, startRow, startInclusive, endRow, endInclusive)
-    return self.recv_getMaxRow()
-
-  def send_getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
-    self._oprot.writeMessageBegin('getMaxRow', TMessageType.CALL, self._seqid)
-    args = getMaxRow_args()
-    args.login = login
-    args.tableName = tableName
-    args.auths = auths
-    args.startRow = startRow
-    args.startInclusive = startInclusive
-    args.endRow = endRow
-    args.endInclusive = endInclusive
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getMaxRow(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getMaxRow_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMaxRow failed: unknown result");
-
-  def getTableProperties(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_getTableProperties(login, tableName)
-    return self.recv_getTableProperties()
-
-  def send_getTableProperties(self, login, tableName):
-    self._oprot.writeMessageBegin('getTableProperties', TMessageType.CALL, self._seqid)
-    args = getTableProperties_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getTableProperties(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getTableProperties_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableProperties failed: unknown result");
-
-  def getSplits(self, login, tableName, maxSplits):
-    """
-    Parameters:
-     - login
-     - tableName
-     - maxSplits
-    """
-    self.send_getSplits(login, tableName, maxSplits)
-    return self.recv_getSplits()
-
-  def send_getSplits(self, login, tableName, maxSplits):
-    self._oprot.writeMessageBegin('getSplits', TMessageType.CALL, self._seqid)
-    args = getSplits_args()
-    args.login = login
-    args.tableName = tableName
-    args.maxSplits = maxSplits
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getSplits(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getSplits_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSplits failed: unknown result");
-
-  def importDirectory(self, login, tableName, importDir, failureDir, setTime):
-    """
-    Parameters:
-     - login
-     - tableName
-     - importDir
-     - failureDir
-     - setTime
-    """
-    self.send_importDirectory(login, tableName, importDir, failureDir, setTime)
-    self.recv_importDirectory()
-
-  def send_importDirectory(self, login, tableName, importDir, failureDir, setTime):
-    self._oprot.writeMessageBegin('importDirectory', TMessageType.CALL, self._seqid)
-    args = importDirectory_args()
-    args.login = login
-    args.tableName = tableName
-    args.importDir = importDir
-    args.failureDir = failureDir
-    args.setTime = setTime
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_importDirectory(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = importDirectory_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch3 is not None:
-      raise result.ouch3
-    if result.ouch4 is not None:
-      raise result.ouch4
-    return
-
-  def importTable(self, login, tableName, importDir):
-    """
-    Parameters:
-     - login
-     - tableName
-     - importDir
-    """
-    self.send_importTable(login, tableName, importDir)
-    self.recv_importTable()
-
-  def send_importTable(self, login, tableName, importDir):
-    self._oprot.writeMessageBegin('importTable', TMessageType.CALL, self._seqid)
-    args = importTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.importDir = importDir
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_importTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = importTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def listTables(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_listTables(login)
-    return self.recv_listTables()
-
-  def send_listTables(self, login):
-    self._oprot.writeMessageBegin('listTables', TMessageType.CALL, self._seqid)
-    args = listTables_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listTables(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listTables_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result");
-
-  def listIterators(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_listIterators(login, tableName)
-    return self.recv_listIterators()
-
-  def send_listIterators(self, login, tableName):
-    self._oprot.writeMessageBegin('listIterators', TMessageType.CALL, self._seqid)
-    args = listIterators_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listIterators(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listIterators_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listIterators failed: unknown result");
-
-  def listConstraints(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_listConstraints(login, tableName)
-    return self.recv_listConstraints()
-
-  def send_listConstraints(self, login, tableName):
-    self._oprot.writeMessageBegin('listConstraints', TMessageType.CALL, self._seqid)
-    args = listConstraints_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listConstraints(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listConstraints_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listConstraints failed: unknown result");
-
-  def mergeTablets(self, login, tableName, startRow, endRow):
-    """
-    Parameters:
-     - login
-     - tableName
-     - startRow
-     - endRow
-    """
-    self.send_mergeTablets(login, tableName, startRow, endRow)
-    self.recv_mergeTablets()
-
-  def send_mergeTablets(self, login, tableName, startRow, endRow):
-    self._oprot.writeMessageBegin('mergeTablets', TMessageType.CALL, self._seqid)
-    args = mergeTablets_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_mergeTablets(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = mergeTablets_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def offlineTable(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_offlineTable(login, tableName)
-    self.recv_offlineTable()
-
-  def send_offlineTable(self, login, tableName):
-    self._oprot.writeMessageBegin('offlineTable', TMessageType.CALL, self._seqid)
-    args = offlineTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_offlineTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = offlineTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def onlineTable(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_onlineTable(login, tableName)
-    self.recv_onlineTable()
-
-  def send_onlineTable(self, login, tableName):
-    self._oprot.writeMessageBegin('onlineTable', TMessageType.CALL, self._seqid)
-    args = onlineTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_onlineTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = onlineTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def removeConstraint(self, login, tableName, constraint):
-    """
-    Parameters:
-     - login
-     - tableName
-     - constraint
-    """
-    self.send_removeConstraint(login, tableName, constraint)
-    self.recv_removeConstraint()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'scope', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, name=None, scope=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.name = name
+        self.scope = scope
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.scope = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceIteratorSetting_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 3)
+            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldEnd()
+        if self.scope is not None:
+            oprot.writeFieldBegin('scope', TType.I32, 4)
+            oprot.writeI32(self.scope)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getNamespaceIteratorSetting_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = IteratorSetting()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceIteratorSetting_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceIterators_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceIterators_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceIterators_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.I32, None, False), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype480, _vtype481, _size479) = iprot.readMapBegin()
+                    for _i483 in range(_size479):
+                        _key484 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val485 = set()
+                        (_etype489, _size486) = iprot.readSetBegin()
+                        for _i490 in range(_size486):
+                            _elem491 = iprot.readI32()
+                            _val485.add(_elem491)
+                        iprot.readSetEnd()
+                        self.success[_key484] = _val485
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceIterators_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
+            for kiter492, viter493 in list(self.success.items()):
+                oprot.writeString(kiter492.encode('utf-8') if sys.version_info[0] == 2 else kiter492)
+                oprot.writeSetBegin(TType.I32, len(viter493))
+                for iter494 in viter493:
+                    oprot.writeI32(iter494)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_removeConstraint(self, login, tableName, constraint):
-    self._oprot.writeMessageBegin('removeConstraint', TMessageType.CALL, self._seqid)
-    args = removeConstraint_args()
-    args.login = login
-    args.tableName = tableName
-    args.constraint = constraint
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeConstraint(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeConstraint_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
 
-  def removeIterator(self, login, tableName, iterName, scopes):
+class checkNamespaceIteratorConflicts_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - iterName
+     - namespaceName
+     - setting
      - scopes
     """
-    self.send_removeIterator(login, tableName, iterName, scopes)
-    self.recv_removeIterator()
-
-  def send_removeIterator(self, login, tableName, iterName, scopes):
-    self._oprot.writeMessageBegin('removeIterator', TMessageType.CALL, self._seqid)
-    args = removeIterator_args()
-    args.login = login
-    args.tableName = tableName
-    args.iterName = iterName
-    args.scopes = scopes
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeIterator(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeIterator_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def removeTableProperty(self, login, tableName, property):
-    """
-    Parameters:
-     - login
-     - tableName
-     - property
-    """
-    self.send_removeTableProperty(login, tableName, property)
-    self.recv_removeTableProperty()
-
-  def send_removeTableProperty(self, login, tableName, property):
-    self._oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
-    args = removeTableProperty_args()
-    args.login = login
-    args.tableName = tableName
-    args.property = property
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeTableProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeTableProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def renameTable(self, login, oldTableName, newTableName):
-    """
-    Parameters:
-     - login
-     - oldTableName
-     - newTableName
-    """
-    self.send_renameTable(login, oldTableName, newTableName)
-    self.recv_renameTable()
-
-  def send_renameTable(self, login, oldTableName, newTableName):
-    self._oprot.writeMessageBegin('renameTable', TMessageType.CALL, self._seqid)
-    args = renameTable_args()
-    args.login = login
-    args.oldTableName = oldTableName
-    args.newTableName = newTableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_renameTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = renameTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    if result.ouch4 is not None:
-      raise result.ouch4
-    return
-
-  def setLocalityGroups(self, login, tableName, groups):
-    """
-    Parameters:
-     - login
-     - tableName
-     - groups
-    """
-    self.send_setLocalityGroups(login, tableName, groups)
-    self.recv_setLocalityGroups()
-
-  def send_setLocalityGroups(self, login, tableName, groups):
-    self._oprot.writeMessageBegin('setLocalityGroups', TMessageType.CALL, self._seqid)
-    args = setLocalityGroups_args()
-    args.login = login
-    args.tableName = tableName
-    args.groups = groups
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_setLocalityGroups(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = setLocalityGroups_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def setTableProperty(self, login, tableName, property, value):
-    """
-    Parameters:
-     - login
-     - tableName
-     - property
-     - value
-    """
-    self.send_setTableProperty(login, tableName, property, value)
-    self.recv_setTableProperty()
-
-  def send_setTableProperty(self, login, tableName, property, value):
-    self._oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
-    args = setTableProperty_args()
-    args.login = login
-    args.tableName = tableName
-    args.property = property
-    args.value = value
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_setTableProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = setTableProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def splitRangeByTablets(self, login, tableName, range, maxSplits):
-    """
-    Parameters:
-     - login
-     - tableName
-     - range
-     - maxSplits
-    """
-    self.send_splitRangeByTablets(login, tableName, range, maxSplits)
-    return self.recv_splitRangeByTablets()
-
-  def send_splitRangeByTablets(self, login, tableName, range, maxSplits):
-    self._oprot.writeMessageBegin('splitRangeByTablets', TMessageType.CALL, self._seqid)
-    args = splitRangeByTablets_args()
-    args.login = login
-    args.tableName = tableName
-    args.range = range
-    args.maxSplits = maxSplits
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_splitRangeByTablets(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = splitRangeByTablets_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "splitRangeByTablets failed: unknown result");
-
-  def tableExists(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_tableExists(login, tableName)
-    return self.recv_tableExists()
-
-  def send_tableExists(self, login, tableName):
-    self._oprot.writeMessageBegin('tableExists', TMessageType.CALL, self._seqid)
-    args = tableExists_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_tableExists(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = tableExists_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "tableExists failed: unknown result");
-
-  def tableIdMap(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_tableIdMap(login)
-    return self.recv_tableIdMap()
-
-  def send_tableIdMap(self, login):
-    self._oprot.writeMessageBegin('tableIdMap', TMessageType.CALL, self._seqid)
-    args = tableIdMap_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_tableIdMap(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = tableIdMap_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIdMap failed: unknown result");
-
-  def pingTabletServer(self, login, tserver):
-    """
-    Parameters:
-     - login
-     - tserver
-    """
-    self.send_pingTabletServer(login, tserver)
-    self.recv_pingTabletServer()
-
-  def send_pingTabletServer(self, login, tserver):
-    self._oprot.writeMessageBegin('pingTabletServer', TMessageType.CALL, self._seqid)
-    args = pingTabletServer_args()
-    args.login = login
-    args.tserver = tserver
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_pingTabletServer(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = pingTabletServer_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def getActiveScans(self, login, tserver):
-    """
-    Parameters:
-     - login
-     - tserver
-    """
-    self.send_getActiveScans(login, tserver)
-    return self.recv_getActiveScans()
-
-  def send_getActiveScans(self, login, tserver):
-    self._oprot.writeMessageBegin('getActiveScans', TMessageType.CALL, self._seqid)
-    args = getActiveScans_args()
-    args.login = login
-    args.tserver = tserver
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getActiveScans(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getActiveScans_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveScans failed: unknown result");
 
-  def getActiveCompactions(self, login, tserver):
-    """
-    Parameters:
-     - login
-     - tserver
-    """
-    self.send_getActiveCompactions(login, tserver)
-    return self.recv_getActiveCompactions()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, setting=None, scopes=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype498, _size495) = iprot.readSetBegin()
+                    for _i499 in range(_size495):
+                        _elem500 = iprot.readI32()
+                        self.scopes.add(_elem500)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkNamespaceIteratorConflicts_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter501 in self.scopes:
+                oprot.writeI32(iter501)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class checkNamespaceIteratorConflicts_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkNamespaceIteratorConflicts_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_getActiveCompactions(self, login, tserver):
-    self._oprot.writeMessageBegin('getActiveCompactions', TMessageType.CALL, self._seqid)
-    args = getActiveCompactions_args()
-    args.login = login
-    args.tserver = tserver
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getActiveCompactions(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getActiveCompactions_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveCompactions failed: unknown result");
-
-  def getSiteConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_getSiteConfiguration(login)
-    return self.recv_getSiteConfiguration()
-
-  def send_getSiteConfiguration(self, login):
-    self._oprot.writeMessageBegin('getSiteConfiguration', TMessageType.CALL, self._seqid)
-    args = getSiteConfiguration_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getSiteConfiguration(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getSiteConfiguration_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSiteConfiguration failed: unknown result");
-
-  def getSystemConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_getSystemConfiguration(login)
-    return self.recv_getSystemConfiguration()
-
-  def send_getSystemConfiguration(self, login):
-    self._oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
-    args = getSystemConfiguration_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getSystemConfiguration(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getSystemConfiguration_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSystemConfiguration failed: unknown result");
-
-  def getTabletServers(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_getTabletServers(login)
-    return self.recv_getTabletServers()
-
-  def send_getTabletServers(self, login):
-    self._oprot.writeMessageBegin('getTabletServers', TMessageType.CALL, self._seqid)
-    args = getTabletServers_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getTabletServers(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getTabletServers_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTabletServers failed: unknown result");
 
-  def removeProperty(self, login, property):
+class addNamespaceConstraint_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - property
+     - namespaceName
+     - constraintClassName
     """
-    self.send_removeProperty(login, property)
-    self.recv_removeProperty()
 
-  def send_removeProperty(self, login, property):
-    self._oprot.writeMessageBegin('removeProperty', TMessageType.CALL, self._seqid)
-    args = removeProperty_args()
-    args.login = login
-    args.property = property
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def setProperty(self, login, property, value):
-    """
-    Parameters:
-     - login
-     - property
-     - value
-    """
-    self.send_setProperty(login, property, value)
-    self.recv_setProperty()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'constraintClassName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, namespaceName=None, constraintClassName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.constraintClassName = constraintClassName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.constraintClassName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addNamespaceConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.constraintClassName is not None:
+            oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
+            oprot.writeString(self.constraintClassName.encode('utf-8') if sys.version_info[0] == 2 else self.constraintClassName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addNamespaceConstraint_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.I32, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addNamespaceConstraint_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceConstraint_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+     - id
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'id', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, namespaceName=None, id=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.id = id
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.id = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.id is not None:
+            oprot.writeFieldBegin('id', TType.I32, 3)
+            oprot.writeI32(self.id)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceConstraint_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceConstraint_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceConstraints_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceConstraints_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceConstraints_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype503, _vtype504, _size502) = iprot.readMapBegin()
+                    for _i506 in range(_size502):
+                        _key507 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val508 = iprot.readI32()
+                        self.success[_key507] = _val508
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceConstraints_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
+            for kiter509, viter510 in list(self.success.items()):
+                oprot.writeString(kiter509.encode('utf-8') if sys.version_info[0] == 2 else kiter509)
+                oprot.writeI32(viter510)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_setProperty(self, login, property, value):
-    self._oprot.writeMessageBegin('setProperty', TMessageType.CALL, self._seqid)
-    args = setProperty_args()
-    args.login = login
-    args.property = property
-    args.value = value
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_setProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = setProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
 
-  def testClassLoad(self, login, className, asTypeName):
+class testNamespaceClassLoad_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - namespaceName
      - className
      - asTypeName
     """
-    self.send_testClassLoad(login, className, asTypeName)
-    return self.recv_testClassLoad()
-
-  def send_testClassLoad(self, login, className, asTypeName):
-    self._oprot.writeMessageBegin('testClassLoad', TMessageType.CALL, self._seqid)
-    args = testClassLoad_args()
-    args.login = login
-    args.className = className
-    args.asTypeName = asTypeName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_testClassLoad(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = testClassLoad_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "testClassLoad failed: unknown result");
-
-  def authenticateUser(self, login, user, properties):
-    """
-    Parameters:
-     - login
-     - user
-     - properties
-    """
-    self.send_authenticateUser(login, user, properties)
-    return self.recv_authenticateUser()
-
-  def send_authenticateUser(self, login, user, properties):
-    self._oprot.writeMessageBegin('authenticateUser', TMessageType.CALL, self._seqid)
-    args = authenticateUser_args()
-    args.login = login
-    args.user = user
-    args.properties = properties
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_authenticateUser(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = authenticateUser_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateUser failed: unknown result");
-
-  def changeUserAuthorizations(self, login, user, authorizations):
-    """
-    Parameters:
-     - login
-     - user
-     - authorizations
-    """
-    self.send_changeUserAuthorizations(login, user, authorizations)
-    self.recv_changeUserAuthorizations()
-
-  def send_changeUserAuthorizations(self, login, user, authorizations):
-    self._oprot.writeMessageBegin('changeUserAuthorizations', TMessageType.CALL, self._seqid)
-    args = changeUserAuthorizations_args()
-    args.login = login
-    args.user = user
-    args.authorizations = authorizations
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_changeUserAuthorizations(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = changeUserAuthorizations_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def changeLocalUserPassword(self, login, user, password):
-    """
-    Parameters:
-     - login
-     - user
-     - password
-    """
-    self.send_changeLocalUserPassword(login, user, password)
-    self.recv_changeLocalUserPassword()
-
-  def send_changeLocalUserPassword(self, login, user, password):
-    self._oprot.writeMessageBegin('changeLocalUserPassword', TMessageType.CALL, self._seqid)
-    args = changeLocalUserPassword_args()
-    args.login = login
-    args.user = user
-    args.password = password
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_changeLocalUserPassword(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = changeLocalUserPassword_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def createLocalUser(self, login, user, password):
-    """
-    Parameters:
-     - login
-     - user
-     - password
-    """
-    self.send_createLocalUser(login, user, password)
-    self.recv_createLocalUser()
 
-  def send_createLocalUser(self, login, user, password):
-    self._oprot.writeMessageBegin('createLocalUser', TMessageType.CALL, self._seqid)
-    args = createLocalUser_args()
-    args.login = login
-    args.user = user
-    args.password = password
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createLocalUser(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createLocalUser_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def dropLocalUser(self, login, user):
-    """
-    Parameters:
-     - login
-     - user
-    """
-    self.send_dropLocalUser(login, user)
-    self.recv_dropLocalUser()
-
-  def send_dropLocalUser(self, login, user):
-    self._oprot.writeMessageBegin('dropLocalUser', TMessageType.CALL, self._seqid)
-    args = dropLocalUser_args()
-    args.login = login
-    args.user = user
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_dropLocalUser(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = dropLocalUser_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def getUserAuthorizations(self, login, user):
-    """
-    Parameters:
-     - login
-     - user
-    """
-    self.send_getUserAuthorizations(login, user)
-    return self.recv_getUserAuthorizations()
-
-  def send_getUserAuthorizations(self, login, user):
-    self._oprot.writeMessageBegin('getUserAuthorizations', TMessageType.CALL, self._seqid)
-    args = getUserAuthorizations_args()
-    args.login = login
-    args.user = user
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getUserAuthorizations(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getUserAuthorizations_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserAuthorizations failed: unknown result");
-
-  def grantSystemPermission(self, login, user, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - perm
-    """
-    self.send_grantSystemPermission(login, user, perm)
-    self.recv_grantSystemPermission()
-
-  def send_grantSystemPermission(self, login, user, perm):
-    self._oprot.writeMessageBegin('grantSystemPermission', TMessageType.CALL, self._seqid)
-    args = grantSystemPermission_args()
-    args.login = login
-    args.user = user
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_grantSystemPermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = grantSystemPermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def grantTablePermission(self, login, user, table, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - table
-     - perm
-    """
-    self.send_grantTablePermission(login, user, table, perm)
-    self.recv_grantTablePermission()
-
-  def send_grantTablePermission(self, login, user, table, perm):
-    self._oprot.writeMessageBegin('grantTablePermission', TMessageType.CALL, self._seqid)
-    args = grantTablePermission_args()
-    args.login = login
-    args.user = user
-    args.table = table
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_grantTablePermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = grantTablePermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def hasSystemPermission(self, login, user, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - perm
-    """
-    self.send_hasSystemPermission(login, user, perm)
-    return self.recv_hasSystemPermission()
-
-  def send_hasSystemPermission(self, login, user, perm):
-    self._oprot.writeMessageBegin('hasSystemPermission', TMessageType.CALL, self._seqid)
-    args = hasSystemPermission_args()
-    args.login = login
-    args.user = user
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_hasSystemPermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = hasSystemPermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "hasSystemPermission failed: unknown result");
-
-  def hasTablePermission(self, login, user, table, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - table
-     - perm
-    """
-    self.send_hasTablePermission(login, user, table, perm)
-    return self.recv_hasTablePermission()
-
-  def send_hasTablePermission(self, login, user, table, perm):
-    self._oprot.writeMessageBegin('hasTablePermission', TMessageType.CALL, self._seqid)
-    args = hasTablePermission_args()
-    args.login = login
-    args.user = user
-    args.table = table
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_hasTablePermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = hasTablePermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "hasTablePermission failed: unknown result");
-
-  def listLocalUsers(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_listLocalUsers(login)
-    return self.recv_listLocalUsers()
-
-  def send_listLocalUsers(self, login):
-    self._oprot.writeMessageBegin('listLocalUsers', TMessageType.CALL, self._seqid)
-    args = listLocalUsers_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listLocalUsers(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listLocalUsers_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listLocalUsers failed: unknown result");
-
-  def revokeSystemPermission(self, login, user, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - perm
-    """
-    self.send_revokeSystemPermission(login, user, perm)
-    self.recv_revokeSystemPermission()
-
-  def send_revokeSystemPermission(self, login, user, perm):
-    self._oprot.writeMessageBegin('revokeSystemPermission', TMessageType.CALL, self._seqid)
-    args = revokeSystemPermission_args()
-    args.login = login
-    args.user = user
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_revokeSystemPermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = revokeSystemPermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def revokeTablePermission(self, login, user, table, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - table
-     - perm
-    """
-    self.send_revokeTablePermission(login, user, table, perm)
-    self.recv_revokeTablePermission()
-
-  def send_revokeTablePermission(self, login, user, table, perm):
-    self._oprot.writeMessageBegin('revokeTablePermission', TMessageType.CALL, self._seqid)
-    args = revokeTablePermission_args()
-    args.login = login
-    args.user = user
-    args.table = table
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_revokeTablePermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = revokeTablePermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def createBatchScanner(self, login, tableName, options):
-    """
-    Parameters:
-     - login
-     - tableName
-     - options
-    """
-    self.send_createBatchScanner(login, tableName, options)
-    return self.recv_createBatchScanner()
-
-  def send_createBatchScanner(self, login, tableName, options):
-    self._oprot.writeMessageBegin('createBatchScanner', TMessageType.CALL, self._seqid)
-    args = createBatchScanner_args()
-    args.login = login
-    args.tableName = tableName
-    args.options = options
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createBatchScanner(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createBatchScanner_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "createBatchScanner failed: unknown result");
-
-  def createScanner(self, login, tableName, options):
-    """
-    Parameters:
-     - login
-     - tableName
-     - options
-    """
-    self.send_createScanner(login, tableName, options)
-    return self.recv_createScanner()
-
-  def send_createScanner(self, login, tableName, options):
-    self._oprot.writeMessageBegin('createScanner', TMessageType.CALL, self._seqid)
-    args = createScanner_args()
-    args.login = login
-    args.tableName = tableName
-    args.options = options
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createScanner(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createScanner_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "createScanner failed: unknown result");
-
-  def hasNext(self, scanner):
-    """
-    Parameters:
-     - scanner
-    """
-    self.send_hasNext(scanner)
-    return self.recv_hasNext()
-
-  def send_hasNext(self, scanner):
-    self._oprot.writeMessageBegin('hasNext', TMessageType.CALL, self._seqid)
-    args = hasNext_args()
-    args.scanner = scanner
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_hasNext(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = hasNext_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNext failed: unknown result");
-
-  def nextEntry(self, scanner):
-    """
-    Parameters:
-     - scanner
-    """
-    self.send_nextEntry(scanner)
-    return self.recv_nextEntry()
-
-  def send_nextEntry(self, scanner):
-    self._oprot.writeMessageBegin('nextEntry', TMessageType.CALL, self._seqid)
-    args = nextEntry_args()
-    args.scanner = scanner
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_nextEntry(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = nextEntry_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "nextEntry failed: unknown result");
-
-  def nextK(self, scanner, k):
-    """
-    Parameters:
-     - scanner
-     - k
-    """
-    self.send_nextK(scanner, k)
-    return self.recv_nextK()
-
-  def send_nextK(self, scanner, k):
-    self._oprot.writeMessageBegin('nextK', TMessageType.CALL, self._seqid)
-    args = nextK_args()
-    args.scanner = scanner
-    args.k = k
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_nextK(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = nextK_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "nextK failed: unknown result");
-
-  def closeScanner(self, scanner):
-    """
-    Parameters:
-     - scanner
-    """
-    self.send_closeScanner(scanner)
-    self.recv_closeScanner()
-
-  def send_closeScanner(self, scanner):
-    self._oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
-    args = closeScanner_args()
-    args.scanner = scanner
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_closeScanner(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = closeScanner_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    return
-
-  def updateAndFlush(self, login, tableName, cells):
-    """
-    Parameters:
-     - login
-     - tableName
-     - cells
-    """
-    self.send_updateAndFlush(login, tableName, cells)
-    self.recv_updateAndFlush()
-
-  def send_updateAndFlush(self, login, tableName, cells):
-    self._oprot.writeMessageBegin('updateAndFlush', TMessageType.CALL, self._seqid)
-    args = updateAndFlush_args()
-    args.login = login
-    args.tableName = tableName
-    args.cells = cells
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_updateAndFlush(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = updateAndFlush_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.outch1 is not None:
-      raise result.outch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def createWriter(self, login, tableName, opts):
-    """
-    Parameters:
-     - login
-     - tableName
-     - opts
-    """
-    self.send_createWriter(login, tableName, opts)
-    return self.recv_createWriter()
-
-  def send_createWriter(self, login, tableName, opts):
-    self._oprot.writeMessageBegin('createWriter', TMessageType.CALL, self._seqid)
-    args = createWriter_args()
-    args.login = login
-    args.tableName = tableName
-    args.opts = opts
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createWriter(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createWriter_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.outch1 is not None:
-      raise result.outch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "createWriter failed: unknown result");
-
-  def update(self, writer, cells):
-    """
-    Parameters:
-     - writer
-     - cells
-    """
-    self.send_update(writer, cells)
-
-  def send_update(self, writer, cells):
-    self._oprot.writeMessageBegin('update', TMessageType.CALL, self._seqid)
-    args = update_args()
-    args.writer = writer
-    args.cells = cells
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-  def flush(self, writer):
-    """
-    Parameters:
-     - writer
-    """
-    self.send_flush(writer)
-    self.recv_flush()
-
-  def send_flush(self, writer):
-    self._oprot.writeMessageBegin('flush', TMessageType.CALL, self._seqid)
-    args = flush_args()
-    args.writer = writer
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_flush(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = flush_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def closeWriter(self, writer):
-    """
-    Parameters:
-     - writer
-    """
-    self.send_closeWriter(writer)
-    self.recv_closeWriter()
-
-  def send_closeWriter(self, writer):
-    self._oprot.writeMessageBegin('closeWriter', TMessageType.CALL, self._seqid)
-    args = closeWriter_args()
-    args.writer = writer
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_closeWriter(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = closeWriter_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def getRowRange(self, row):
-    """
-    Parameters:
-     - row
-    """
-    self.send_getRowRange(row)
-    return self.recv_getRowRange()
-
-  def send_getRowRange(self, row):
-    self._oprot.writeMessageBegin('getRowRange', TMessageType.CALL, self._seqid)
-    args = getRowRange_args()
-    args.row = row
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getRowRange(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getRowRange_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRowRange failed: unknown result");
-
-  def getFollowing(self, key, part):
-    """
-    Parameters:
-     - key
-     - part
-    """
-    self.send_getFollowing(key, part)
-    return self.recv_getFollowing()
-
-  def send_getFollowing(self, key, part):
-    self._oprot.writeMessageBegin('getFollowing', TMessageType.CALL, self._seqid)
-    args = getFollowing_args()
-    args.key = key
-    args.part = part
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getFollowing(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getFollowing_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFollowing failed: unknown result");
-
-
-class Processor(Iface, TProcessor):
-  def __init__(self, handler):
-    self._handler = handler
-    self._processMap = {}
-    self._processMap["login"] = Processor.process_login
-    self._processMap["addConstraint"] = Processor.process_addConstraint
-    self._processMap["addSplits"] = Processor.process_addSplits
-    self._processMap["attachIterator"] = Processor.process_attachIterator
-    self._processMap["checkIteratorConflicts"] = Processor.process_checkIteratorConflicts
-    self._processMap["clearLocatorCache"] = Processor.process_clearLocatorCache
-    self._processMap["cloneTable"] = Processor.process_cloneTable
-    self._processMap["compactTable"] = Processor.process_compactTable
-    self._processMap["cancelCompaction"] = Processor.process_cancelCompaction
-    self._processMap["createTable"] = Processor.process_createTable
-    self._processMap["deleteTable"] = Processor.process_deleteTable
-    self._processMap["deleteRows"] = Processor.process_deleteRows
-    self._processMap["exportTable"] = Processor.process_exportTable
-    self._processMap["flushTable"] = Processor.process_flushTable
-    self._processMap["getLocalityGroups"] = Processor.process_getLocalityGroups
-    self._processMap["getIteratorSetting"] = Processor.process_getIteratorSetting
-    self._processMap["getMaxRow"] = Processor.process_getMaxRow
-    self._processMap["getTableProperties"] = Processor.process_getTableProperties
-    self._processMap["getSplits"] = Processor.process_getSplits
-    self._processMap["importDirectory"] = Processor.process_importDirectory
-    self._processMap["importTable"] = Processor.process_importTable
-    self._processMap["listTables"] = Processor.process_listTables
-    self._processMap["listIterators"] = Processor.process_listIterators
-    self._processMap["listConstraints"] = Processor.process_listConstraints
-    self._processMap["mergeTablets"] = Processor.process_mergeTablets
-    self._processMap["offlineTable"] = Processor.process_offlineTable
-    self._processMap["onlineTable"] = Processor.process_onlineTable
-    self._processMap["removeConstraint"] = Processor.process_removeConstraint
-    self._processMap["removeIterator"] = Processor.process_removeIterator
-    self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
-    self._processMap["renameTable"] = Processor.process_renameTable
-    self._processMap["setLocalityGroups"] = Processor.process_setLocalityGroups
-    self._processMap["setTableProperty"] = Processor.process_setTableProperty
-    self._processMap["splitRangeByTablets"] = Processor.process_splitRangeByTablets
-    self._processMap["tableExists"] = Processor.process_tableExists
-    self._processMap["tableIdMap"] = Processor.process_tableIdMap
-    self._processMap["pingTabletServer"] = Processor.process_pingTabletServer
-    self._processMap["getActiveScans"] = Processor.process_getActiveScans
-    self._processMap["getActiveCompactions"] = Processor.process_getActiveCompactions
-    self._processMap["getSiteConfiguration"] = Processor.process_getSiteConfiguration
-    self._processMap["getSystemConfiguration"] = Processor.process_getSystemConfiguration
-    self._processMap["getTabletServers"] = Processor.process_getTabletServers
-    self._processMap["removeProperty"] = Processor.process_removeProperty
-    self._processMap["setProperty"] = Processor.process_setProperty
-    self._processMap["testClassLoad"] = Processor.process_testClassLoad
-    self._processMap["authenticateUser"] = Processor.process_authenticateUser
-    self._processMap["changeUserAuthorizations"] = Processor.process_changeUserAuthorizations
-    self._processMap["changeLocalUserPassword"] = Processor.process_changeLocalUserPassword
-    self._processMap["createLocalUser"] = Processor.process_createLocalUser
-    self._processMap["dropLocalUser"] = Processor.process_dropLocalUser
-    self._processMap["getUserAuthorizations"] = Processor.process_getUserAuthorizations
-    self._processMap["grantSystemPermission"] = Processor.process_grantSystemPermission
-    self._processMap["grantTablePermission"] = Processor.process_grantTablePermission
-    self._processMap["hasSystemPermission"] = Processor.process_hasSystemPermission
-    self._processMap["hasTablePermission"] = Processor.process_hasTablePermission
-    self._processMap["listLocalUsers"] = Processor.process_listLocalUsers
-    self._processMap["revokeSystemPermission"] = Processor.process_revokeSystemPermission
-    self._processMap["revokeTablePermission"] = Processor.process_revokeTablePermission
-    self._processMap["createBatchScanner"] = Processor.process_createBatchScanner
-    self._processMap["createScanner"] = Processor.process_createScanner
-    self._processMap["hasNext"] = Processor.process_hasNext
-    self._processMap["nextEntry"] = Processor.process_nextEntry
-    self._processMap["nextK"] = Processor.process_nextK
-    self._processMap["closeScanner"] = Processor.process_closeScanner
-    self._processMap["updateAndFlush"] = Processor.process_updateAndFlush
-    self._processMap["createWriter"] = Processor.process_createWriter
-    self._processMap["update"] = Processor.process_update
-    self._processMap["flush"] = Processor.process_flush
-    self._processMap["closeWriter"] = Processor.process_closeWriter
-    self._processMap["getRowRange"] = Processor.process_getRowRange
-    self._processMap["getFollowing"] = Processor.process_getFollowing
-
-  def process(self, iprot, oprot):
-    (name, type, seqid) = iprot.readMessageBegin()
-    if name not in self._processMap:
-      iprot.skip(TType.STRUCT)
-      iprot.readMessageEnd()
-      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
-      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
-      x.write(oprot)
-      oprot.writeMessageEnd()
-      oprot.trans.flush()
-      return
-    else:
-      self._processMap[name](self, seqid, iprot, oprot)
-    return True
-
-  def process_login(self, seqid, iprot, oprot):
-    args = login_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = login_result()
-    try:
-      result.success = self._handler.login(args.principal, args.loginProperties)
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("login", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_addConstraint(self, seqid, iprot, oprot):
-    args = addConstraint_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = addConstraint_result()
-    try:
-      result.success = self._handler.addConstraint(args.login, args.tableName, args.constraintClassName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("addConstraint", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_addSplits(self, seqid, iprot, oprot):
-    args = addSplits_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = addSplits_result()
-    try:
-      self._handler.addSplits(args.login, args.tableName, args.splits)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("addSplits", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_attachIterator(self, seqid, iprot, oprot):
-    args = attachIterator_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = attachIterator_result()
-    try:
-      self._handler.attachIterator(args.login, args.tableName, args.setting, args.scopes)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("attachIterator", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_checkIteratorConflicts(self, seqid, iprot, oprot):
-    args = checkIteratorConflicts_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = checkIteratorConflicts_result()
-    try:
-      self._handler.checkIteratorConflicts(args.login, args.tableName, args.setting, args.scopes)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("checkIteratorConflicts", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_clearLocatorCache(self, seqid, iprot, oprot):
-    args = clearLocatorCache_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = clearLocatorCache_result()
-    try:
-      self._handler.clearLocatorCache(args.login, args.tableName)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("clearLocatorCache", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_cloneTable(self, seqid, iprot, oprot):
-    args = cloneTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = cloneTable_result()
-    try:
-      self._handler.cloneTable(args.login, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    except TableExistsException as ouch4:
-      result.ouch4 = ouch4
-    oprot.writeMessageBegin("cloneTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_compactTable(self, seqid, iprot, oprot):
-    args = compactTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = compactTable_result()
-    try:
-      self._handler.compactTable(args.login, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("compactTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_cancelCompaction(self, seqid, iprot, oprot):
-    args = cancelCompaction_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = cancelCompaction_result()
-    try:
-      self._handler.cancelCompaction(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("cancelCompaction", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createTable(self, seqid, iprot, oprot):
-    args = createTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createTable_result()
-    try:
-      self._handler.createTable(args.login, args.tableName, args.versioningIter, args.type)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableExistsException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("createTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_deleteTable(self, seqid, iprot, oprot):
-    args = deleteTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = deleteTable_result()
-    try:
-      self._handler.deleteTable(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("deleteTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_deleteRows(self, seqid, iprot, oprot):
-    args = deleteRows_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = deleteRows_result()
-    try:
-      self._handler.deleteRows(args.login, args.tableName, args.startRow, args.endRow)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("deleteRows", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_exportTable(self, seqid, iprot, oprot):
-    args = exportTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = exportTable_result()
-    try:
-      self._handler.exportTable(args.login, args.tableName, args.exportDir)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("exportTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_flushTable(self, seqid, iprot, oprot):
-    args = flushTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = flushTable_result()
-    try:
-      self._handler.flushTable(args.login, args.tableName, args.startRow, args.endRow, args.wait)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("flushTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getLocalityGroups(self, seqid, iprot, oprot):
-    args = getLocalityGroups_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getLocalityGroups_result()
-    try:
-      result.success = self._handler.getLocalityGroups(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getLocalityGroups", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getIteratorSetting(self, seqid, iprot, oprot):
-    args = getIteratorSetting_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getIteratorSetting_result()
-    try:
-      result.success = self._handler.getIteratorSetting(args.login, args.tableName, args.iteratorName, args.scope)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("getIteratorSetting", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getMaxRow(self, seqid, iprot, oprot):
-    args = getMaxRow_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getMaxRow_result()
-    try:
-      result.success = self._handler.getMaxRow(args.login, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("getMaxRow", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getTableProperties(self, seqid, iprot, oprot):
-    args = getTableProperties_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getTableProperties_result()
-    try:
-      result.success = self._handler.getTableProperties(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getTableProperties", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getSplits(self, seqid, iprot, oprot):
-    args = getSplits_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getSplits_result()
-    try:
-      result.success = self._handler.getSplits(args.login, args.tableName, args.maxSplits)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("getSplits", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_importDirectory(self, seqid, iprot, oprot):
-    args = importDirectory_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = importDirectory_result()
-    try:
-      self._handler.importDirectory(args.login, args.tableName, args.importDir, args.failureDir, args.setTime)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    except AccumuloSecurityException as ouch4:
-      result.ouch4 = ouch4
-    oprot.writeMessageBegin("importDirectory", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_importTable(self, seqid, iprot, oprot):
-    args = importTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = importTable_result()
-    try:
-      self._handler.importTable(args.login, args.tableName, args.importDir)
-    except TableExistsException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("importTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listTables(self, seqid, iprot, oprot):
-    args = listTables_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listTables_result()
-    result.success = self._handler.listTables(args.login)
-    oprot.writeMessageBegin("listTables", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listIterators(self, seqid, iprot, oprot):
-    args = listIterators_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listIterators_result()
-    try:
-      result.success = self._handler.listIterators(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("listIterators", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listConstraints(self, seqid, iprot, oprot):
-    args = listConstraints_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listConstraints_result()
-    try:
-      result.success = self._handler.listConstraints(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("listConstraints", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_mergeTablets(self, seqid, iprot, oprot):
-    args = mergeTablets_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = mergeTablets_result()
-    try:
-      self._handler.mergeTablets(args.login, args.tableName, args.startRow, args.endRow)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("mergeTablets", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_offlineTable(self, seqid, iprot, oprot):
-    args = offlineTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = offlineTable_result()
-    try:
-      self._handler.offlineTable(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("offlineTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_onlineTable(self, seqid, iprot, oprot):
-    args = onlineTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = onlineTable_result()
-    try:
-      self._handler.onlineTable(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("onlineTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeConstraint(self, seqid, iprot, oprot):
-    args = removeConstraint_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeConstraint_result()
-    try:
-      self._handler.removeConstraint(args.login, args.tableName, args.constraint)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("removeConstraint", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeIterator(self, seqid, iprot, oprot):
-    args = removeIterator_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeIterator_result()
-    try:
-      self._handler.removeIterator(args.login, args.tableName, args.iterName, args.scopes)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("removeIterator", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeTableProperty(self, seqid, iprot, oprot):
-    args = removeTableProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeTableProperty_result()
-    try:
-      self._handler.removeTableProperty(args.login, args.tableName, args.property)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("removeTableProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_renameTable(self, seqid, iprot, oprot):
-    args = renameTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = renameTable_result()
-    try:
-      self._handler.renameTable(args.login, args.oldTableName, args.newTableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    except TableExistsException as ouch4:
-      result.ouch4 = ouch4
-    oprot.writeMessageBegin("renameTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_setLocalityGroups(self, seqid, iprot, oprot):
-    args = setLocalityGroups_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = setLocalityGroups_result()
-    try:
-      self._handler.setLocalityGroups(args.login, args.tableName, args.groups)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("setLocalityGroups", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_setTableProperty(self, seqid, iprot, oprot):
-    args = setTableProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = setTableProperty_result()
-    try:
-      self._handler.setTableProperty(args.login, args.tableName, args.property, args.value)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("setTableProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_splitRangeByTablets(self, seqid, iprot, oprot):
-    args = splitRangeByTablets_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = splitRangeByTablets_result()
-    try:
-      result.success = self._handler.splitRangeByTablets(args.login, args.tableName, args.range, args.maxSplits)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("splitRangeByTablets", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_tableExists(self, seqid, iprot, oprot):
-    args = tableExists_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = tableExists_result()
-    result.success = self._handler.tableExists(args.login, args.tableName)
-    oprot.writeMessageBegin("tableExists", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_tableIdMap(self, seqid, iprot, oprot):
-    args = tableIdMap_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = tableIdMap_result()
-    result.success = self._handler.tableIdMap(args.login)
-    oprot.writeMessageBegin("tableIdMap", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_pingTabletServer(self, seqid, iprot, oprot):
-    args = pingTabletServer_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = pingTabletServer_result()
-    try:
-      self._handler.pingTabletServer(args.login, args.tserver)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("pingTabletServer", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getActiveScans(self, seqid, iprot, oprot):
-    args = getActiveScans_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getActiveScans_result()
-    try:
-      result.success = self._handler.getActiveScans(args.login, args.tserver)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getActiveScans", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getActiveCompactions(self, seqid, iprot, oprot):
-    args = getActiveCompactions_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getActiveCompactions_result()
-    try:
-      result.success = self._handler.getActiveCompactions(args.login, args.tserver)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getActiveCompactions", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getSiteConfiguration(self, seqid, iprot, oprot):
-    args = getSiteConfiguration_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getSiteConfiguration_result()
-    try:
-      result.success = self._handler.getSiteConfiguration(args.login)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getSiteConfiguration", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getSystemConfiguration(self, seqid, iprot, oprot):
-    args = getSystemConfiguration_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getSystemConfiguration_result()
-    try:
-      result.success = self._handler.getSystemConfiguration(args.login)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getSystemConfiguration", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getTabletServers(self, seqid, iprot, oprot):
-    args = getTabletServers_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getTabletServers_result()
-    result.success = self._handler.getTabletServers(args.login)
-    oprot.writeMessageBegin("getTabletServers", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeProperty(self, seqid, iprot, oprot):
-    args = removeProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeProperty_result()
-    try:
-      self._handler.removeProperty(args.login, args.property)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("removeProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_setProperty(self, seqid, iprot, oprot):
-    args = setProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = setProperty_result()
-    try:
-      self._handler.setProperty(args.login, args.property, args.value)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("setProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_testClassLoad(self, seqid, iprot, oprot):
-    args = testClassLoad_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = testClassLoad_result()
-    try:
-      result.success = self._handler.testClassLoad(args.login, args.className, args.asTypeName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("testClassLoad", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_authenticateUser(self, seqid, iprot, oprot):
-    args = authenticateUser_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = authenticateUser_result()
-    try:
-      result.success = self._handler.authenticateUser(args.login, args.user, args.properties)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("authenticateUser", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_changeUserAuthorizations(self, seqid, iprot, oprot):
-    args = changeUserAuthorizations_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = changeUserAuthorizations_result()
-    try:
-      self._handler.changeUserAuthorizations(args.login, args.user, args.authorizations)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("changeUserAuthorizations", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_changeLocalUserPassword(self, seqid, iprot, oprot):
-    args = changeLocalUserPassword_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = changeLocalUserPassword_result()
-    try:
-      self._handler.changeLocalUserPassword(args.login, args.user, args.password)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("changeLocalUserPassword", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createLocalUser(self, seqid, iprot, oprot):
-    args = createLocalUser_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createLocalUser_result()
-    try:
-      self._handler.createLocalUser(args.login, args.user, args.password)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createLocalUser", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_dropLocalUser(self, seqid, iprot, oprot):
-    args = dropLocalUser_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = dropLocalUser_result()
-    try:
-      self._handler.dropLocalUser(args.login, args.user)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("dropLocalUser", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getUserAuthorizations(self, seqid, iprot, oprot):
-    args = getUserAuthorizations_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getUserAuthorizations_result()
-    try:
-      result.success = self._handler.getUserAuthorizations(args.login, args.user)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getUserAuthorizations", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_grantSystemPermission(self, seqid, iprot, oprot):
-    args = grantSystemPermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = grantSystemPermission_result()
-    try:
-      self._handler.grantSystemPermission(args.login, args.user, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("grantSystemPermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_grantTablePermission(self, seqid, iprot, oprot):
-    args = grantTablePermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = grantTablePermission_result()
-    try:
-      self._handler.grantTablePermission(args.login, args.user, args.table, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("grantTablePermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_hasSystemPermission(self, seqid, iprot, oprot):
-    args = hasSystemPermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = hasSystemPermission_result()
-    try:
-      result.success = self._handler.hasSystemPermission(args.login, args.user, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("hasSystemPermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_hasTablePermission(self, seqid, iprot, oprot):
-    args = hasTablePermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = hasTablePermission_result()
-    try:
-      result.success = self._handler.hasTablePermission(args.login, args.user, args.table, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("hasTablePermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listLocalUsers(self, seqid, iprot, oprot):
-    args = listLocalUsers_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listLocalUsers_result()
-    try:
-      result.success = self._handler.listLocalUsers(args.login)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("listLocalUsers", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_revokeSystemPermission(self, seqid, iprot, oprot):
-    args = revokeSystemPermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = revokeSystemPermission_result()
-    try:
-      self._handler.revokeSystemPermission(args.login, args.user, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("revokeSystemPermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_revokeTablePermission(self, seqid, iprot, oprot):
-    args = revokeTablePermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = revokeTablePermission_result()
-    try:
-      self._handler.revokeTablePermission(args.login, args.user, args.table, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("revokeTablePermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createBatchScanner(self, seqid, iprot, oprot):
-    args = createBatchScanner_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createBatchScanner_result()
-    try:
-      result.success = self._handler.createBatchScanner(args.login, args.tableName, args.options)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createBatchScanner", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createScanner(self, seqid, iprot, oprot):
-    args = createScanner_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createScanner_result()
-    try:
-      result.success = self._handler.createScanner(args.login, args.tableName, args.options)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createScanner", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_hasNext(self, seqid, iprot, oprot):
-    args = hasNext_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = hasNext_result()
-    try:
-      result.success = self._handler.hasNext(args.scanner)
-    except UnknownScanner as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("hasNext", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_nextEntry(self, seqid, iprot, oprot):
-    args = nextEntry_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = nextEntry_result()
-    try:
-      result.success = self._handler.nextEntry(args.scanner)
-    except NoMoreEntriesException as ouch1:
-      result.ouch1 = ouch1
-    except UnknownScanner as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("nextEntry", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_nextK(self, seqid, iprot, oprot):
-    args = nextK_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = nextK_result()
-    try:
-      result.success = self._handler.nextK(args.scanner, args.k)
-    except NoMoreEntriesException as ouch1:
-      result.ouch1 = ouch1
-    except UnknownScanner as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("nextK", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_closeScanner(self, seqid, iprot, oprot):
-    args = closeScanner_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = closeScanner_result()
-    try:
-      self._handler.closeScanner(args.scanner)
-    except UnknownScanner as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("closeScanner", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_updateAndFlush(self, seqid, iprot, oprot):
-    args = updateAndFlush_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = updateAndFlush_result()
-    try:
-      self._handler.updateAndFlush(args.login, args.tableName, args.cells)
-    except AccumuloException as outch1:
-      result.outch1 = outch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("updateAndFlush", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createWriter(self, seqid, iprot, oprot):
-    args = createWriter_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createWriter_result()
-    try:
-      result.success = self._handler.createWriter(args.login, args.tableName, args.opts)
-    except AccumuloException as outch1:
-      result.outch1 = outch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createWriter", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_update(self, seqid, iprot, oprot):
-    args = update_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    self._handler.update(args.writer, args.cells)
-    return
-
-  def process_flush(self, seqid, iprot, oprot):
-    args = flush_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = flush_result()
-    try:
-      self._handler.flush(args.writer)
-    except UnknownWriter as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("flush", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_closeWriter(self, seqid, iprot, oprot):
-    args = closeWriter_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = closeWriter_result()
-    try:
-      self._handler.closeWriter(args.writer)
-    except UnknownWriter as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("closeWriter", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getRowRange(self, seqid, iprot, oprot):
-    args = getRowRange_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getRowRange_result()
-    result.success = self._handler.getRowRange(args.row)
-    oprot.writeMessageBegin("getRowRange", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getFollowing(self, seqid, iprot, oprot):
-    args = getFollowing_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getFollowing_result()
-    result.success = self._handler.getFollowing(args.key, args.part)
-    oprot.writeMessageBegin("getFollowing", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-
-# HELPER FUNCTIONS AND STRUCTURES
-
-class login_args:
-  """
-  Attributes:
-   - principal
-   - loginProperties
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'principal', None, None, ), # 1
-    (2, TType.MAP, 'loginProperties', (TType.STRING,None,TType.STRING,None), None, ), # 2
-  )
-
-  def __init__(self, principal=None, loginProperties=None,):
-    self.principal = principal
-    self.loginProperties = loginProperties
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.principal = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.MAP:
-          self.loginProperties = {}
-          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin() 
-          for _i104 in xrange(_size100):
-            _key105 = iprot.readString();
-            _val106 = iprot.readString();
-            self.loginProperties[_key105] = _val106
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('login_args')
-    if self.principal is not None:
-      oprot.writeFieldBegin('principal', TType.STRING, 1)
-      oprot.writeString(self.principal)
-      oprot.writeFieldEnd()
-    if self.loginProperties is not None:
-      oprot.writeFieldBegin('loginProperties', TType.MAP, 2)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.loginProperties))
-      for kiter107,viter108 in self.loginProperties.items():
-        oprot.writeString(kiter107)
-        oprot.writeString(viter108)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class login_result:
-  """
-  Attributes:
-   - success
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, success=None, ouch2=None,):
-    self.success = success
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('login_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 1)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addConstraint_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - constraintClassName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'constraintClassName', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, constraintClassName=None,):
-    self.login = login
-    self.tableName = tableName
-    self.constraintClassName = constraintClassName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.constraintClassName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addConstraint_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.constraintClassName is not None:
-      oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
-      oprot.writeString(self.constraintClassName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addConstraint_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.I32, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.I32:
-          self.success = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addConstraint_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.I32, 0)
-      oprot.writeI32(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addSplits_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - splits
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.SET, 'splits', (TType.STRING,None), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, splits=None,):
-    self.login = login
-    self.tableName = tableName
-    self.splits = splits
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.SET:
-          self.splits = set()
-          (_etype112, _size109) = iprot.readSetBegin()
-          for _i113 in xrange(_size109):
-            _elem114 = iprot.readString();
-            self.splits.add(_elem114)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addSplits_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.splits is not None:
-      oprot.writeFieldBegin('splits', TType.SET, 3)
-      oprot.writeSetBegin(TType.STRING, len(self.splits))
-      for iter115 in self.splits:
-        oprot.writeString(iter115)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addSplits_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addSplits_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class attachIterator_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - setting
-   - scopes
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 3
-    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
-    self.login = login
-    self.tableName = tableName
-    self.setting = setting
-    self.scopes = scopes
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.setting = IteratorSetting()
-          self.setting.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.SET:
-          self.scopes = set()
-          (_etype119, _size116) = iprot.readSetBegin()
-          for _i120 in xrange(_size116):
-            _elem121 = iprot.readI32();
-            self.scopes.add(_elem121)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('attachIterator_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.setting is not None:
-      oprot.writeFieldBegin('setting', TType.STRUCT, 3)
-      self.setting.write(oprot)
-      oprot.writeFieldEnd()
-    if self.scopes is not None:
-      oprot.writeFieldBegin('scopes', TType.SET, 4)
-      oprot.writeSetBegin(TType.I32, len(self.scopes))
-      for iter122 in self.scopes:
-        oprot.writeI32(iter122)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class attachIterator_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('attachIterator_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class checkIteratorConflicts_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - setting
-   - scopes
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 3
-    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
-    self.login = login
-    self.tableName = tableName
-    self.setting = setting
-    self.scopes = scopes
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.setting = IteratorSetting()
-          self.setting.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.SET:
-          self.scopes = set()
-          (_etype126, _size123) = iprot.readSetBegin()
-          for _i127 in xrange(_size123):
-            _elem128 = iprot.readI32();
-            self.scopes.add(_elem128)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('checkIteratorConflicts_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.setting is not None:
-      oprot.writeFieldBegin('setting', TType.STRUCT, 3)
-      self.setting.write(oprot)
-      oprot.writeFieldEnd()
-    if self.scopes is not None:
-      oprot.writeFieldBegin('scopes', TType.SET, 4)
-      oprot.writeSetBegin(TType.I32, len(self.scopes))
-      for iter129 in self.scopes:
-        oprot.writeI32(iter129)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class checkIteratorConflicts_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('checkIteratorConflicts_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class clearLocatorCache_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('clearLocatorCache_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class clearLocatorCache_result:
-  """
-  Attributes:
-   - ouch1
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, ouch1=None,):
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('clearLocatorCache_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cloneTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - newTableName
-   - flush
-   - propertiesToSet
-   - propertiesToExclude
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'newTableName', None, None, ), # 3
-    (4, TType.BOOL, 'flush', None, None, ), # 4
-    (5, TType.MAP, 'propertiesToSet', (TType.STRING,None,TType.STRING,None), None, ), # 5
-    (6, TType.SET, 'propertiesToExclude', (TType.STRING,None), None, ), # 6
-  )
-
-  def __init__(self, login=None, tableName=None, newTableName=None, flush=None, propertiesToSet=None, propertiesToExclude=None,):
-    self.login = login
-    self.tableName = tableName
-    self.newTableName = newTableName
-    self.flush = flush
-    self.propertiesToSet = propertiesToSet
-    self.propertiesToExclude = propertiesToExclude
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.newTableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.BOOL:
-          self.flush = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.MAP:
-          self.propertiesToSet = {}
-          (_ktype131, _vtype132, _size130 ) = iprot.readMapBegin() 
-          for _i134 in xrange(_size130):
-            _key135 = iprot.readString();
-            _val136 = iprot.readString();
-            self.propertiesToSet[_key135] = _val136
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.SET:
-          self.propertiesToExclude = set()
-          (_etype140, _size137) = iprot.readSetBegin()
-          for _i141 in xrange(_size137):
-            _elem142 = iprot.readString();
-            self.propertiesToExclude.add(_elem142)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cloneTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.newTableName is not None:
-      oprot.writeFieldBegin('newTableName', TType.STRING, 3)
-      oprot.writeString(self.newTableName)
-      oprot.writeFieldEnd()
-    if self.flush is not None:
-      oprot.writeFieldBegin('flush', TType.BOOL, 4)
-      oprot.writeBool(self.flush)
-      oprot.writeFieldEnd()
-    if self.propertiesToSet is not None:
-      oprot.writeFieldBegin('propertiesToSet', TType.MAP, 5)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.propertiesToSet))
-      for kiter143,viter144 in self.propertiesToSet.items():
-        oprot.writeString(kiter143)
-        oprot.writeString(viter144)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.propertiesToExclude is not None:
-      oprot.writeFieldBegin('propertiesToExclude', TType.SET, 6)
-      oprot.writeSetBegin(TType.STRING, len(self.propertiesToExclude))
-      for iter145 in self.propertiesToExclude:
-        oprot.writeString(iter145)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cloneTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-   - ouch4
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-    (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ), # 4
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-    self.ouch4 = ouch4
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRUCT:
-          self.ouch4 = TableExistsException()
-          self.ouch4.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cloneTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch4 is not None:
-      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
-      self.ouch4.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class compactTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-   - iterators
-   - flush
-   - wait
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-    (5, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 5
-    (6, TType.BOOL, 'flush', None, None, ), # 6
-    (7, TType.BOOL, 'wait', None, None, ), # 7
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None, iterators=None, flush=None, wait=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-    self.iterators = iterators
-    self.flush = flush
-    self.wait = wait
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype149, _size146) = iprot.readListBegin()
-          for _i150 in xrange(_size146):
-            _elem151 = IteratorSetting()
-            _elem151.read(iprot)
-            self.iterators.append(_elem151)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.BOOL:
-          self.flush = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.BOOL:
-          self.wait = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('compactTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 5)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter152 in self.iterators:
-        iter152.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.flush is not None:
-      oprot.writeFieldBegin('flush', TType.BOOL, 6)
-      oprot.writeBool(self.flush)
-      oprot.writeFieldEnd()
-    if self.wait is not None:
-      oprot.writeFieldBegin('wait', TType.BOOL, 7)
-      oprot.writeBool(self.wait)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class compactTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('compactTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cancelCompaction_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cancelCompaction_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cancelCompaction_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cancelCompaction_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - versioningIter
-   - type
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.BOOL, 'versioningIter', None, None, ), # 3
-    (4, TType.I32, 'type', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, versioningIter=None, type=None,):
-    self.login = login
-    self.tableName = tableName
-    self.versioningIter = versioningIter
-    self.type = type
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.BOOL:
-          self.versioningIter = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.type = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.versioningIter is not None:
-      oprot.writeFieldBegin('versioningIter', TType.BOOL, 3)
-      oprot.writeBool(self.versioningIter)
-      oprot.writeFieldEnd()
-    if self.type is not None:
-      oprot.writeFieldBegin('type', TType.I32, 4)
-      oprot.writeI32(self.type)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableExistsException, TableExistsException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableExistsException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteRows_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteRows_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteRows_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteRows_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class exportTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - exportDir
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'exportDir', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, exportDir=None,):
-    self.login = login
-    self.tableName = tableName
-    self.exportDir = exportDir
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.exportDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('exportTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.exportDir is not None:
-      oprot.writeFieldBegin('exportDir', TType.STRING, 3)
-      oprot.writeString(self.exportDir)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class exportTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('exportTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flushTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-   - wait
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-    (5, TType.BOOL, 'wait', None, None, ), # 5
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None, wait=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-    self.wait = wait
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.BOOL:
-          self.wait = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flushTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.wait is not None:
-      oprot.writeFieldBegin('wait', TType.BOOL, 5)
-      oprot.writeBool(self.wait)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flushTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flushTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getLocalityGroups_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getLocalityGroups_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getLocalityGroups_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRING,None)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype154, _vtype155, _size153 ) = iprot.readMapBegin() 
-          for _i157 in xrange(_size153):
-            _key158 = iprot.readString();
-            _val159 = set()
-            (_etype163, _size160) = iprot.readSetBegin()
-            for _i164 in xrange(_size160):
-              _elem165 = iprot.readString();
-              _val159.add(_elem165)
-            iprot.readSetEnd()
-            self.success[_key158] = _val159
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getLocalityGroups_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
-      for kiter166,viter167 in self.success.items():
-        oprot.writeString(kiter166)
-        oprot.writeSetBegin(TType.STRING, len(viter167))
-        for iter168 in viter167:
-          oprot.writeString(iter168)
-        oprot.writeSetEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getIteratorSetting_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - iteratorName
-   - scope
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'iteratorName', None, None, ), # 3
-    (4, TType.I32, 'scope', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, iteratorName=None, scope=None,):
-    self.login = login
-    self.tableName = tableName
-    self.iteratorName = iteratorName
-    self.scope = scope
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.iteratorName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.scope = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getIteratorSetting_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.iteratorName is not None:
-      oprot.writeFieldBegin('iteratorName', TType.STRING, 3)
-      oprot.writeString(self.iteratorName)
-      oprot.writeFieldEnd()
-    if self.scope is not None:
-      oprot.writeFieldBegin('scope', TType.I32, 4)
-      oprot.writeI32(self.scope)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getIteratorSetting_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = IteratorSetting()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getIteratorSetting_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getMaxRow_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - auths
-   - startRow
-   - startInclusive
-   - endRow
-   - endInclusive
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.SET, 'auths', (TType.STRING,None), None, ), # 3
-    (4, TType.STRING, 'startRow', None, None, ), # 4
-    (5, TType.BOOL, 'startInclusive', None, None, ), # 5
-    (6, TType.STRING, 'endRow', None, None, ), # 6
-    (7, TType.BOOL, 'endInclusive', None, None, ), # 7
-  )
-
-  def __init__(self, login=None, tableName=None, auths=None, startRow=None, startInclusive=None, endRow=None, endInclusive=None,):
-    self.login = login
-    self.tableName = tableName
-    self.auths = auths
-    self.startRow = startRow
-    self.startInclusive = startInclusive
-    self.endRow = endRow
-    self.endInclusive = endInclusive
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.SET:
-          self.auths = set()
-          (_etype172, _size169) = iprot.readSetBegin()
-          for _i173 in xrange(_size169):
-            _elem174 = iprot.readString();
-            self.auths.add(_elem174)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.BOOL:
-          self.startInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.BOOL:
-          self.endInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getMaxRow_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.auths is not None:
-      oprot.writeFieldBegin('auths', TType.SET, 3)
-      oprot.writeSetBegin(TType.STRING, len(self.auths))
-      for iter175 in self.auths:
-        oprot.writeString(iter175)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 4)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.startInclusive is not None:
-      oprot.writeFieldBegin('startInclusive', TType.BOOL, 5)
-      oprot.writeBool(self.startInclusive)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 6)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.endInclusive is not None:
-      oprot.writeFieldBegin('endInclusive', TType.BOOL, 7)
-      oprot.writeBool(self.endInclusive)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getMaxRow_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getMaxRow_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTableProperties_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTableProperties_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTableProperties_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype177, _vtype178, _size176 ) = iprot.readMapBegin() 
-          for _i180 in xrange(_size176):
-            _key181 = iprot.readString();
-            _val182 = iprot.readString();
-            self.success[_key181] = _val182
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTableProperties_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter183,viter184 in self.success.items():
-        oprot.writeString(kiter183)
-        oprot.writeString(viter184)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSplits_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - maxSplits
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.I32, 'maxSplits', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, maxSplits=None,):
-    self.login = login
-    self.tableName = tableName
-    self.maxSplits = maxSplits
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.maxSplits = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSplits_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.maxSplits is not None:
-      oprot.writeFieldBegin('maxSplits', TType.I32, 3)
-      oprot.writeI32(self.maxSplits)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSplits_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, success=None, ouch1=None,):
-    self.success = success
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype188, _size185) = iprot.readListBegin()
-          for _i189 in xrange(_size185):
-            _elem190 = iprot.readString();
-            self.success.append(_elem190)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSplits_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRING, len(self.success))
-      for iter191 in self.success:
-        oprot.writeString(iter191)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importDirectory_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - importDir
-   - failureDir
-   - setTime
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'importDir', None, None, ), # 3
-    (4, TType.STRING, 'failureDir', None, None, ), # 4
-    (5, TType.BOOL, 'setTime', None, None, ), # 5
-  )
-
-  def __init__(self, login=None, tableName=None, importDir=None, failureDir=None, setTime=None,):
-    self.login = login
-    self.tableName = tableName
-    self.importDir = importDir
-    self.failureDir = failureDir
-    self.setTime = setTime
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.importDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.failureDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.BOOL:
-          self.setTime = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importDirectory_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.importDir is not None:
-      oprot.writeFieldBegin('importDir', TType.STRING, 3)
-      oprot.writeString(self.importDir)
-      oprot.writeFieldEnd()
-    if self.failureDir is not None:
-      oprot.writeFieldBegin('failureDir', TType.STRING, 4)
-      oprot.writeString(self.failureDir)
-      oprot.writeFieldEnd()
-    if self.setTime is not None:
-      oprot.writeFieldBegin('setTime', TType.BOOL, 5)
-      oprot.writeBool(self.setTime)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importDirectory_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch3
-   - ouch4
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch4', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch3=None, ouch4=None,):
-    self.ouch1 = ouch1
-    self.ouch3 = ouch3
-    self.ouch4 = ouch4
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch4 = AccumuloSecurityException()
-          self.ouch4.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importDirectory_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 2)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch4 is not None:
-      oprot.writeFieldBegin('ouch4', TType.STRUCT, 3)
-      self.ouch4.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - importDir
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'importDir', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, importDir=None,):
-    self.login = login
-    self.tableName = tableName
-    self.importDir = importDir
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.importDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.importDir is not None:
-      oprot.writeFieldBegin('importDir', TType.STRING, 3)
-      oprot.writeString(self.importDir)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableExistsException, TableExistsException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableExistsException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listTables_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listTables_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listTables_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.SET:
-          self.success = set()
-          (_etype195, _size192) = iprot.readSetBegin()
-          for _i196 in xrange(_size192):
-            _elem197 = iprot.readString();
-            self.success.add(_elem197)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listTables_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.SET, 0)
-      oprot.writeSetBegin(TType.STRING, len(self.success))
-      for iter198 in self.success:
-        oprot.writeString(iter198)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listIterators_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listIterators_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listIterators_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.I32,None)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype200, _vtype201, _size199 ) = iprot.readMapBegin() 
-          for _i203 in xrange(_size199):
-            _key204 = iprot.readString();
-            _val205 = set()
-            (_etype209, _size206) = iprot.readSetBegin()
-            for _i210 in xrange(_size206):
-              _elem211 = iprot.readI32();
-              _val205.add(_elem211)
-            iprot.readSetEnd()
-            self.success[_key204] = _val205
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listIterators_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
-      for kiter212,viter213 in self.success.items():
-        oprot.writeString(kiter212)
-        oprot.writeSetBegin(TType.I32, len(viter213))
-        for iter214 in viter213:
-          oprot.writeI32(iter214)
-        oprot.writeSetEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listConstraints_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listConstraints_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listConstraints_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.I32,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype216, _vtype217, _size215 ) = iprot.readMapBegin() 
-          for _i219 in xrange(_size215):
-            _key220 = iprot.readString();
-            _val221 = iprot.readI32();
-            self.success[_key220] = _val221
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listConstraints_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
-      for kiter222,viter223 in self.success.items():
-        oprot.writeString(kiter222)
-        oprot.writeI32(viter223)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class mergeTablets_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('mergeTablets_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class mergeTablets_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('mergeTablets_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class offlineTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('offlineTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class offlineTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('offlineTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class onlineTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('onlineTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class onlineTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('onlineTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeConstraint_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - constraint
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.I32, 'constraint', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, constraint=None,):
-    self.login = login
-    self.tableName = tableName
-    self.constraint = constraint
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.constraint = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeConstraint_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.constraint is not None:
-      oprot.writeFieldBegin('constraint', TType.I32, 3)
-      oprot.writeI32(self.constraint)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeConstraint_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeConstraint_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeIterator_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - iterName
-   - scopes
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'iterName', None, None, ), # 3
-    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, iterName=None, scopes=None,):
-    self.login = login
-    self.tableName = tableName
-    self.iterName = iterName
-    self.scopes = scopes
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.iterName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.SET:
-          self.scopes = set()
-          (_etype227, _size224) = iprot.readSetBegin()
-          for _i228 in xrange(_size224):
-            _elem229 = iprot.readI32();
-            self.scopes.add(_elem229)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeIterator_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.iterName is not None:
-      oprot.writeFieldBegin('iterName', TType.STRING, 3)
-      oprot.writeString(self.iterName)
-      oprot.writeFieldEnd()
-    if self.scopes is not None:
-      oprot.writeFieldBegin('scopes', TType.SET, 4)
-      oprot.writeSetBegin(TType.I32, len(self.scopes))
-      for iter230 in self.scopes:
-        oprot.writeI32(iter230)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeIterator_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeIterator_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeTableProperty_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - property
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'property', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, property=None,):
-    self.login = login
-    self.tableName = tableName
-    self.property = property
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeTableProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 3)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeTableProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeTableProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class renameTable_args:
-  """
-  Attributes:
-   - login
-   - oldTableName
-   - newTableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'oldTableName', None, None, ), # 2
-    (3, TType.STRING, 'newTableName', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, oldTableName=None, newTableName=None,):
-    self.login = login
-    self.oldTableName = oldTableName
-    self.newTableName = newTableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.oldTableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.newTableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('renameTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.oldTableName is not None:
-      oprot.writeFieldBegin('oldTableName', TType.STRING, 2)
-      oprot.writeString(self.oldTableName)
-      oprot.writeFieldEnd()
-    if self.newTableName is not None:
-      oprot.writeFieldBegin('newTableName', TType.STRING, 3)
-      oprot.writeString(self.newTableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class renameTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-   - ouch4
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
-    (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ), # 4
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-    self.ouch4 = ouch4
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRUCT:
-          self.ouch4 = TableExistsException()
-          self.ouch4.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('renameTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch4 is not None:
-      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
-      self.ouch4.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setLocalityGroups_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - groups
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.MAP, 'groups', (TType.STRING,None,TType.SET,(TType.STRING,None)), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, groups=None,):
-    self.login = login
-    self.tableName = tableName
-    self.groups = groups
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.MAP:
-          self.groups = {}
-          (_ktype232, _vtype233, _size231 ) = iprot.readMapBegin() 
-          for _i235 in xrange(_size231):
-            _key236 = iprot.readString();
-            _val237 = set()
-            (_etype241, _size238) = iprot.readSetBegin()
-            for _i242 in xrange(_size238):
-              _elem243 = iprot.readString();
-              _val237.add(_elem243)
-            iprot.readSetEnd()
-            self.groups[_key236] = _val237
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setLocalityGroups_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.groups is not None:
-      oprot.writeFieldBegin('groups', TType.MAP, 3)
-      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.groups))
-      for kiter244,viter245 in self.groups.items():
-        oprot.writeString(kiter244)
-        oprot.writeSetBegin(TType.STRING, len(viter245))
-        for iter246 in viter245:
-          oprot.writeString(iter246)
-        oprot.writeSetEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setLocalityGroups_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setLocalityGroups_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setTableProperty_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - property
-   - value
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'property', None, None, ), # 3
-    (4, TType.STRING, 'value', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, property=None, value=None,):
-    self.login = login
-    self.tableName = tableName
-    self.property = property
-    self.value = value
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setTableProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 3)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 4)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setTableProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setTableProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class splitRangeByTablets_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - range
-   - maxSplits
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 3
-    (4, TType.I32, 'maxSplits', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, range=None, maxSplits=None,):
-    self.login = login
-    self.tableName = tableName
-    self.range = range
-    self.maxSplits = maxSplits
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.range = Range()
-          self.range.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.maxSplits = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('splitRangeByTablets_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.range is not None:
-      oprot.writeFieldBegin('range', TType.STRUCT, 3)
-      self.range.write(oprot)
-      oprot.writeFieldEnd()
-    if self.maxSplits is not None:
-      oprot.writeFieldBegin('maxSplits', TType.I32, 4)
-      oprot.writeI32(self.maxSplits)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class splitRangeByTablets_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.SET, 'success', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.SET:
-          self.success = set()
-          (_etype250, _size247) = iprot.readSetBegin()
-          for _i251 in xrange(_size247):
-            _elem252 = Range()
-            _elem252.read(iprot)
-            self.success.add(_elem252)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('splitRangeByTablets_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.SET, 0)
-      oprot.writeSetBegin(TType.STRUCT, len(self.success))
-      for iter253 in self.success:
-        iter253.write(oprot)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableExists_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableExists_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableExists_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableExists_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableIdMap_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableIdMap_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableIdMap_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype255, _vtype256, _size254 ) = iprot.readMapBegin() 
-          for _i258 in xrange(_size254):
-            _key259 = iprot.readString();
-            _val260 = iprot.readString();
-            self.success[_key259] = _val260
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableIdMap_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter261,viter262 in self.success.items():
-        oprot.writeString(kiter261)
-        oprot.writeString(viter262)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class pingTabletServer_args:
-  """
-  Attributes:
-   - login
-   - tserver
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tserver', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tserver=None,):
-    self.login = login
-    self.tserver = tserver
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tserver = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('pingTabletServer_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tserver is not None:
-      oprot.writeFieldBegin('tserver', TType.STRING, 2)
-      oprot.writeString(self.tserver)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class pingTabletServer_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('pingTabletServer_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveScans_args:
-  """
-  Attributes:
-   - login
-   - tserver
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tserver', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tserver=None,):
-    self.login = login
-    self.tserver = tserver
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tserver = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveScans_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tserver is not None:
-      oprot.writeFieldBegin('tserver', TType.STRING, 2)
-      oprot.writeString(self.tserver)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveScans_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRUCT,(ActiveScan, ActiveScan.thrift_spec)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype266, _size263) = iprot.readListBegin()
-          for _i267 in xrange(_size263):
-            _elem268 = ActiveScan()
-            _elem268.read(iprot)
-            self.success.append(_elem268)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveScans_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRUCT, len(self.success))
-      for iter269 in self.success:
-        iter269.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveCompactions_args:
-  """
-  Attributes:
-   - login
-   - tserver
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tserver', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tserver=None,):
-    self.login = login
-    self.tserver = tserver
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tserver = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveCompactions_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tserver is not None:
-      oprot.writeFieldBegin('tserver', TType.STRING, 2)
-      oprot.writeString(self.tserver)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveCompactions_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRUCT,(ActiveCompaction, ActiveCompaction.thrift_spec)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype273, _size270) = iprot.readListBegin()
-          for _i274 in xrange(_size270):
-            _elem275 = ActiveCompaction()
-            _elem275.read(iprot)
-            self.success.append(_elem275)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveCompactions_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRUCT, len(self.success))
-      for iter276 in self.success:
-        iter276.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSiteConfiguration_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSiteConfiguration_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSiteConfiguration_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype278, _vtype279, _size277 ) = iprot.readMapBegin() 
-          for _i281 in xrange(_size277):
-            _key282 = iprot.readString();
-            _val283 = iprot.readString();
-            self.success[_key282] = _val283
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSiteConfiguration_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter284,viter285 in self.success.items():
-        oprot.writeString(kiter284)
-        oprot.writeString(viter285)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSystemConfiguration_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSystemConfiguration_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSystemConfiguration_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype287, _vtype288, _size286 ) = iprot.readMapBegin() 
-          for _i290 in xrange(_size286):
-            _key291 = iprot.readString();
-            _val292 = iprot.readString();
-            self.success[_key291] = _val292
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSystemConfiguration_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter293,viter294 in self.success.items():
-        oprot.writeString(kiter293)
-        oprot.writeString(viter294)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTabletServers_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTabletServers_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTabletServers_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype298, _size295) = iprot.readListBegin()
-          for _i299 in xrange(_size295):
-            _elem300 = iprot.readString();
-            self.success.append(_elem300)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTabletServers_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRING, len(self.success))
-      for iter301 in self.success:
-        oprot.writeString(iter301)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeProperty_args:
-  """
-  Attributes:
-   - login
-   - property
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'property', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, property=None,):
-    self.login = login
-    self.property = property
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 2)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setProperty_args:
-  """
-  Attributes:
-   - login
-   - property
-   - value
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'property', None, None, ), # 2
-    (3, TType.STRING, 'value', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, property=None, value=None,):
-    self.login = login
-    self.property = property
-    self.value = value
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 2)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 3)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class testClassLoad_args:
-  """
-  Attributes:
-   - login
-   - className
-   - asTypeName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'className', None, None, ), # 2
-    (3, TType.STRING, 'asTypeName', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, className=None, asTypeName=None,):
-    self.login = login
-    self.className = className
-    self.asTypeName = asTypeName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.className = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.asTypeName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('testClassLoad_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.className is not None:
-      oprot.writeFieldBegin('className', TType.STRING, 2)
-      oprot.writeString(self.className)
-      oprot.writeFieldEnd()
-    if self.asTypeName is not None:
-      oprot.writeFieldBegin('asTypeName', TType.STRING, 3)
-      oprot.writeString(self.asTypeName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class testClassLoad_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('testClassLoad_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class authenticateUser_args:
-  """
-  Attributes:
-   - login
-   - user
-   - properties
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, properties=None,):
-    self.login = login
-    self.user = user
-    self.properties = properties
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.MAP:
-          self.properties = {}
-          (_ktype303, _vtype304, _size302 ) = iprot.readMapBegin() 
-          for _i306 in xrange(_size302):
-            _key307 = iprot.readString();
-            _val308 = iprot.readString();
-            self.properties[_key307] = _val308
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('authenticateUser_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.properties is not None:
-      oprot.writeFieldBegin('properties', TType.MAP, 3)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
-      for kiter309,viter310 in self.properties.items():
-        oprot.writeString(kiter309)
-        oprot.writeString(viter310)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class authenticateUser_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('authenticateUser_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeUserAuthorizations_args:
-  """
-  Attributes:
-   - login
-   - user
-   - authorizations
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, authorizations=None,):
-    self.login = login
-    self.user = user
-    self.authorizations = authorizations
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.SET:
-          self.authorizations = set()
-          (_etype314, _size311) = iprot.readSetBegin()
-          for _i315 in xrange(_size311):
-            _elem316 = iprot.readString();
-            self.authorizations.add(_elem316)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeUserAuthorizations_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.SET, 3)
-      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
-      for iter317 in self.authorizations:
-        oprot.writeString(iter317)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeUserAuthorizations_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeUserAuthorizations_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeLocalUserPassword_args:
-  """
-  Attributes:
-   - login
-   - user
-   - password
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'password', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, password=None,):
-    self.login = login
-    self.user = user
-    self.password = password
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.password = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeLocalUserPassword_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.password is not None:
-      oprot.writeFieldBegin('password', TType.STRING, 3)
-      oprot.writeString(self.password)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeLocalUserPassword_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeLocalUserPassword_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createLocalUser_args:
-  """
-  Attributes:
-   - login
-   - user
-   - password
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'password', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, password=None,):
-    self.login = login
-    self.user = user
-    self.password = password
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.password = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createLocalUser_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.password is not None:
-      oprot.writeFieldBegin('password', TType.STRING, 3)
-      oprot.writeString(self.password)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createLocalUser_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createLocalUser_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class dropLocalUser_args:
-  """
-  Attributes:
-   - login
-   - user
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, user=None,):
-    self.login = login
-    self.user = user
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('dropLocalUser_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class dropLocalUser_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('dropLocalUser_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getUserAuthorizations_args:
-  """
-  Attributes:
-   - login
-   - user
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, user=None,):
-    self.login = login
-    self.user = user
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getUserAuthorizations_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getUserAuthorizations_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype321, _size318) = iprot.readListBegin()
-          for _i322 in xrange(_size318):
-            _elem323 = iprot.readString();
-            self.success.append(_elem323)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getUserAuthorizations_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRING, len(self.success))
-      for iter324 in self.success:
-        oprot.writeString(iter324)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantSystemPermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.I32, 'perm', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantSystemPermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 3)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantSystemPermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantSystemPermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantTablePermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - table
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I32, 'perm', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, user=None, table=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.table = table
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantTablePermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 4)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantTablePermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantTablePermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasSystemPermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.I32, 'perm', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasSystemPermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 3)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasSystemPermission_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasSystemPermission_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasTablePermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - table
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I32, 'perm', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, user=None, table=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.table = table
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasTablePermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 4)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasTablePermission_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasTablePermission_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listLocalUsers_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listLocalUsers_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listLocalUsers_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.SET:
-          self.success = set()
-          (_etype328, _size325) = iprot.readSetBegin()
-          for _i329 in xrange(_size325):
-            _elem330 = iprot.readString();
-            self.success.add(_elem330)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listLocalUsers_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.SET, 0)
-      oprot.writeSetBegin(TType.STRING, len(self.success))
-      for iter331 in self.success:
-        oprot.writeString(iter331)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeSystemPermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.I32, 'perm', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeSystemPermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 3)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeSystemPermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeSystemPermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeTablePermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - table
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I32, 'perm', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, user=None, table=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.table = table
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeTablePermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 4)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeTablePermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeTablePermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createBatchScanner_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - options
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'options', (BatchScanOptions, BatchScanOptions.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, options=None,):
-    self.login = login
-    self.tableName = tableName
-    self.options = options
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.options = BatchScanOptions()
-          self.options.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createBatchScanner_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.options is not None:
-      oprot.writeFieldBegin('options', TType.STRUCT, 3)
-      self.options.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createBatchScanner_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createBatchScanner_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createScanner_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - options
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'options', (ScanOptions, ScanOptions.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, options=None,):
-    self.login = login
-    self.tableName = tableName
-    self.options = options
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.options = ScanOptions()
-          self.options.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createScanner_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.options is not None:
-      oprot.writeFieldBegin('options', TType.STRUCT, 3)
-      self.options.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createScanner_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createScanner_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasNext_args:
-  """
-  Attributes:
-   - scanner
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-  )
-
-  def __init__(self, scanner=None,):
-    self.scanner = scanner
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasNext_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasNext_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, success=None, ouch1=None,):
-    self.success = success
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownScanner()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasNext_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextEntry_args:
-  """
-  Attributes:
-   - scanner
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-  )
-
-  def __init__(self, scanner=None,):
-    self.scanner = scanner
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextEntry_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextEntry_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (KeyValueAndPeek, KeyValueAndPeek.thrift_spec), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = KeyValueAndPeek()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = NoMoreEntriesException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = UnknownScanner()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextEntry_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextK_args:
-  """
-  Attributes:
-   - scanner
-   - k
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-    (2, TType.I32, 'k', None, None, ), # 2
-  )
-
-  def __init__(self, scanner=None, k=None,):
-    self.scanner = scanner
-    self.k = k
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I32:
-          self.k = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextK_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    if self.k is not None:
-      oprot.writeFieldBegin('k', TType.I32, 2)
-      oprot.writeI32(self.k)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextK_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = ScanResult()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = NoMoreEntriesException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = UnknownScanner()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextK_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeScanner_args:
-  """
-  Attributes:
-   - scanner
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-  )
-
-  def __init__(self, scanner=None,):
-    self.scanner = scanner
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeScanner_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeScanner_result:
-  """
-  Attributes:
-   - ouch1
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, ouch1=None,):
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownScanner()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeScanner_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class updateAndFlush_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - cells
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.MAP, 'cells', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnUpdate, ColumnUpdate.thrift_spec))), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, cells=None,):
-    self.login = login
-    self.tableName = tableName
-    self.cells = cells
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.MAP:
-          self.cells = {}
-          (_ktype333, _vtype334, _size332 ) = iprot.readMapBegin() 
-          for _i336 in xrange(_size332):
-            _key337 = iprot.readString();
-            _val338 = []
-            (_etype342, _size339) = iprot.readListBegin()
-            for _i343 in xrange(_size339):
-              _elem344 = ColumnUpdate()
-              _elem344.read(iprot)
-              _val338.append(_elem344)
-            iprot.readListEnd()
-            self.cells[_key337] = _val338
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('updateAndFlush_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.cells is not None:
-      oprot.writeFieldBegin('cells', TType.MAP, 3)
-      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
-      for kiter345,viter346 in self.cells.items():
-        oprot.writeString(kiter345)
-        oprot.writeListBegin(TType.STRUCT, len(viter346))
-        for iter347 in viter346:
-          iter347.write(oprot)
-        oprot.writeListEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class updateAndFlush_result:
-  """
-  Attributes:
-   - outch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, outch1=None, ouch2=None,):
-    self.outch1 = outch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.outch1 = AccumuloException()
-          self.outch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('updateAndFlush_result')
-    if self.outch1 is not None:
-      oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
-      self.outch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createWriter_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - opts
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'opts', (WriterOptions, WriterOptions.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, opts=None,):
-    self.login = login
-    self.tableName = tableName
-    self.opts = opts
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.opts = WriterOptions()
-          self.opts.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createWriter_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.opts is not None:
-      oprot.writeFieldBegin('opts', TType.STRUCT, 3)
-      self.opts.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createWriter_result:
-  """
-  Attributes:
-   - success
-   - outch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, outch1=None, ouch2=None,):
-    self.success = success
-    self.outch1 = outch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.outch1 = AccumuloException()
-          self.outch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createWriter_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.outch1 is not None:
-      oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
-      self.outch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class update_args:
-  """
-  Attributes:
-   - writer
-   - cells
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'writer', None, None, ), # 1
-    (2, TType.MAP, 'cells', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnUpdate, ColumnUpdate.thrift_spec))), None, ), # 2
-  )
-
-  def __init__(self, writer=None, cells=None,):
-    self.writer = writer
-    self.cells = cells
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.writer = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.MAP:
-          self.cells = {}
-          (_ktype349, _vtype350, _size348 ) = iprot.readMapBegin() 
-          for _i352 in xrange(_size348):
-            _key353 = iprot.readString();
-            _val354 = []
-            (_etype358, _size355) = iprot.readListBegin()
-            for _i359 in xrange(_size355):
-              _elem360 = ColumnUpdate()
-              _elem360.read(iprot)
-              _val354.append(_elem360)
-            iprot.readListEnd()
-            self.cells[_key353] = _val354
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('update_args')
-    if self.writer is not None:
-      oprot.writeFieldBegin('writer', TType.STRING, 1)
-      oprot.writeString(self.writer)
-      oprot.writeFieldEnd()
-    if self.cells is not None:
-      oprot.writeFieldBegin('cells', TType.MAP, 2)
-      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
-      for kiter361,viter362 in self.cells.items():
-        oprot.writeString(kiter361)
-        oprot.writeListBegin(TType.STRUCT, len(viter362))
-        for iter363 in viter362:
-          iter363.write(oprot)
-        oprot.writeListEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flush_args:
-  """
-  Attributes:
-   - writer
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'writer', None, None, ), # 1
-  )
-
-  def __init__(self, writer=None,):
-    self.writer = writer
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.writer = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flush_args')
-    if self.writer is not None:
-      oprot.writeFieldBegin('writer', TType.STRING, 1)
-      oprot.writeString(self.writer)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flush_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownWriter()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flush_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeWriter_args:
-  """
-  Attributes:
-   - writer
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'writer', None, None, ), # 1
-  )
-
-  def __init__(self, writer=None,):
-    self.writer = writer
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.writer = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeWriter_args')
-    if self.writer is not None:
-      oprot.writeFieldBegin('writer', TType.STRING, 1)
-      oprot.writeString(self.writer)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeWriter_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownWriter()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeWriter_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getRowRange_args:
-  """
-  Attributes:
-   - row
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'row', None, None, ), # 1
-  )
-
-  def __init__(self, row=None,):
-    self.row = row
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.row = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getRowRange_args')
-    if self.row is not None:
-      oprot.writeFieldBegin('row', TType.STRING, 1)
-      oprot.writeString(self.row)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getRowRange_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (Range, Range.thrift_spec), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = Range()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getRowRange_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getFollowing_args:
-  """
-  Attributes:
-   - key
-   - part
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ), # 1
-    (2, TType.I32, 'part', None, None, ), # 2
-  )
-
-  def __init__(self, key=None, part=None,):
-    self.key = key
-    self.part = part
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.key = Key()
-          self.key.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I32:
-          self.part = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getFollowing_args')
-    if self.key is not None:
-      oprot.writeFieldBegin('key', TType.STRUCT, 1)
-      self.key.write(oprot)
-      oprot.writeFieldEnd()
-    if self.part is not None:
-      oprot.writeFieldBegin('part', TType.I32, 2)
-      oprot.writeI32(self.part)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getFollowing_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (Key, Key.thrift_spec), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = Key()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getFollowing_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, className=None, asTypeName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.className = className
+        self.asTypeName = asTypeName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.asTypeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testNamespaceClassLoad_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 3)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.asTypeName is not None:
+            oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
+            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testNamespaceClassLoad_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testNamespaceClassLoad_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __ne__(self, other):
-    return not (self == other)
+    def __ne__(self, other):
+        return not (self == other)
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/AccumuloProxy-remote pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy-remote
--- pyaccumulo/pyaccumulo/proxy/AccumuloProxy-remote	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy-remote	2017-03-15 22:24:26.486584651 +0000
@@ -1,6 +1,20 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 #!/usr/bin/env python
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
@@ -9,570 +23,802 @@
 
 import sys
 import pprint
-from urlparse import urlparse
-from thrift.transport import TTransport
-from thrift.transport import TSocket
-from thrift.transport import THttpClient
-from thrift.protocol import TBinaryProtocol
+if sys.version_info[0] > 2:
+    from urllib.parse import urlparse
+else:
+    from urlparse import urlparse
+from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
+from thrift.protocol.TBinaryProtocol import TBinaryProtocol
 
-import AccumuloProxy
-from ttypes import *
+from accumulo import AccumuloProxy
+from accumulo.ttypes import *
 
 if len(sys.argv) <= 1 or sys.argv[1] == '--help':
-  print ''
-  print 'Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] function [arg1 [arg2...]]'
-  print ''
-  print 'Functions:'
-  print '  string login(string principal,  loginProperties)'
-  print '  i32 addConstraint(string login, string tableName, string constraintClassName)'
-  print '  void addSplits(string login, string tableName,  splits)'
-  print '  void attachIterator(string login, string tableName, IteratorSetting setting,  scopes)'
-  print '  void checkIteratorConflicts(string login, string tableName, IteratorSetting setting,  scopes)'
-  print '  void clearLocatorCache(string login, string tableName)'
-  print '  void cloneTable(string login, string tableName, string newTableName, bool flush,  propertiesToSet,  propertiesToExclude)'
-  print '  void compactTable(string login, string tableName, string startRow, string endRow,  iterators, bool flush, bool wait)'
-  print '  void cancelCompaction(string login, string tableName)'
-  print '  void createTable(string login, string tableName, bool versioningIter, TimeType type)'
-  print '  void deleteTable(string login, string tableName)'
-  print '  void deleteRows(string login, string tableName, string startRow, string endRow)'
-  print '  void exportTable(string login, string tableName, string exportDir)'
-  print '  void flushTable(string login, string tableName, string startRow, string endRow, bool wait)'
-  print '   getLocalityGroups(string login, string tableName)'
-  print '  IteratorSetting getIteratorSetting(string login, string tableName, string iteratorName, IteratorScope scope)'
-  print '  string getMaxRow(string login, string tableName,  auths, string startRow, bool startInclusive, string endRow, bool endInclusive)'
-  print '   getTableProperties(string login, string tableName)'
-  print '   getSplits(string login, string tableName, i32 maxSplits)'
-  print '  void importDirectory(string login, string tableName, string importDir, string failureDir, bool setTime)'
-  print '  void importTable(string login, string tableName, string importDir)'
-  print '   listTables(string login)'
-  print '   listIterators(string login, string tableName)'
-  print '   listConstraints(string login, string tableName)'
-  print '  void mergeTablets(string login, string tableName, string startRow, string endRow)'
-  print '  void offlineTable(string login, string tableName)'
-  print '  void onlineTable(string login, string tableName)'
-  print '  void removeConstraint(string login, string tableName, i32 constraint)'
-  print '  void removeIterator(string login, string tableName, string iterName,  scopes)'
-  print '  void removeTableProperty(string login, string tableName, string property)'
-  print '  void renameTable(string login, string oldTableName, string newTableName)'
-  print '  void setLocalityGroups(string login, string tableName,  groups)'
-  print '  void setTableProperty(string login, string tableName, string property, string value)'
-  print '   splitRangeByTablets(string login, string tableName, Range range, i32 maxSplits)'
-  print '  bool tableExists(string login, string tableName)'
-  print '   tableIdMap(string login)'
-  print '  void pingTabletServer(string login, string tserver)'
-  print '   getActiveScans(string login, string tserver)'
-  print '   getActiveCompactions(string login, string tserver)'
-  print '   getSiteConfiguration(string login)'
-  print '   getSystemConfiguration(string login)'
-  print '   getTabletServers(string login)'
-  print '  void removeProperty(string login, string property)'
-  print '  void setProperty(string login, string property, string value)'
-  print '  bool testClassLoad(string login, string className, string asTypeName)'
-  print '  bool authenticateUser(string login, string user,  properties)'
-  print '  void changeUserAuthorizations(string login, string user,  authorizations)'
-  print '  void changeLocalUserPassword(string login, string user, string password)'
-  print '  void createLocalUser(string login, string user, string password)'
-  print '  void dropLocalUser(string login, string user)'
-  print '   getUserAuthorizations(string login, string user)'
-  print '  void grantSystemPermission(string login, string user, SystemPermission perm)'
-  print '  void grantTablePermission(string login, string user, string table, TablePermission perm)'
-  print '  bool hasSystemPermission(string login, string user, SystemPermission perm)'
-  print '  bool hasTablePermission(string login, string user, string table, TablePermission perm)'
-  print '   listLocalUsers(string login)'
-  print '  void revokeSystemPermission(string login, string user, SystemPermission perm)'
-  print '  void revokeTablePermission(string login, string user, string table, TablePermission perm)'
-  print '  string createBatchScanner(string login, string tableName, BatchScanOptions options)'
-  print '  string createScanner(string login, string tableName, ScanOptions options)'
-  print '  bool hasNext(string scanner)'
-  print '  KeyValueAndPeek nextEntry(string scanner)'
-  print '  ScanResult nextK(string scanner, i32 k)'
-  print '  void closeScanner(string scanner)'
-  print '  void updateAndFlush(string login, string tableName,  cells)'
-  print '  string createWriter(string login, string tableName, WriterOptions opts)'
-  print '  void update(string writer,  cells)'
-  print '  void flush(string writer)'
-  print '  void closeWriter(string writer)'
-  print '  Range getRowRange(string row)'
-  print '  Key getFollowing(Key key, PartialKey part)'
-  print ''
-  sys.exit(0)
+    print('')
+    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
+    print('')
+    print('Functions:')
+    print('  string login(string principal,  loginProperties)')
+    print('  i32 addConstraint(string login, string tableName, string constraintClassName)')
+    print('  void addSplits(string login, string tableName,  splits)')
+    print('  void attachIterator(string login, string tableName, IteratorSetting setting,  scopes)')
+    print('  void checkIteratorConflicts(string login, string tableName, IteratorSetting setting,  scopes)')
+    print('  void clearLocatorCache(string login, string tableName)')
+    print('  void cloneTable(string login, string tableName, string newTableName, bool flush,  propertiesToSet,  propertiesToExclude)')
+    print('  void compactTable(string login, string tableName, string startRow, string endRow,  iterators, bool flush, bool wait, CompactionStrategyConfig compactionStrategy)')
+    print('  void cancelCompaction(string login, string tableName)')
+    print('  void createTable(string login, string tableName, bool versioningIter, TimeType type)')
+    print('  void deleteTable(string login, string tableName)')
+    print('  void deleteRows(string login, string tableName, string startRow, string endRow)')
+    print('  void exportTable(string login, string tableName, string exportDir)')
+    print('  void flushTable(string login, string tableName, string startRow, string endRow, bool wait)')
+    print('   getDiskUsage(string login,  tables)')
+    print('   getLocalityGroups(string login, string tableName)')
+    print('  IteratorSetting getIteratorSetting(string login, string tableName, string iteratorName, IteratorScope scope)')
+    print('  string getMaxRow(string login, string tableName,  auths, string startRow, bool startInclusive, string endRow, bool endInclusive)')
+    print('   getTableProperties(string login, string tableName)')
+    print('  void importDirectory(string login, string tableName, string importDir, string failureDir, bool setTime)')
+    print('  void importTable(string login, string tableName, string importDir)')
+    print('   listSplits(string login, string tableName, i32 maxSplits)')
+    print('   listTables(string login)')
+    print('   listIterators(string login, string tableName)')
+    print('   listConstraints(string login, string tableName)')
+    print('  void mergeTablets(string login, string tableName, string startRow, string endRow)')
+    print('  void offlineTable(string login, string tableName, bool wait)')
+    print('  void onlineTable(string login, string tableName, bool wait)')
+    print('  void removeConstraint(string login, string tableName, i32 constraint)')
+    print('  void removeIterator(string login, string tableName, string iterName,  scopes)')
+    print('  void removeTableProperty(string login, string tableName, string property)')
+    print('  void renameTable(string login, string oldTableName, string newTableName)')
+    print('  void setLocalityGroups(string login, string tableName,  groups)')
+    print('  void setTableProperty(string login, string tableName, string property, string value)')
+    print('   splitRangeByTablets(string login, string tableName, Range range, i32 maxSplits)')
+    print('  bool tableExists(string login, string tableName)')
+    print('   tableIdMap(string login)')
+    print('  bool testTableClassLoad(string login, string tableName, string className, string asTypeName)')
+    print('  void pingTabletServer(string login, string tserver)')
+    print('   getActiveScans(string login, string tserver)')
+    print('   getActiveCompactions(string login, string tserver)')
+    print('   getSiteConfiguration(string login)')
+    print('   getSystemConfiguration(string login)')
+    print('   getTabletServers(string login)')
+    print('  void removeProperty(string login, string property)')
+    print('  void setProperty(string login, string property, string value)')
+    print('  bool testClassLoad(string login, string className, string asTypeName)')
+    print('  bool authenticateUser(string login, string user,  properties)')
+    print('  void changeUserAuthorizations(string login, string user,  authorizations)')
+    print('  void changeLocalUserPassword(string login, string user, string password)')
+    print('  void createLocalUser(string login, string user, string password)')
+    print('  void dropLocalUser(string login, string user)')
+    print('   getUserAuthorizations(string login, string user)')
+    print('  void grantSystemPermission(string login, string user, SystemPermission perm)')
+    print('  void grantTablePermission(string login, string user, string table, TablePermission perm)')
+    print('  bool hasSystemPermission(string login, string user, SystemPermission perm)')
+    print('  bool hasTablePermission(string login, string user, string table, TablePermission perm)')
+    print('   listLocalUsers(string login)')
+    print('  void revokeSystemPermission(string login, string user, SystemPermission perm)')
+    print('  void revokeTablePermission(string login, string user, string table, TablePermission perm)')
+    print('  void grantNamespacePermission(string login, string user, string namespaceName, NamespacePermission perm)')
+    print('  bool hasNamespacePermission(string login, string user, string namespaceName, NamespacePermission perm)')
+    print('  void revokeNamespacePermission(string login, string user, string namespaceName, NamespacePermission perm)')
+    print('  string createBatchScanner(string login, string tableName, BatchScanOptions options)')
+    print('  string createScanner(string login, string tableName, ScanOptions options)')
+    print('  bool hasNext(string scanner)')
+    print('  KeyValueAndPeek nextEntry(string scanner)')
+    print('  ScanResult nextK(string scanner, i32 k)')
+    print('  void closeScanner(string scanner)')
+    print('  void updateAndFlush(string login, string tableName,  cells)')
+    print('  string createWriter(string login, string tableName, WriterOptions opts)')
+    print('  void update(string writer,  cells)')
+    print('  void flush(string writer)')
+    print('  void closeWriter(string writer)')
+    print('  ConditionalStatus updateRowConditionally(string login, string tableName, string row, ConditionalUpdates updates)')
+    print('  string createConditionalWriter(string login, string tableName, ConditionalWriterOptions options)')
+    print('   updateRowsConditionally(string conditionalWriter,  updates)')
+    print('  void closeConditionalWriter(string conditionalWriter)')
+    print('  Range getRowRange(string row)')
+    print('  Key getFollowing(Key key, PartialKey part)')
+    print('  string systemNamespace()')
+    print('  string defaultNamespace()')
+    print('   listNamespaces(string login)')
+    print('  bool namespaceExists(string login, string namespaceName)')
+    print('  void createNamespace(string login, string namespaceName)')
+    print('  void deleteNamespace(string login, string namespaceName)')
+    print('  void renameNamespace(string login, string oldNamespaceName, string newNamespaceName)')
+    print('  void setNamespaceProperty(string login, string namespaceName, string property, string value)')
+    print('  void removeNamespaceProperty(string login, string namespaceName, string property)')
+    print('   getNamespaceProperties(string login, string namespaceName)')
+    print('   namespaceIdMap(string login)')
+    print('  void attachNamespaceIterator(string login, string namespaceName, IteratorSetting setting,  scopes)')
+    print('  void removeNamespaceIterator(string login, string namespaceName, string name,  scopes)')
+    print('  IteratorSetting getNamespaceIteratorSetting(string login, string namespaceName, string name, IteratorScope scope)')
+    print('   listNamespaceIterators(string login, string namespaceName)')
+    print('  void checkNamespaceIteratorConflicts(string login, string namespaceName, IteratorSetting setting,  scopes)')
+    print('  i32 addNamespaceConstraint(string login, string namespaceName, string constraintClassName)')
+    print('  void removeNamespaceConstraint(string login, string namespaceName, i32 id)')
+    print('   listNamespaceConstraints(string login, string namespaceName)')
+    print('  bool testNamespaceClassLoad(string login, string namespaceName, string className, string asTypeName)')
+    print('')
+    sys.exit(0)
 
-pp = pprint.PrettyPrinter(indent = 2)
+pp = pprint.PrettyPrinter(indent=2)
 host = 'localhost'
 port = 9090
 uri = ''
 framed = False
+ssl = False
+validate = True
+ca_certs = None
+keyfile = None
+certfile = None
 http = False
 argi = 1
 
 if sys.argv[argi] == '-h':
-  parts = sys.argv[argi+1].split(':')
-  host = parts[0]
-  if len(parts) > 1:
-    port = int(parts[1])
-  argi += 2
+    parts = sys.argv[argi + 1].split(':')
+    host = parts[0]
+    if len(parts) > 1:
+        port = int(parts[1])
+    argi += 2
 
 if sys.argv[argi] == '-u':
-  url = urlparse(sys.argv[argi+1])
-  parts = url[1].split(':')
-  host = parts[0]
-  if len(parts) > 1:
-    port = int(parts[1])
-  else:
-    port = 80
-  uri = url[2]
-  if url[4]:
-    uri += '?%s' % url[4]
-  http = True
-  argi += 2
+    url = urlparse(sys.argv[argi + 1])
+    parts = url[1].split(':')
+    host = parts[0]
+    if len(parts) > 1:
+        port = int(parts[1])
+    else:
+        port = 80
+    uri = url[2]
+    if url[4]:
+        uri += '?%s' % url[4]
+    http = True
+    argi += 2
 
 if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
-  framed = True
-  argi += 1
+    framed = True
+    argi += 1
+
+if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
+    ssl = True
+    argi += 1
+
+if sys.argv[argi] == '-novalidate':
+    validate = False
+    argi += 1
+
+if sys.argv[argi] == '-ca_certs':
+    ca_certs = sys.argv[argi+1]
+    argi += 2
+
+if sys.argv[argi] == '-keyfile':
+    keyfile = sys.argv[argi+1]
+    argi += 2
+
+if sys.argv[argi] == '-certfile':
+    certfile = sys.argv[argi+1]
+    argi += 2
 
 cmd = sys.argv[argi]
-args = sys.argv[argi+1:]
+args = sys.argv[argi + 1:]
 
 if http:
-  transport = THttpClient.THttpClient(host, port, uri)
+    transport = THttpClient.THttpClient(host, port, uri)
 else:
-  socket = TSocket.TSocket(host, port)
-  if framed:
-    transport = TTransport.TFramedTransport(socket)
-  else:
-    transport = TTransport.TBufferedTransport(socket)
-protocol = TBinaryProtocol.TBinaryProtocol(transport)
+    if ssl:
+        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
+    else:
+        socket = TSocket.TSocket(host, port)
+    if framed:
+        transport = TTransport.TFramedTransport(socket)
+    else:
+        transport = TTransport.TBufferedTransport(socket)
+protocol = TBinaryProtocol(transport)
 client = AccumuloProxy.Client(protocol)
 transport.open()
 
 if cmd == 'login':
-  if len(args) != 2:
-    print 'login requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.login(args[0],eval(args[1]),))
+    if len(args) != 2:
+        print('login requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.login(args[0], eval(args[1]),))
 
 elif cmd == 'addConstraint':
-  if len(args) != 3:
-    print 'addConstraint requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.addConstraint(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('addConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.addConstraint(args[0], args[1], args[2],))
 
 elif cmd == 'addSplits':
-  if len(args) != 3:
-    print 'addSplits requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.addSplits(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('addSplits requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.addSplits(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'attachIterator':
-  if len(args) != 4:
-    print 'attachIterator requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.attachIterator(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('attachIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.attachIterator(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'checkIteratorConflicts':
-  if len(args) != 4:
-    print 'checkIteratorConflicts requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.checkIteratorConflicts(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('checkIteratorConflicts requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.checkIteratorConflicts(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'clearLocatorCache':
-  if len(args) != 2:
-    print 'clearLocatorCache requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.clearLocatorCache(args[0],args[1],))
+    if len(args) != 2:
+        print('clearLocatorCache requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.clearLocatorCache(args[0], args[1],))
 
 elif cmd == 'cloneTable':
-  if len(args) != 6:
-    print 'cloneTable requires 6 args'
-    sys.exit(1)
-  pp.pprint(client.cloneTable(args[0],args[1],args[2],eval(args[3]),eval(args[4]),eval(args[5]),))
+    if len(args) != 6:
+        print('cloneTable requires 6 args')
+        sys.exit(1)
+    pp.pprint(client.cloneTable(args[0], args[1], args[2], eval(args[3]), eval(args[4]), eval(args[5]),))
 
 elif cmd == 'compactTable':
-  if len(args) != 7:
-    print 'compactTable requires 7 args'
-    sys.exit(1)
-  pp.pprint(client.compactTable(args[0],args[1],args[2],args[3],eval(args[4]),eval(args[5]),eval(args[6]),))
+    if len(args) != 8:
+        print('compactTable requires 8 args')
+        sys.exit(1)
+    pp.pprint(client.compactTable(args[0], args[1], args[2], args[3], eval(args[4]), eval(args[5]), eval(args[6]), eval(args[7]),))
 
 elif cmd == 'cancelCompaction':
-  if len(args) != 2:
-    print 'cancelCompaction requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.cancelCompaction(args[0],args[1],))
+    if len(args) != 2:
+        print('cancelCompaction requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.cancelCompaction(args[0], args[1],))
 
 elif cmd == 'createTable':
-  if len(args) != 4:
-    print 'createTable requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.createTable(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('createTable requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.createTable(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'deleteTable':
-  if len(args) != 2:
-    print 'deleteTable requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.deleteTable(args[0],args[1],))
+    if len(args) != 2:
+        print('deleteTable requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.deleteTable(args[0], args[1],))
 
 elif cmd == 'deleteRows':
-  if len(args) != 4:
-    print 'deleteRows requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.deleteRows(args[0],args[1],args[2],args[3],))
+    if len(args) != 4:
+        print('deleteRows requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.deleteRows(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'exportTable':
-  if len(args) != 3:
-    print 'exportTable requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.exportTable(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('exportTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.exportTable(args[0], args[1], args[2],))
 
 elif cmd == 'flushTable':
-  if len(args) != 5:
-    print 'flushTable requires 5 args'
-    sys.exit(1)
-  pp.pprint(client.flushTable(args[0],args[1],args[2],args[3],eval(args[4]),))
+    if len(args) != 5:
+        print('flushTable requires 5 args')
+        sys.exit(1)
+    pp.pprint(client.flushTable(args[0], args[1], args[2], args[3], eval(args[4]),))
+
+elif cmd == 'getDiskUsage':
+    if len(args) != 2:
+        print('getDiskUsage requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getDiskUsage(args[0], eval(args[1]),))
 
 elif cmd == 'getLocalityGroups':
-  if len(args) != 2:
-    print 'getLocalityGroups requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getLocalityGroups(args[0],args[1],))
+    if len(args) != 2:
+        print('getLocalityGroups requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getLocalityGroups(args[0], args[1],))
 
 elif cmd == 'getIteratorSetting':
-  if len(args) != 4:
-    print 'getIteratorSetting requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.getIteratorSetting(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('getIteratorSetting requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.getIteratorSetting(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'getMaxRow':
-  if len(args) != 7:
-    print 'getMaxRow requires 7 args'
-    sys.exit(1)
-  pp.pprint(client.getMaxRow(args[0],args[1],eval(args[2]),args[3],eval(args[4]),args[5],eval(args[6]),))
+    if len(args) != 7:
+        print('getMaxRow requires 7 args')
+        sys.exit(1)
+    pp.pprint(client.getMaxRow(args[0], args[1], eval(args[2]), args[3], eval(args[4]), args[5], eval(args[6]),))
 
 elif cmd == 'getTableProperties':
-  if len(args) != 2:
-    print 'getTableProperties requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getTableProperties(args[0],args[1],))
-
-elif cmd == 'getSplits':
-  if len(args) != 3:
-    print 'getSplits requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.getSplits(args[0],args[1],eval(args[2]),))
+    if len(args) != 2:
+        print('getTableProperties requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getTableProperties(args[0], args[1],))
 
 elif cmd == 'importDirectory':
-  if len(args) != 5:
-    print 'importDirectory requires 5 args'
-    sys.exit(1)
-  pp.pprint(client.importDirectory(args[0],args[1],args[2],args[3],eval(args[4]),))
+    if len(args) != 5:
+        print('importDirectory requires 5 args')
+        sys.exit(1)
+    pp.pprint(client.importDirectory(args[0], args[1], args[2], args[3], eval(args[4]),))
 
 elif cmd == 'importTable':
-  if len(args) != 3:
-    print 'importTable requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.importTable(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('importTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.importTable(args[0], args[1], args[2],))
+
+elif cmd == 'listSplits':
+    if len(args) != 3:
+        print('listSplits requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.listSplits(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'listTables':
-  if len(args) != 1:
-    print 'listTables requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.listTables(args[0],))
+    if len(args) != 1:
+        print('listTables requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.listTables(args[0],))
 
 elif cmd == 'listIterators':
-  if len(args) != 2:
-    print 'listIterators requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.listIterators(args[0],args[1],))
+    if len(args) != 2:
+        print('listIterators requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listIterators(args[0], args[1],))
 
 elif cmd == 'listConstraints':
-  if len(args) != 2:
-    print 'listConstraints requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.listConstraints(args[0],args[1],))
+    if len(args) != 2:
+        print('listConstraints requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listConstraints(args[0], args[1],))
 
 elif cmd == 'mergeTablets':
-  if len(args) != 4:
-    print 'mergeTablets requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.mergeTablets(args[0],args[1],args[2],args[3],))
+    if len(args) != 4:
+        print('mergeTablets requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.mergeTablets(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'offlineTable':
-  if len(args) != 2:
-    print 'offlineTable requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.offlineTable(args[0],args[1],))
+    if len(args) != 3:
+        print('offlineTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.offlineTable(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'onlineTable':
-  if len(args) != 2:
-    print 'onlineTable requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.onlineTable(args[0],args[1],))
+    if len(args) != 3:
+        print('onlineTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.onlineTable(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'removeConstraint':
-  if len(args) != 3:
-    print 'removeConstraint requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.removeConstraint(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('removeConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeConstraint(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'removeIterator':
-  if len(args) != 4:
-    print 'removeIterator requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.removeIterator(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('removeIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.removeIterator(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'removeTableProperty':
-  if len(args) != 3:
-    print 'removeTableProperty requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.removeTableProperty(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('removeTableProperty requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeTableProperty(args[0], args[1], args[2],))
 
 elif cmd == 'renameTable':
-  if len(args) != 3:
-    print 'renameTable requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.renameTable(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('renameTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.renameTable(args[0], args[1], args[2],))
 
 elif cmd == 'setLocalityGroups':
-  if len(args) != 3:
-    print 'setLocalityGroups requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.setLocalityGroups(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('setLocalityGroups requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.setLocalityGroups(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'setTableProperty':
-  if len(args) != 4:
-    print 'setTableProperty requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.setTableProperty(args[0],args[1],args[2],args[3],))
+    if len(args) != 4:
+        print('setTableProperty requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.setTableProperty(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'splitRangeByTablets':
-  if len(args) != 4:
-    print 'splitRangeByTablets requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.splitRangeByTablets(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('splitRangeByTablets requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.splitRangeByTablets(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'tableExists':
-  if len(args) != 2:
-    print 'tableExists requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.tableExists(args[0],args[1],))
+    if len(args) != 2:
+        print('tableExists requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.tableExists(args[0], args[1],))
 
 elif cmd == 'tableIdMap':
-  if len(args) != 1:
-    print 'tableIdMap requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.tableIdMap(args[0],))
+    if len(args) != 1:
+        print('tableIdMap requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.tableIdMap(args[0],))
+
+elif cmd == 'testTableClassLoad':
+    if len(args) != 4:
+        print('testTableClassLoad requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.testTableClassLoad(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'pingTabletServer':
-  if len(args) != 2:
-    print 'pingTabletServer requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.pingTabletServer(args[0],args[1],))
+    if len(args) != 2:
+        print('pingTabletServer requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.pingTabletServer(args[0], args[1],))
 
 elif cmd == 'getActiveScans':
-  if len(args) != 2:
-    print 'getActiveScans requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getActiveScans(args[0],args[1],))
+    if len(args) != 2:
+        print('getActiveScans requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getActiveScans(args[0], args[1],))
 
 elif cmd == 'getActiveCompactions':
-  if len(args) != 2:
-    print 'getActiveCompactions requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getActiveCompactions(args[0],args[1],))
+    if len(args) != 2:
+        print('getActiveCompactions requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getActiveCompactions(args[0], args[1],))
 
 elif cmd == 'getSiteConfiguration':
-  if len(args) != 1:
-    print 'getSiteConfiguration requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getSiteConfiguration(args[0],))
+    if len(args) != 1:
+        print('getSiteConfiguration requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getSiteConfiguration(args[0],))
 
 elif cmd == 'getSystemConfiguration':
-  if len(args) != 1:
-    print 'getSystemConfiguration requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getSystemConfiguration(args[0],))
+    if len(args) != 1:
+        print('getSystemConfiguration requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getSystemConfiguration(args[0],))
 
 elif cmd == 'getTabletServers':
-  if len(args) != 1:
-    print 'getTabletServers requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getTabletServers(args[0],))
+    if len(args) != 1:
+        print('getTabletServers requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getTabletServers(args[0],))
 
 elif cmd == 'removeProperty':
-  if len(args) != 2:
-    print 'removeProperty requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.removeProperty(args[0],args[1],))
+    if len(args) != 2:
+        print('removeProperty requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.removeProperty(args[0], args[1],))
 
 elif cmd == 'setProperty':
-  if len(args) != 3:
-    print 'setProperty requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.setProperty(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('setProperty requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.setProperty(args[0], args[1], args[2],))
 
 elif cmd == 'testClassLoad':
-  if len(args) != 3:
-    print 'testClassLoad requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.testClassLoad(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('testClassLoad requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.testClassLoad(args[0], args[1], args[2],))
 
 elif cmd == 'authenticateUser':
-  if len(args) != 3:
-    print 'authenticateUser requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.authenticateUser(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('authenticateUser requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.authenticateUser(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'changeUserAuthorizations':
-  if len(args) != 3:
-    print 'changeUserAuthorizations requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.changeUserAuthorizations(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('changeUserAuthorizations requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.changeUserAuthorizations(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'changeLocalUserPassword':
-  if len(args) != 3:
-    print 'changeLocalUserPassword requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.changeLocalUserPassword(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('changeLocalUserPassword requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.changeLocalUserPassword(args[0], args[1], args[2],))
 
 elif cmd == 'createLocalUser':
-  if len(args) != 3:
-    print 'createLocalUser requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createLocalUser(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('createLocalUser requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createLocalUser(args[0], args[1], args[2],))
 
 elif cmd == 'dropLocalUser':
-  if len(args) != 2:
-    print 'dropLocalUser requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.dropLocalUser(args[0],args[1],))
+    if len(args) != 2:
+        print('dropLocalUser requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.dropLocalUser(args[0], args[1],))
 
 elif cmd == 'getUserAuthorizations':
-  if len(args) != 2:
-    print 'getUserAuthorizations requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getUserAuthorizations(args[0],args[1],))
+    if len(args) != 2:
+        print('getUserAuthorizations requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getUserAuthorizations(args[0], args[1],))
 
 elif cmd == 'grantSystemPermission':
-  if len(args) != 3:
-    print 'grantSystemPermission requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.grantSystemPermission(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('grantSystemPermission requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.grantSystemPermission(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'grantTablePermission':
-  if len(args) != 4:
-    print 'grantTablePermission requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.grantTablePermission(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('grantTablePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.grantTablePermission(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'hasSystemPermission':
-  if len(args) != 3:
-    print 'hasSystemPermission requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.hasSystemPermission(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('hasSystemPermission requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.hasSystemPermission(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'hasTablePermission':
-  if len(args) != 4:
-    print 'hasTablePermission requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.hasTablePermission(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('hasTablePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.hasTablePermission(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'listLocalUsers':
-  if len(args) != 1:
-    print 'listLocalUsers requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.listLocalUsers(args[0],))
+    if len(args) != 1:
+        print('listLocalUsers requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.listLocalUsers(args[0],))
 
 elif cmd == 'revokeSystemPermission':
-  if len(args) != 3:
-    print 'revokeSystemPermission requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.revokeSystemPermission(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('revokeSystemPermission requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.revokeSystemPermission(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'revokeTablePermission':
-  if len(args) != 4:
-    print 'revokeTablePermission requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.revokeTablePermission(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('revokeTablePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.revokeTablePermission(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'grantNamespacePermission':
+    if len(args) != 4:
+        print('grantNamespacePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.grantNamespacePermission(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'hasNamespacePermission':
+    if len(args) != 4:
+        print('hasNamespacePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.hasNamespacePermission(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'revokeNamespacePermission':
+    if len(args) != 4:
+        print('revokeNamespacePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.revokeNamespacePermission(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'createBatchScanner':
-  if len(args) != 3:
-    print 'createBatchScanner requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createBatchScanner(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('createBatchScanner requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createBatchScanner(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'createScanner':
-  if len(args) != 3:
-    print 'createScanner requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createScanner(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('createScanner requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createScanner(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'hasNext':
-  if len(args) != 1:
-    print 'hasNext requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.hasNext(args[0],))
+    if len(args) != 1:
+        print('hasNext requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.hasNext(args[0],))
 
 elif cmd == 'nextEntry':
-  if len(args) != 1:
-    print 'nextEntry requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.nextEntry(args[0],))
+    if len(args) != 1:
+        print('nextEntry requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.nextEntry(args[0],))
 
 elif cmd == 'nextK':
-  if len(args) != 2:
-    print 'nextK requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.nextK(args[0],eval(args[1]),))
+    if len(args) != 2:
+        print('nextK requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.nextK(args[0], eval(args[1]),))
 
 elif cmd == 'closeScanner':
-  if len(args) != 1:
-    print 'closeScanner requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.closeScanner(args[0],))
+    if len(args) != 1:
+        print('closeScanner requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.closeScanner(args[0],))
 
 elif cmd == 'updateAndFlush':
-  if len(args) != 3:
-    print 'updateAndFlush requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.updateAndFlush(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('updateAndFlush requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.updateAndFlush(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'createWriter':
-  if len(args) != 3:
-    print 'createWriter requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createWriter(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('createWriter requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createWriter(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'update':
-  if len(args) != 2:
-    print 'update requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.update(args[0],eval(args[1]),))
+    if len(args) != 2:
+        print('update requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.update(args[0], eval(args[1]),))
 
 elif cmd == 'flush':
-  if len(args) != 1:
-    print 'flush requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.flush(args[0],))
+    if len(args) != 1:
+        print('flush requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.flush(args[0],))
 
 elif cmd == 'closeWriter':
-  if len(args) != 1:
-    print 'closeWriter requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.closeWriter(args[0],))
+    if len(args) != 1:
+        print('closeWriter requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.closeWriter(args[0],))
+
+elif cmd == 'updateRowConditionally':
+    if len(args) != 4:
+        print('updateRowConditionally requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.updateRowConditionally(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'createConditionalWriter':
+    if len(args) != 3:
+        print('createConditionalWriter requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createConditionalWriter(args[0], args[1], eval(args[2]),))
+
+elif cmd == 'updateRowsConditionally':
+    if len(args) != 2:
+        print('updateRowsConditionally requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.updateRowsConditionally(args[0], eval(args[1]),))
+
+elif cmd == 'closeConditionalWriter':
+    if len(args) != 1:
+        print('closeConditionalWriter requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.closeConditionalWriter(args[0],))
 
 elif cmd == 'getRowRange':
-  if len(args) != 1:
-    print 'getRowRange requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getRowRange(args[0],))
+    if len(args) != 1:
+        print('getRowRange requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getRowRange(args[0],))
 
 elif cmd == 'getFollowing':
-  if len(args) != 2:
-    print 'getFollowing requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getFollowing(eval(args[0]),eval(args[1]),))
+    if len(args) != 2:
+        print('getFollowing requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getFollowing(eval(args[0]), eval(args[1]),))
+
+elif cmd == 'systemNamespace':
+    if len(args) != 0:
+        print('systemNamespace requires 0 args')
+        sys.exit(1)
+    pp.pprint(client.systemNamespace())
+
+elif cmd == 'defaultNamespace':
+    if len(args) != 0:
+        print('defaultNamespace requires 0 args')
+        sys.exit(1)
+    pp.pprint(client.defaultNamespace())
+
+elif cmd == 'listNamespaces':
+    if len(args) != 1:
+        print('listNamespaces requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.listNamespaces(args[0],))
+
+elif cmd == 'namespaceExists':
+    if len(args) != 2:
+        print('namespaceExists requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.namespaceExists(args[0], args[1],))
+
+elif cmd == 'createNamespace':
+    if len(args) != 2:
+        print('createNamespace requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.createNamespace(args[0], args[1],))
+
+elif cmd == 'deleteNamespace':
+    if len(args) != 2:
+        print('deleteNamespace requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.deleteNamespace(args[0], args[1],))
+
+elif cmd == 'renameNamespace':
+    if len(args) != 3:
+        print('renameNamespace requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.renameNamespace(args[0], args[1], args[2],))
+
+elif cmd == 'setNamespaceProperty':
+    if len(args) != 4:
+        print('setNamespaceProperty requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.setNamespaceProperty(args[0], args[1], args[2], args[3],))
+
+elif cmd == 'removeNamespaceProperty':
+    if len(args) != 3:
+        print('removeNamespaceProperty requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeNamespaceProperty(args[0], args[1], args[2],))
+
+elif cmd == 'getNamespaceProperties':
+    if len(args) != 2:
+        print('getNamespaceProperties requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getNamespaceProperties(args[0], args[1],))
+
+elif cmd == 'namespaceIdMap':
+    if len(args) != 1:
+        print('namespaceIdMap requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.namespaceIdMap(args[0],))
+
+elif cmd == 'attachNamespaceIterator':
+    if len(args) != 4:
+        print('attachNamespaceIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.attachNamespaceIterator(args[0], args[1], eval(args[2]), eval(args[3]),))
+
+elif cmd == 'removeNamespaceIterator':
+    if len(args) != 4:
+        print('removeNamespaceIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.removeNamespaceIterator(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'getNamespaceIteratorSetting':
+    if len(args) != 4:
+        print('getNamespaceIteratorSetting requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.getNamespaceIteratorSetting(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'listNamespaceIterators':
+    if len(args) != 2:
+        print('listNamespaceIterators requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listNamespaceIterators(args[0], args[1],))
+
+elif cmd == 'checkNamespaceIteratorConflicts':
+    if len(args) != 4:
+        print('checkNamespaceIteratorConflicts requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.checkNamespaceIteratorConflicts(args[0], args[1], eval(args[2]), eval(args[3]),))
+
+elif cmd == 'addNamespaceConstraint':
+    if len(args) != 3:
+        print('addNamespaceConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.addNamespaceConstraint(args[0], args[1], args[2],))
+
+elif cmd == 'removeNamespaceConstraint':
+    if len(args) != 3:
+        print('removeNamespaceConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeNamespaceConstraint(args[0], args[1], eval(args[2]),))
+
+elif cmd == 'listNamespaceConstraints':
+    if len(args) != 2:
+        print('listNamespaceConstraints requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listNamespaceConstraints(args[0], args[1],))
+
+elif cmd == 'testNamespaceClassLoad':
+    if len(args) != 4:
+        print('testNamespaceClassLoad requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.testNamespaceClassLoad(args[0], args[1], args[2], args[3],))
 
 else:
-  print 'Unrecognized method %s' % cmd
-  sys.exit(1)
+    print('Unrecognized method %s' % cmd)
+    sys.exit(1)
 
 transport.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/constants.py pyaccumulo-new/pyaccumulo/proxy/constants.py
--- pyaccumulo/pyaccumulo/proxy/constants.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/constants.py	2017-03-15 22:24:26.486584651 +0000
@@ -1,11 +1,26 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TException, TApplicationException
-from ttypes import *
-
+from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+from thrift.protocol.TProtocol import TProtocolException
+import sys
+from .ttypes import *
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/__init__.py pyaccumulo-new/pyaccumulo/proxy/__init__.py
--- pyaccumulo/pyaccumulo/proxy/__init__.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/__init__.py	2017-03-15 22:24:26.486584651 +0000
@@ -1 +1,15 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 __all__ = ['ttypes', 'constants', 'AccumuloProxy']
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/ttypes.py pyaccumulo-new/pyaccumulo/proxy/ttypes.py
--- pyaccumulo/pyaccumulo/proxy/ttypes.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/ttypes.py	2017-03-15 22:31:55.002584651 +0000
@@ -1,2314 +1,3167 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+from thrift.protocol.TProtocol import TProtocolException
+import sys
 
 from thrift.transport import TTransport
-from thrift.protocol import TBinaryProtocol, TProtocol
-try:
-  from thrift.protocol import fastbinary
-except:
-  fastbinary = None
-
-
-class PartialKey:
-  ROW = 0
-  ROW_COLFAM = 1
-  ROW_COLFAM_COLQUAL = 2
-  ROW_COLFAM_COLQUAL_COLVIS = 3
-  ROW_COLFAM_COLQUAL_COLVIS_TIME = 4
-  ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL = 5
-
-  _VALUES_TO_NAMES = {
-    0: "ROW",
-    1: "ROW_COLFAM",
-    2: "ROW_COLFAM_COLQUAL",
-    3: "ROW_COLFAM_COLQUAL_COLVIS",
-    4: "ROW_COLFAM_COLQUAL_COLVIS_TIME",
-    5: "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL",
-  }
-
-  _NAMES_TO_VALUES = {
-    "ROW": 0,
-    "ROW_COLFAM": 1,
-    "ROW_COLFAM_COLQUAL": 2,
-    "ROW_COLFAM_COLQUAL_COLVIS": 3,
-    "ROW_COLFAM_COLQUAL_COLVIS_TIME": 4,
-    "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL": 5,
-  }
-
-class TablePermission:
-  READ = 2
-  WRITE = 3
-  BULK_IMPORT = 4
-  ALTER_TABLE = 5
-  GRANT = 6
-  DROP_TABLE = 7
-
-  _VALUES_TO_NAMES = {
-    2: "READ",
-    3: "WRITE",
-    4: "BULK_IMPORT",
-    5: "ALTER_TABLE",
-    6: "GRANT",
-    7: "DROP_TABLE",
-  }
-
-  _NAMES_TO_VALUES = {
-    "READ": 2,
-    "WRITE": 3,
-    "BULK_IMPORT": 4,
-    "ALTER_TABLE": 5,
-    "GRANT": 6,
-    "DROP_TABLE": 7,
-  }
-
-class SystemPermission:
-  GRANT = 0
-  CREATE_TABLE = 1
-  DROP_TABLE = 2
-  ALTER_TABLE = 3
-  CREATE_USER = 4
-  DROP_USER = 5
-  ALTER_USER = 6
-  SYSTEM = 7
-
-  _VALUES_TO_NAMES = {
-    0: "GRANT",
-    1: "CREATE_TABLE",
-    2: "DROP_TABLE",
-    3: "ALTER_TABLE",
-    4: "CREATE_USER",
-    5: "DROP_USER",
-    6: "ALTER_USER",
-    7: "SYSTEM",
-  }
-
-  _NAMES_TO_VALUES = {
-    "GRANT": 0,
-    "CREATE_TABLE": 1,
-    "DROP_TABLE": 2,
-    "ALTER_TABLE": 3,
-    "CREATE_USER": 4,
-    "DROP_USER": 5,
-    "ALTER_USER": 6,
-    "SYSTEM": 7,
-  }
-
-class ScanType:
-  SINGLE = 0
-  BATCH = 1
-
-  _VALUES_TO_NAMES = {
-    0: "SINGLE",
-    1: "BATCH",
-  }
-
-  _NAMES_TO_VALUES = {
-    "SINGLE": 0,
-    "BATCH": 1,
-  }
-
-class ScanState:
-  IDLE = 0
-  RUNNING = 1
-  QUEUED = 2
-
-  _VALUES_TO_NAMES = {
-    0: "IDLE",
-    1: "RUNNING",
-    2: "QUEUED",
-  }
-
-  _NAMES_TO_VALUES = {
-    "IDLE": 0,
-    "RUNNING": 1,
-    "QUEUED": 2,
-  }
-
-class CompactionType:
-  MINOR = 0
-  MERGE = 1
-  MAJOR = 2
-  FULL = 3
-
-  _VALUES_TO_NAMES = {
-    0: "MINOR",
-    1: "MERGE",
-    2: "MAJOR",
-    3: "FULL",
-  }
-
-  _NAMES_TO_VALUES = {
-    "MINOR": 0,
-    "MERGE": 1,
-    "MAJOR": 2,
-    "FULL": 3,
-  }
-
-class CompactionReason:
-  USER = 0
-  SYSTEM = 1
-  CHOP = 2
-  IDLE = 3
-  CLOSE = 4
-
-  _VALUES_TO_NAMES = {
-    0: "USER",
-    1: "SYSTEM",
-    2: "CHOP",
-    3: "IDLE",
-    4: "CLOSE",
-  }
-
-  _NAMES_TO_VALUES = {
-    "USER": 0,
-    "SYSTEM": 1,
-    "CHOP": 2,
-    "IDLE": 3,
-    "CLOSE": 4,
-  }
-
-class IteratorScope:
-  MINC = 0
-  MAJC = 1
-  SCAN = 2
-
-  _VALUES_TO_NAMES = {
-    0: "MINC",
-    1: "MAJC",
-    2: "SCAN",
-  }
-
-  _NAMES_TO_VALUES = {
-    "MINC": 0,
-    "MAJC": 1,
-    "SCAN": 2,
-  }
-
-class TimeType:
-  LOGICAL = 0
-  MILLIS = 1
-
-  _VALUES_TO_NAMES = {
-    0: "LOGICAL",
-    1: "MILLIS",
-  }
-
-  _NAMES_TO_VALUES = {
-    "LOGICAL": 0,
-    "MILLIS": 1,
-  }
-
-
-class Key:
-  """
-  Attributes:
-   - row
-   - colFamily
-   - colQualifier
-   - colVisibility
-   - timestamp
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'row', None, None, ), # 1
-    (2, TType.STRING, 'colFamily', None, None, ), # 2
-    (3, TType.STRING, 'colQualifier', None, None, ), # 3
-    (4, TType.STRING, 'colVisibility', None, None, ), # 4
-    (5, TType.I64, 'timestamp', None, None, ), # 5
-  )
-
-  def __init__(self, row=None, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None,):
-    self.row = row
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-    self.colVisibility = colVisibility
-    self.timestamp = timestamp
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.row = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.colVisibility = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I64:
-          self.timestamp = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('Key')
-    if self.row is not None:
-      oprot.writeFieldBegin('row', TType.STRING, 1)
-      oprot.writeString(self.row)
-      oprot.writeFieldEnd()
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 2)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 3)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    if self.colVisibility is not None:
-      oprot.writeFieldBegin('colVisibility', TType.STRING, 4)
-      oprot.writeString(self.colVisibility)
-      oprot.writeFieldEnd()
-    if self.timestamp is not None:
-      oprot.writeFieldBegin('timestamp', TType.I64, 5)
-      oprot.writeI64(self.timestamp)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ColumnUpdate:
-  """
-  Attributes:
-   - colFamily
-   - colQualifier
-   - colVisibility
-   - timestamp
-   - value
-   - deleteCell
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'colFamily', None, None, ), # 1
-    (2, TType.STRING, 'colQualifier', None, None, ), # 2
-    (3, TType.STRING, 'colVisibility', None, None, ), # 3
-    (4, TType.I64, 'timestamp', None, None, ), # 4
-    (5, TType.STRING, 'value', None, None, ), # 5
-    (6, TType.BOOL, 'deleteCell', None, None, ), # 6
-  )
-
-  def __init__(self, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None, value=None, deleteCell=None,):
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-    self.colVisibility = colVisibility
-    self.timestamp = timestamp
-    self.value = value
-    self.deleteCell = deleteCell
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.colVisibility = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I64:
-          self.timestamp = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.BOOL:
-          self.deleteCell = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ColumnUpdate')
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    if self.colVisibility is not None:
-      oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
-      oprot.writeString(self.colVisibility)
-      oprot.writeFieldEnd()
-    if self.timestamp is not None:
-      oprot.writeFieldBegin('timestamp', TType.I64, 4)
-      oprot.writeI64(self.timestamp)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 5)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    if self.deleteCell is not None:
-      oprot.writeFieldBegin('deleteCell', TType.BOOL, 6)
-      oprot.writeBool(self.deleteCell)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class KeyValue:
-  """
-  Attributes:
-   - key
-   - value
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ), # 1
-    (2, TType.STRING, 'value', None, None, ), # 2
-  )
-
-  def __init__(self, key=None, value=None,):
-    self.key = key
-    self.value = value
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.key = Key()
-          self.key.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('KeyValue')
-    if self.key is not None:
-      oprot.writeFieldBegin('key', TType.STRUCT, 1)
-      self.key.write(oprot)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 2)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ScanResult:
-  """
-  Attributes:
-   - results
-   - more
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.LIST, 'results', (TType.STRUCT,(KeyValue, KeyValue.thrift_spec)), None, ), # 1
-    (2, TType.BOOL, 'more', None, None, ), # 2
-  )
-
-  def __init__(self, results=None, more=None,):
-    self.results = results
-    self.more = more
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.LIST:
-          self.results = []
-          (_etype3, _size0) = iprot.readListBegin()
-          for _i4 in xrange(_size0):
-            _elem5 = KeyValue()
-            _elem5.read(iprot)
-            self.results.append(_elem5)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.BOOL:
-          self.more = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ScanResult')
-    if self.results is not None:
-      oprot.writeFieldBegin('results', TType.LIST, 1)
-      oprot.writeListBegin(TType.STRUCT, len(self.results))
-      for iter6 in self.results:
-        iter6.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.more is not None:
-      oprot.writeFieldBegin('more', TType.BOOL, 2)
-      oprot.writeBool(self.more)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class Range:
-  """
-  Attributes:
-   - start
-   - startInclusive
-   - stop
-   - stopInclusive
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'start', (Key, Key.thrift_spec), None, ), # 1
-    (2, TType.BOOL, 'startInclusive', None, None, ), # 2
-    (3, TType.STRUCT, 'stop', (Key, Key.thrift_spec), None, ), # 3
-    (4, TType.BOOL, 'stopInclusive', None, None, ), # 4
-  )
-
-  def __init__(self, start=None, startInclusive=None, stop=None, stopInclusive=None,):
-    self.start = start
-    self.startInclusive = startInclusive
-    self.stop = stop
-    self.stopInclusive = stopInclusive
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.start = Key()
-          self.start.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.BOOL:
-          self.startInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.stop = Key()
-          self.stop.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.BOOL:
-          self.stopInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('Range')
-    if self.start is not None:
-      oprot.writeFieldBegin('start', TType.STRUCT, 1)
-      self.start.write(oprot)
-      oprot.writeFieldEnd()
-    if self.startInclusive is not None:
-      oprot.writeFieldBegin('startInclusive', TType.BOOL, 2)
-      oprot.writeBool(self.startInclusive)
-      oprot.writeFieldEnd()
-    if self.stop is not None:
-      oprot.writeFieldBegin('stop', TType.STRUCT, 3)
-      self.stop.write(oprot)
-      oprot.writeFieldEnd()
-    if self.stopInclusive is not None:
-      oprot.writeFieldBegin('stopInclusive', TType.BOOL, 4)
-      oprot.writeBool(self.stopInclusive)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ScanColumn:
-  """
-  Attributes:
-   - colFamily
-   - colQualifier
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'colFamily', None, None, ), # 1
-    (2, TType.STRING, 'colQualifier', None, None, ), # 2
-  )
-
-  def __init__(self, colFamily=None, colQualifier=None,):
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ScanColumn')
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class IteratorSetting:
-  """
-  Attributes:
-   - priority
-   - name
-   - iteratorClass
-   - properties
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.I32, 'priority', None, None, ), # 1
-    (2, TType.STRING, 'name', None, None, ), # 2
-    (3, TType.STRING, 'iteratorClass', None, None, ), # 3
-    (4, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 4
-  )
-
-  def __init__(self, priority=None, name=None, iteratorClass=None, properties=None,):
-    self.priority = priority
-    self.name = name
-    self.iteratorClass = iteratorClass
-    self.properties = properties
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.I32:
-          self.priority = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.name = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.iteratorClass = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.MAP:
-          self.properties = {}
-          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
-          for _i11 in xrange(_size7):
-            _key12 = iprot.readString();
-            _val13 = iprot.readString();
-            self.properties[_key12] = _val13
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('IteratorSetting')
-    if self.priority is not None:
-      oprot.writeFieldBegin('priority', TType.I32, 1)
-      oprot.writeI32(self.priority)
-      oprot.writeFieldEnd()
-    if self.name is not None:
-      oprot.writeFieldBegin('name', TType.STRING, 2)
-      oprot.writeString(self.name)
-      oprot.writeFieldEnd()
-    if self.iteratorClass is not None:
-      oprot.writeFieldBegin('iteratorClass', TType.STRING, 3)
-      oprot.writeString(self.iteratorClass)
-      oprot.writeFieldEnd()
-    if self.properties is not None:
-      oprot.writeFieldBegin('properties', TType.MAP, 4)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
-      for kiter14,viter15 in self.properties.items():
-        oprot.writeString(kiter14)
-        oprot.writeString(viter15)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ScanOptions:
-  """
-  Attributes:
-   - authorizations
-   - range
-   - columns
-   - iterators
-   - bufferSize
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 1
-    (2, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 2
-    (3, TType.LIST, 'columns', (TType.STRUCT,(ScanColumn, ScanColumn.thrift_spec)), None, ), # 3
-    (4, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 4
-    (5, TType.I32, 'bufferSize', None, None, ), # 5
-  )
-
-  def __init__(self, authorizations=None, range=None, columns=None, iterators=None, bufferSize=None,):
-    self.authorizations = authorizations
-    self.range = range
-    self.columns = columns
-    self.iterators = iterators
-    self.bufferSize = bufferSize
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.SET:
-          self.authorizations = set()
-          (_etype19, _size16) = iprot.readSetBegin()
-          for _i20 in xrange(_size16):
-            _elem21 = iprot.readString();
-            self.authorizations.add(_elem21)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.range = Range()
-          self.range.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.LIST:
-          self.columns = []
-          (_etype25, _size22) = iprot.readListBegin()
-          for _i26 in xrange(_size22):
-            _elem27 = ScanColumn()
-            _elem27.read(iprot)
-            self.columns.append(_elem27)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype31, _size28) = iprot.readListBegin()
-          for _i32 in xrange(_size28):
-            _elem33 = IteratorSetting()
-            _elem33.read(iprot)
-            self.iterators.append(_elem33)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I32:
-          self.bufferSize = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ScanOptions')
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.SET, 1)
-      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
-      for iter34 in self.authorizations:
-        oprot.writeString(iter34)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.range is not None:
-      oprot.writeFieldBegin('range', TType.STRUCT, 2)
-      self.range.write(oprot)
-      oprot.writeFieldEnd()
-    if self.columns is not None:
-      oprot.writeFieldBegin('columns', TType.LIST, 3)
-      oprot.writeListBegin(TType.STRUCT, len(self.columns))
-      for iter35 in self.columns:
-        iter35.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 4)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter36 in self.iterators:
-        iter36.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.bufferSize is not None:
-      oprot.writeFieldBegin('bufferSize', TType.I32, 5)
-      oprot.writeI32(self.bufferSize)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class BatchScanOptions:
-  """
-  Attributes:
-   - authorizations
-   - ranges
-   - columns
-   - iterators
-   - threads
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 1
-    (2, TType.LIST, 'ranges', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 2
-    (3, TType.LIST, 'columns', (TType.STRUCT,(ScanColumn, ScanColumn.thrift_spec)), None, ), # 3
-    (4, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 4
-    (5, TType.I32, 'threads', None, None, ), # 5
-  )
-
-  def __init__(self, authorizations=None, ranges=None, columns=None, iterators=None, threads=None,):
-    self.authorizations = authorizations
-    self.ranges = ranges
-    self.columns = columns
-    self.iterators = iterators
-    self.threads = threads
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.SET:
-          self.authorizations = set()
-          (_etype40, _size37) = iprot.readSetBegin()
-          for _i41 in xrange(_size37):
-            _elem42 = iprot.readString();
-            self.authorizations.add(_elem42)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.LIST:
-          self.ranges = []
-          (_etype46, _size43) = iprot.readListBegin()
-          for _i47 in xrange(_size43):
-            _elem48 = Range()
-            _elem48.read(iprot)
-            self.ranges.append(_elem48)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.LIST:
-          self.columns = []
-          (_etype52, _size49) = iprot.readListBegin()
-          for _i53 in xrange(_size49):
-            _elem54 = ScanColumn()
-            _elem54.read(iprot)
-            self.columns.append(_elem54)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype58, _size55) = iprot.readListBegin()
-          for _i59 in xrange(_size55):
-            _elem60 = IteratorSetting()
-            _elem60.read(iprot)
-            self.iterators.append(_elem60)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I32:
-          self.threads = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('BatchScanOptions')
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.SET, 1)
-      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
-      for iter61 in self.authorizations:
-        oprot.writeString(iter61)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.ranges is not None:
-      oprot.writeFieldBegin('ranges', TType.LIST, 2)
-      oprot.writeListBegin(TType.STRUCT, len(self.ranges))
-      for iter62 in self.ranges:
-        iter62.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.columns is not None:
-      oprot.writeFieldBegin('columns', TType.LIST, 3)
-      oprot.writeListBegin(TType.STRUCT, len(self.columns))
-      for iter63 in self.columns:
-        iter63.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 4)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter64 in self.iterators:
-        iter64.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.threads is not None:
-      oprot.writeFieldBegin('threads', TType.I32, 5)
-      oprot.writeI32(self.threads)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class KeyValueAndPeek:
-  """
-  Attributes:
-   - keyValue
-   - hasNext
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'keyValue', (KeyValue, KeyValue.thrift_spec), None, ), # 1
-    (2, TType.BOOL, 'hasNext', None, None, ), # 2
-  )
-
-  def __init__(self, keyValue=None, hasNext=None,):
-    self.keyValue = keyValue
-    self.hasNext = hasNext
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.keyValue = KeyValue()
-          self.keyValue.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.BOOL:
-          self.hasNext = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('KeyValueAndPeek')
-    if self.keyValue is not None:
-      oprot.writeFieldBegin('keyValue', TType.STRUCT, 1)
-      self.keyValue.write(oprot)
-      oprot.writeFieldEnd()
-    if self.hasNext is not None:
-      oprot.writeFieldBegin('hasNext', TType.BOOL, 2)
-      oprot.writeBool(self.hasNext)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class KeyExtent:
-  """
-  Attributes:
-   - tableId
-   - endRow
-   - prevEndRow
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'tableId', None, None, ), # 1
-    (2, TType.STRING, 'endRow', None, None, ), # 2
-    (3, TType.STRING, 'prevEndRow', None, None, ), # 3
-  )
-
-  def __init__(self, tableId=None, endRow=None, prevEndRow=None,):
-    self.tableId = tableId
-    self.endRow = endRow
-    self.prevEndRow = prevEndRow
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.tableId = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.prevEndRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('KeyExtent')
-    if self.tableId is not None:
-      oprot.writeFieldBegin('tableId', TType.STRING, 1)
-      oprot.writeString(self.tableId)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 2)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.prevEndRow is not None:
-      oprot.writeFieldBegin('prevEndRow', TType.STRING, 3)
-      oprot.writeString(self.prevEndRow)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class Column:
-  """
-  Attributes:
-   - colFamily
-   - colQualifier
-   - colVisibility
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'colFamily', None, None, ), # 1
-    (2, TType.STRING, 'colQualifier', None, None, ), # 2
-    (3, TType.STRING, 'colVisibility', None, None, ), # 3
-  )
-
-  def __init__(self, colFamily=None, colQualifier=None, colVisibility=None,):
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-    self.colVisibility = colVisibility
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.colVisibility = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('Column')
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    if self.colVisibility is not None:
-      oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
-      oprot.writeString(self.colVisibility)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ActiveScan:
-  """
-  Attributes:
-   - client
-   - user
-   - table
-   - age
-   - idleTime
-   - type
-   - state
-   - extent
-   - columns
-   - iterators
-   - authorizations
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'client', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I64, 'age', None, None, ), # 4
-    (5, TType.I64, 'idleTime', None, None, ), # 5
-    (6, TType.I32, 'type', None, None, ), # 6
-    (7, TType.I32, 'state', None, None, ), # 7
-    (8, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ), # 8
-    (9, TType.LIST, 'columns', (TType.STRUCT,(Column, Column.thrift_spec)), None, ), # 9
-    (10, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 10
-    (11, TType.LIST, 'authorizations', (TType.STRING,None), None, ), # 11
-  )
-
-  def __init__(self, client=None, user=None, table=None, age=None, idleTime=None, type=None, state=None, extent=None, columns=None, iterators=None, authorizations=None,):
-    self.client = client
-    self.user = user
-    self.table = table
-    self.age = age
-    self.idleTime = idleTime
-    self.type = type
-    self.state = state
-    self.extent = extent
-    self.columns = columns
-    self.iterators = iterators
-    self.authorizations = authorizations
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.client = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I64:
-          self.age = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I64:
-          self.idleTime = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.I32:
-          self.type = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.I32:
-          self.state = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 8:
-        if ftype == TType.STRUCT:
-          self.extent = KeyExtent()
-          self.extent.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 9:
-        if ftype == TType.LIST:
-          self.columns = []
-          (_etype68, _size65) = iprot.readListBegin()
-          for _i69 in xrange(_size65):
-            _elem70 = Column()
-            _elem70.read(iprot)
-            self.columns.append(_elem70)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 10:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype74, _size71) = iprot.readListBegin()
-          for _i75 in xrange(_size71):
-            _elem76 = IteratorSetting()
-            _elem76.read(iprot)
-            self.iterators.append(_elem76)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 11:
-        if ftype == TType.LIST:
-          self.authorizations = []
-          (_etype80, _size77) = iprot.readListBegin()
-          for _i81 in xrange(_size77):
-            _elem82 = iprot.readString();
-            self.authorizations.append(_elem82)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ActiveScan')
-    if self.client is not None:
-      oprot.writeFieldBegin('client', TType.STRING, 1)
-      oprot.writeString(self.client)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.age is not None:
-      oprot.writeFieldBegin('age', TType.I64, 4)
-      oprot.writeI64(self.age)
-      oprot.writeFieldEnd()
-    if self.idleTime is not None:
-      oprot.writeFieldBegin('idleTime', TType.I64, 5)
-      oprot.writeI64(self.idleTime)
-      oprot.writeFieldEnd()
-    if self.type is not None:
-      oprot.writeFieldBegin('type', TType.I32, 6)
-      oprot.writeI32(self.type)
-      oprot.writeFieldEnd()
-    if self.state is not None:
-      oprot.writeFieldBegin('state', TType.I32, 7)
-      oprot.writeI32(self.state)
-      oprot.writeFieldEnd()
-    if self.extent is not None:
-      oprot.writeFieldBegin('extent', TType.STRUCT, 8)
-      self.extent.write(oprot)
-      oprot.writeFieldEnd()
-    if self.columns is not None:
-      oprot.writeFieldBegin('columns', TType.LIST, 9)
-      oprot.writeListBegin(TType.STRUCT, len(self.columns))
-      for iter83 in self.columns:
-        iter83.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 10)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter84 in self.iterators:
-        iter84.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.LIST, 11)
-      oprot.writeListBegin(TType.STRING, len(self.authorizations))
-      for iter85 in self.authorizations:
-        oprot.writeString(iter85)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ActiveCompaction:
-  """
-  Attributes:
-   - extent
-   - age
-   - inputFiles
-   - outputFile
-   - type
-   - reason
-   - localityGroup
-   - entriesRead
-   - entriesWritten
-   - iterators
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ), # 1
-    (2, TType.I64, 'age', None, None, ), # 2
-    (3, TType.LIST, 'inputFiles', (TType.STRING,None), None, ), # 3
-    (4, TType.STRING, 'outputFile', None, None, ), # 4
-    (5, TType.I32, 'type', None, None, ), # 5
-    (6, TType.I32, 'reason', None, None, ), # 6
-    (7, TType.STRING, 'localityGroup', None, None, ), # 7
-    (8, TType.I64, 'entriesRead', None, None, ), # 8
-    (9, TType.I64, 'entriesWritten', None, None, ), # 9
-    (10, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 10
-  )
-
-  def __init__(self, extent=None, age=None, inputFiles=None, outputFile=None, type=None, reason=None, localityGroup=None, entriesRead=None, entriesWritten=None, iterators=None,):
-    self.extent = extent
-    self.age = age
-    self.inputFiles = inputFiles
-    self.outputFile = outputFile
-    self.type = type
-    self.reason = reason
-    self.localityGroup = localityGroup
-    self.entriesRead = entriesRead
-    self.entriesWritten = entriesWritten
-    self.iterators = iterators
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.extent = KeyExtent()
-          self.extent.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I64:
-          self.age = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.LIST:
-          self.inputFiles = []
-          (_etype89, _size86) = iprot.readListBegin()
-          for _i90 in xrange(_size86):
-            _elem91 = iprot.readString();
-            self.inputFiles.append(_elem91)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.outputFile = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I32:
-          self.type = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.I32:
-          self.reason = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.STRING:
-          self.localityGroup = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 8:
-        if ftype == TType.I64:
-          self.entriesRead = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 9:
-        if ftype == TType.I64:
-          self.entriesWritten = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 10:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype95, _size92) = iprot.readListBegin()
-          for _i96 in xrange(_size92):
-            _elem97 = IteratorSetting()
-            _elem97.read(iprot)
-            self.iterators.append(_elem97)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ActiveCompaction')
-    if self.extent is not None:
-      oprot.writeFieldBegin('extent', TType.STRUCT, 1)
-      self.extent.write(oprot)
-      oprot.writeFieldEnd()
-    if self.age is not None:
-      oprot.writeFieldBegin('age', TType.I64, 2)
-      oprot.writeI64(self.age)
-      oprot.writeFieldEnd()
-    if self.inputFiles is not None:
-      oprot.writeFieldBegin('inputFiles', TType.LIST, 3)
-      oprot.writeListBegin(TType.STRING, len(self.inputFiles))
-      for iter98 in self.inputFiles:
-        oprot.writeString(iter98)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.outputFile is not None:
-      oprot.writeFieldBegin('outputFile', TType.STRING, 4)
-      oprot.writeString(self.outputFile)
-      oprot.writeFieldEnd()
-    if self.type is not None:
-      oprot.writeFieldBegin('type', TType.I32, 5)
-      oprot.writeI32(self.type)
-      oprot.writeFieldEnd()
-    if self.reason is not None:
-      oprot.writeFieldBegin('reason', TType.I32, 6)
-      oprot.writeI32(self.reason)
-      oprot.writeFieldEnd()
-    if self.localityGroup is not None:
-      oprot.writeFieldBegin('localityGroup', TType.STRING, 7)
-      oprot.writeString(self.localityGroup)
-      oprot.writeFieldEnd()
-    if self.entriesRead is not None:
-      oprot.writeFieldBegin('entriesRead', TType.I64, 8)
-      oprot.writeI64(self.entriesRead)
-      oprot.writeFieldEnd()
-    if self.entriesWritten is not None:
-      oprot.writeFieldBegin('entriesWritten', TType.I64, 9)
-      oprot.writeI64(self.entriesWritten)
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 10)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter99 in self.iterators:
-        iter99.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class WriterOptions:
-  """
-  Attributes:
-   - maxMemory
-   - latencyMs
-   - timeoutMs
-   - threads
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.I64, 'maxMemory', None, None, ), # 1
-    (2, TType.I64, 'latencyMs', None, None, ), # 2
-    (3, TType.I64, 'timeoutMs', None, None, ), # 3
-    (4, TType.I32, 'threads', None, None, ), # 4
-  )
-
-  def __init__(self, maxMemory=None, latencyMs=None, timeoutMs=None, threads=None,):
-    self.maxMemory = maxMemory
-    self.latencyMs = latencyMs
-    self.timeoutMs = timeoutMs
-    self.threads = threads
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.I64:
-          self.maxMemory = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I64:
-          self.latencyMs = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I64:
-          self.timeoutMs = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.threads = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('WriterOptions')
-    if self.maxMemory is not None:
-      oprot.writeFieldBegin('maxMemory', TType.I64, 1)
-      oprot.writeI64(self.maxMemory)
-      oprot.writeFieldEnd()
-    if self.latencyMs is not None:
-      oprot.writeFieldBegin('latencyMs', TType.I64, 2)
-      oprot.writeI64(self.latencyMs)
-      oprot.writeFieldEnd()
-    if self.timeoutMs is not None:
-      oprot.writeFieldBegin('timeoutMs', TType.I64, 3)
-      oprot.writeI64(self.timeoutMs)
-      oprot.writeFieldEnd()
-    if self.threads is not None:
-      oprot.writeFieldBegin('threads', TType.I32, 4)
-      oprot.writeI32(self.threads)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __ne__(self, other):
-    return not (self == other)
+class PartialKey(object):
+    ROW = 0
+    ROW_COLFAM = 1
+    ROW_COLFAM_COLQUAL = 2
+    ROW_COLFAM_COLQUAL_COLVIS = 3
+    ROW_COLFAM_COLQUAL_COLVIS_TIME = 4
+    ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL = 5
+
+    _VALUES_TO_NAMES = {
+        0: "ROW",
+        1: "ROW_COLFAM",
+        2: "ROW_COLFAM_COLQUAL",
+        3: "ROW_COLFAM_COLQUAL_COLVIS",
+        4: "ROW_COLFAM_COLQUAL_COLVIS_TIME",
+        5: "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL",
+    }
+
+    _NAMES_TO_VALUES = {
+        "ROW": 0,
+        "ROW_COLFAM": 1,
+        "ROW_COLFAM_COLQUAL": 2,
+        "ROW_COLFAM_COLQUAL_COLVIS": 3,
+        "ROW_COLFAM_COLQUAL_COLVIS_TIME": 4,
+        "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL": 5,
+    }
+
+
+class TablePermission(object):
+    READ = 2
+    WRITE = 3
+    BULK_IMPORT = 4
+    ALTER_TABLE = 5
+    GRANT = 6
+    DROP_TABLE = 7
+
+    _VALUES_TO_NAMES = {
+        2: "READ",
+        3: "WRITE",
+        4: "BULK_IMPORT",
+        5: "ALTER_TABLE",
+        6: "GRANT",
+        7: "DROP_TABLE",
+    }
+
+    _NAMES_TO_VALUES = {
+        "READ": 2,
+        "WRITE": 3,
+        "BULK_IMPORT": 4,
+        "ALTER_TABLE": 5,
+        "GRANT": 6,
+        "DROP_TABLE": 7,
+    }
+
+
+class SystemPermission(object):
+    GRANT = 0
+    CREATE_TABLE = 1
+    DROP_TABLE = 2
+    ALTER_TABLE = 3
+    CREATE_USER = 4
+    DROP_USER = 5
+    ALTER_USER = 6
+    SYSTEM = 7
+    CREATE_NAMESPACE = 8
+    DROP_NAMESPACE = 9
+    ALTER_NAMESPACE = 10
+    OBTAIN_DELEGATION_TOKEN = 11
+
+    _VALUES_TO_NAMES = {
+        0: "GRANT",
+        1: "CREATE_TABLE",
+        2: "DROP_TABLE",
+        3: "ALTER_TABLE",
+        4: "CREATE_USER",
+        5: "DROP_USER",
+        6: "ALTER_USER",
+        7: "SYSTEM",
+        8: "CREATE_NAMESPACE",
+        9: "DROP_NAMESPACE",
+        10: "ALTER_NAMESPACE",
+        11: "OBTAIN_DELEGATION_TOKEN",
+    }
+
+    _NAMES_TO_VALUES = {
+        "GRANT": 0,
+        "CREATE_TABLE": 1,
+        "DROP_TABLE": 2,
+        "ALTER_TABLE": 3,
+        "CREATE_USER": 4,
+        "DROP_USER": 5,
+        "ALTER_USER": 6,
+        "SYSTEM": 7,
+        "CREATE_NAMESPACE": 8,
+        "DROP_NAMESPACE": 9,
+        "ALTER_NAMESPACE": 10,
+        "OBTAIN_DELEGATION_TOKEN": 11,
+    }
+
+
+class NamespacePermission(object):
+    READ = 0
+    WRITE = 1
+    ALTER_NAMESPACE = 2
+    GRANT = 3
+    ALTER_TABLE = 4
+    CREATE_TABLE = 5
+    DROP_TABLE = 6
+    BULK_IMPORT = 7
+    DROP_NAMESPACE = 8
+
+    _VALUES_TO_NAMES = {
+        0: "READ",
+        1: "WRITE",
+        2: "ALTER_NAMESPACE",
+        3: "GRANT",
+        4: "ALTER_TABLE",
+        5: "CREATE_TABLE",
+        6: "DROP_TABLE",
+        7: "BULK_IMPORT",
+        8: "DROP_NAMESPACE",
+    }
+
+    _NAMES_TO_VALUES = {
+        "READ": 0,
+        "WRITE": 1,
+        "ALTER_NAMESPACE": 2,
+        "GRANT": 3,
+        "ALTER_TABLE": 4,
+        "CREATE_TABLE": 5,
+        "DROP_TABLE": 6,
+        "BULK_IMPORT": 7,
+        "DROP_NAMESPACE": 8,
+    }
+
+
+class ScanType(object):
+    SINGLE = 0
+    BATCH = 1
+
+    _VALUES_TO_NAMES = {
+        0: "SINGLE",
+        1: "BATCH",
+    }
+
+    _NAMES_TO_VALUES = {
+        "SINGLE": 0,
+        "BATCH": 1,
+    }
+
+
+class ScanState(object):
+    IDLE = 0
+    RUNNING = 1
+    QUEUED = 2
+
+    _VALUES_TO_NAMES = {
+        0: "IDLE",
+        1: "RUNNING",
+        2: "QUEUED",
+    }
+
+    _NAMES_TO_VALUES = {
+        "IDLE": 0,
+        "RUNNING": 1,
+        "QUEUED": 2,
+    }
+
+
+class ConditionalStatus(object):
+    ACCEPTED = 0
+    REJECTED = 1
+    VIOLATED = 2
+    UNKNOWN = 3
+    INVISIBLE_VISIBILITY = 4
+
+    _VALUES_TO_NAMES = {
+        0: "ACCEPTED",
+        1: "REJECTED",
+        2: "VIOLATED",
+        3: "UNKNOWN",
+        4: "INVISIBLE_VISIBILITY",
+    }
+
+    _NAMES_TO_VALUES = {
+        "ACCEPTED": 0,
+        "REJECTED": 1,
+        "VIOLATED": 2,
+        "UNKNOWN": 3,
+        "INVISIBLE_VISIBILITY": 4,
+    }
+
+
+class Durability(object):
+    DEFAULT = 0
+    NONE = 1
+    LOG = 2
+    FLUSH = 3
+    SYNC = 4
+
+    _VALUES_TO_NAMES = {
+        0: "DEFAULT",
+        1: "NONE",
+        2: "LOG",
+        3: "FLUSH",
+        4: "SYNC",
+    }
+
+    _NAMES_TO_VALUES = {
+        "DEFAULT": 0,
+        "NONE": 1,
+        "LOG": 2,
+        "FLUSH": 3,
+        "SYNC": 4,
+    }
+
+
+class CompactionType(object):
+    MINOR = 0
+    MERGE = 1
+    MAJOR = 2
+    FULL = 3
+
+    _VALUES_TO_NAMES = {
+        0: "MINOR",
+        1: "MERGE",
+        2: "MAJOR",
+        3: "FULL",
+    }
+
+    _NAMES_TO_VALUES = {
+        "MINOR": 0,
+        "MERGE": 1,
+        "MAJOR": 2,
+        "FULL": 3,
+    }
+
+
+class CompactionReason(object):
+    USER = 0
+    SYSTEM = 1
+    CHOP = 2
+    IDLE = 3
+    CLOSE = 4
+
+    _VALUES_TO_NAMES = {
+        0: "USER",
+        1: "SYSTEM",
+        2: "CHOP",
+        3: "IDLE",
+        4: "CLOSE",
+    }
+
+    _NAMES_TO_VALUES = {
+        "USER": 0,
+        "SYSTEM": 1,
+        "CHOP": 2,
+        "IDLE": 3,
+        "CLOSE": 4,
+    }
+
+
+class IteratorScope(object):
+    MINC = 0
+    MAJC = 1
+    SCAN = 2
+
+    _VALUES_TO_NAMES = {
+        0: "MINC",
+        1: "MAJC",
+        2: "SCAN",
+    }
+
+    _NAMES_TO_VALUES = {
+        "MINC": 0,
+        "MAJC": 1,
+        "SCAN": 2,
+    }
+
+
+class TimeType(object):
+    LOGICAL = 0
+    MILLIS = 1
+
+    _VALUES_TO_NAMES = {
+        0: "LOGICAL",
+        1: "MILLIS",
+    }
+
+    _NAMES_TO_VALUES = {
+        "LOGICAL": 0,
+        "MILLIS": 1,
+    }
+
+
+class Key(object):
+    """
+    Attributes:
+     - row
+     - colFamily
+     - colQualifier
+     - colVisibility
+     - timestamp
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colFamily', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'colVisibility', 'BINARY', None, ),  # 4
+        (5, TType.I64, 'timestamp', None, 9223372036854775807, ),  # 5
+    )
+
+    def __init__(self, row=None, colFamily=None, colQualifier=None, colVisibility=None, timestamp=thrift_spec[5][4],):
+        self.row = row
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+        self.colVisibility = colVisibility
+        self.timestamp = timestamp
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.row = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.colVisibility = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I64:
+                    self.timestamp = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Key')
+        if self.row is not None:
+            oprot.writeFieldBegin('row', TType.STRING, 1)
+            oprot.writeBinary(self.row)
+            oprot.writeFieldEnd()
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 2)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 3)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        if self.colVisibility is not None:
+            oprot.writeFieldBegin('colVisibility', TType.STRING, 4)
+            oprot.writeBinary(self.colVisibility)
+            oprot.writeFieldEnd()
+        if self.timestamp is not None:
+            oprot.writeFieldBegin('timestamp', TType.I64, 5)
+            oprot.writeI64(self.timestamp)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ColumnUpdate(object):
+    """
+    Attributes:
+     - colFamily
+     - colQualifier
+     - colVisibility
+     - timestamp
+     - value
+     - deleteCell
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'colFamily', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'colVisibility', 'BINARY', None, ),  # 3
+        (4, TType.I64, 'timestamp', None, None, ),  # 4
+        (5, TType.STRING, 'value', 'BINARY', None, ),  # 5
+        (6, TType.BOOL, 'deleteCell', None, None, ),  # 6
+    )
+
+    def __init__(self, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None, value=None, deleteCell=None,):
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+        self.colVisibility = colVisibility
+        self.timestamp = timestamp
+        self.value = value
+        self.deleteCell = deleteCell
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.colVisibility = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I64:
+                    self.timestamp = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.STRING:
+                    self.value = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.BOOL:
+                    self.deleteCell = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ColumnUpdate')
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 1)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        if self.colVisibility is not None:
+            oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
+            oprot.writeBinary(self.colVisibility)
+            oprot.writeFieldEnd()
+        if self.timestamp is not None:
+            oprot.writeFieldBegin('timestamp', TType.I64, 4)
+            oprot.writeI64(self.timestamp)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 5)
+            oprot.writeBinary(self.value)
+            oprot.writeFieldEnd()
+        if self.deleteCell is not None:
+            oprot.writeFieldBegin('deleteCell', TType.BOOL, 6)
+            oprot.writeBool(self.deleteCell)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class DiskUsage(object):
+    """
+    Attributes:
+     - tables
+     - usage
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.LIST, 'tables', (TType.STRING, 'UTF8', False), None, ),  # 1
+        (2, TType.I64, 'usage', None, None, ),  # 2
+    )
+
+    def __init__(self, tables=None, usage=None,):
+        self.tables = tables
+        self.usage = usage
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.tables = []
+                    (_etype3, _size0) = iprot.readListBegin()
+                    for _i4 in range(_size0):
+                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.tables.append(_elem5)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.usage = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('DiskUsage')
+        if self.tables is not None:
+            oprot.writeFieldBegin('tables', TType.LIST, 1)
+            oprot.writeListBegin(TType.STRING, len(self.tables))
+            for iter6 in self.tables:
+                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.usage is not None:
+            oprot.writeFieldBegin('usage', TType.I64, 2)
+            oprot.writeI64(self.usage)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class KeyValue(object):
+    """
+    Attributes:
+     - key
+     - value
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ),  # 1
+        (2, TType.STRING, 'value', 'BINARY', None, ),  # 2
+    )
+
+    def __init__(self, key=None, value=None,):
+        self.key = key
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.key = Key()
+                    self.key.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.value = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('KeyValue')
+        if self.key is not None:
+            oprot.writeFieldBegin('key', TType.STRUCT, 1)
+            self.key.write(oprot)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 2)
+            oprot.writeBinary(self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ScanResult(object):
+    """
+    Attributes:
+     - results
+     - more
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.LIST, 'results', (TType.STRUCT, (KeyValue, KeyValue.thrift_spec), False), None, ),  # 1
+        (2, TType.BOOL, 'more', None, None, ),  # 2
+    )
+
+    def __init__(self, results=None, more=None,):
+        self.results = results
+        self.more = more
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.results = []
+                    (_etype10, _size7) = iprot.readListBegin()
+                    for _i11 in range(_size7):
+                        _elem12 = KeyValue()
+                        _elem12.read(iprot)
+                        self.results.append(_elem12)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.BOOL:
+                    self.more = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ScanResult')
+        if self.results is not None:
+            oprot.writeFieldBegin('results', TType.LIST, 1)
+            oprot.writeListBegin(TType.STRUCT, len(self.results))
+            for iter13 in self.results:
+                iter13.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.more is not None:
+            oprot.writeFieldBegin('more', TType.BOOL, 2)
+            oprot.writeBool(self.more)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class Range(object):
+    """
+    Attributes:
+     - start
+     - startInclusive
+     - stop
+     - stopInclusive
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'start', (Key, Key.thrift_spec), None, ),  # 1
+        (2, TType.BOOL, 'startInclusive', None, None, ),  # 2
+        (3, TType.STRUCT, 'stop', (Key, Key.thrift_spec), None, ),  # 3
+        (4, TType.BOOL, 'stopInclusive', None, None, ),  # 4
+    )
+
+    def __init__(self, start=None, startInclusive=None, stop=None, stopInclusive=None,):
+        self.start = start
+        self.startInclusive = startInclusive
+        self.stop = stop
+        self.stopInclusive = stopInclusive
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.start = Key()
+                    self.start.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.BOOL:
+                    self.startInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.stop = Key()
+                    self.stop.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.BOOL:
+                    self.stopInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Range')
+        if self.start is not None:
+            oprot.writeFieldBegin('start', TType.STRUCT, 1)
+            self.start.write(oprot)
+            oprot.writeFieldEnd()
+        if self.startInclusive is not None:
+            oprot.writeFieldBegin('startInclusive', TType.BOOL, 2)
+            oprot.writeBool(self.startInclusive)
+            oprot.writeFieldEnd()
+        if self.stop is not None:
+            oprot.writeFieldBegin('stop', TType.STRUCT, 3)
+            self.stop.write(oprot)
+            oprot.writeFieldEnd()
+        if self.stopInclusive is not None:
+            oprot.writeFieldBegin('stopInclusive', TType.BOOL, 4)
+            oprot.writeBool(self.stopInclusive)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ScanColumn(object):
+    """
+    Attributes:
+     - colFamily
+     - colQualifier
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'colFamily', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 2
+    )
+
+    def __init__(self, colFamily=None, colQualifier=None,):
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ScanColumn')
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 1)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class IteratorSetting(object):
+    """
+    Attributes:
+     - priority
+     - name
+     - iteratorClass
+     - properties
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.I32, 'priority', None, None, ),  # 1
+        (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'iteratorClass', 'UTF8', None, ),  # 3
+        (4, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
+    )
+
+    def __init__(self, priority=None, name=None, iteratorClass=None, properties=None,):
+        self.priority = priority
+        self.name = name
+        self.iteratorClass = iteratorClass
+        self.properties = properties
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I32:
+                    self.priority = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.iteratorClass = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.MAP:
+                    self.properties = {}
+                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
+                    for _i18 in range(_size14):
+                        _key19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val20 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.properties[_key19] = _val20
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('IteratorSetting')
+        if self.priority is not None:
+            oprot.writeFieldBegin('priority', TType.I32, 1)
+            oprot.writeI32(self.priority)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 2)
+            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldEnd()
+        if self.iteratorClass is not None:
+            oprot.writeFieldBegin('iteratorClass', TType.STRING, 3)
+            oprot.writeString(self.iteratorClass.encode('utf-8') if sys.version_info[0] == 2 else self.iteratorClass)
+            oprot.writeFieldEnd()
+        if self.properties is not None:
+            oprot.writeFieldBegin('properties', TType.MAP, 4)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
+            for kiter21, viter22 in list(self.properties.items()):
+                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
+                oprot.writeString(viter22.encode('utf-8') if sys.version_info[0] == 2 else viter22)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ScanOptions(object):
+    """
+    Attributes:
+     - authorizations
+     - range
+     - columns
+     - iterators
+     - bufferSize
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 1
+        (2, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ),  # 2
+        (3, TType.LIST, 'columns', (TType.STRUCT, (ScanColumn, ScanColumn.thrift_spec), False), None, ),  # 3
+        (4, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 4
+        (5, TType.I32, 'bufferSize', None, None, ),  # 5
+    )
+
+    def __init__(self, authorizations=None, range=None, columns=None, iterators=None, bufferSize=None,):
+        self.authorizations = authorizations
+        self.range = range
+        self.columns = columns
+        self.iterators = iterators
+        self.bufferSize = bufferSize
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype26, _size23) = iprot.readSetBegin()
+                    for _i27 in range(_size23):
+                        _elem28 = iprot.readBinary()
+                        self.authorizations.add(_elem28)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.range = Range()
+                    self.range.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.columns = []
+                    (_etype32, _size29) = iprot.readListBegin()
+                    for _i33 in range(_size29):
+                        _elem34 = ScanColumn()
+                        _elem34.read(iprot)
+                        self.columns.append(_elem34)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype38, _size35) = iprot.readListBegin()
+                    for _i39 in range(_size35):
+                        _elem40 = IteratorSetting()
+                        _elem40.read(iprot)
+                        self.iterators.append(_elem40)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.bufferSize = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ScanOptions')
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 1)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter41 in self.authorizations:
+                oprot.writeBinary(iter41)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.range is not None:
+            oprot.writeFieldBegin('range', TType.STRUCT, 2)
+            self.range.write(oprot)
+            oprot.writeFieldEnd()
+        if self.columns is not None:
+            oprot.writeFieldBegin('columns', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.columns))
+            for iter42 in self.columns:
+                iter42.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 4)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter43 in self.iterators:
+                iter43.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.bufferSize is not None:
+            oprot.writeFieldBegin('bufferSize', TType.I32, 5)
+            oprot.writeI32(self.bufferSize)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class BatchScanOptions(object):
+    """
+    Attributes:
+     - authorizations
+     - ranges
+     - columns
+     - iterators
+     - threads
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 1
+        (2, TType.LIST, 'ranges', (TType.STRUCT, (Range, Range.thrift_spec), False), None, ),  # 2
+        (3, TType.LIST, 'columns', (TType.STRUCT, (ScanColumn, ScanColumn.thrift_spec), False), None, ),  # 3
+        (4, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 4
+        (5, TType.I32, 'threads', None, None, ),  # 5
+    )
+
+    def __init__(self, authorizations=None, ranges=None, columns=None, iterators=None, threads=None,):
+        self.authorizations = authorizations
+        self.ranges = ranges
+        self.columns = columns
+        self.iterators = iterators
+        self.threads = threads
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype47, _size44) = iprot.readSetBegin()
+                    for _i48 in range(_size44):
+                        _elem49 = iprot.readBinary()
+                        self.authorizations.add(_elem49)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.LIST:
+                    self.ranges = []
+                    (_etype53, _size50) = iprot.readListBegin()
+                    for _i54 in range(_size50):
+                        _elem55 = Range()
+                        _elem55.read(iprot)
+                        self.ranges.append(_elem55)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.columns = []
+                    (_etype59, _size56) = iprot.readListBegin()
+                    for _i60 in range(_size56):
+                        _elem61 = ScanColumn()
+                        _elem61.read(iprot)
+                        self.columns.append(_elem61)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype65, _size62) = iprot.readListBegin()
+                    for _i66 in range(_size62):
+                        _elem67 = IteratorSetting()
+                        _elem67.read(iprot)
+                        self.iterators.append(_elem67)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.threads = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('BatchScanOptions')
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 1)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter68 in self.authorizations:
+                oprot.writeBinary(iter68)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.ranges is not None:
+            oprot.writeFieldBegin('ranges', TType.LIST, 2)
+            oprot.writeListBegin(TType.STRUCT, len(self.ranges))
+            for iter69 in self.ranges:
+                iter69.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.columns is not None:
+            oprot.writeFieldBegin('columns', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.columns))
+            for iter70 in self.columns:
+                iter70.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 4)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter71 in self.iterators:
+                iter71.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.threads is not None:
+            oprot.writeFieldBegin('threads', TType.I32, 5)
+            oprot.writeI32(self.threads)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class KeyValueAndPeek(object):
+    """
+    Attributes:
+     - keyValue
+     - hasNext
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'keyValue', (KeyValue, KeyValue.thrift_spec), None, ),  # 1
+        (2, TType.BOOL, 'hasNext', None, None, ),  # 2
+    )
+
+    def __init__(self, keyValue=None, hasNext=None,):
+        self.keyValue = keyValue
+        self.hasNext = hasNext
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.keyValue = KeyValue()
+                    self.keyValue.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.BOOL:
+                    self.hasNext = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('KeyValueAndPeek')
+        if self.keyValue is not None:
+            oprot.writeFieldBegin('keyValue', TType.STRUCT, 1)
+            self.keyValue.write(oprot)
+            oprot.writeFieldEnd()
+        if self.hasNext is not None:
+            oprot.writeFieldBegin('hasNext', TType.BOOL, 2)
+            oprot.writeBool(self.hasNext)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class KeyExtent(object):
+    """
+    Attributes:
+     - tableId
+     - endRow
+     - prevEndRow
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'tableId', 'UTF8', None, ),  # 1
+        (2, TType.STRING, 'endRow', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'prevEndRow', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, tableId=None, endRow=None, prevEndRow=None,):
+        self.tableId = tableId
+        self.endRow = endRow
+        self.prevEndRow = prevEndRow
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.tableId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.prevEndRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('KeyExtent')
+        if self.tableId is not None:
+            oprot.writeFieldBegin('tableId', TType.STRING, 1)
+            oprot.writeString(self.tableId.encode('utf-8') if sys.version_info[0] == 2 else self.tableId)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 2)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.prevEndRow is not None:
+            oprot.writeFieldBegin('prevEndRow', TType.STRING, 3)
+            oprot.writeBinary(self.prevEndRow)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class Column(object):
+    """
+    Attributes:
+     - colFamily
+     - colQualifier
+     - colVisibility
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'colFamily', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'colVisibility', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, colFamily=None, colQualifier=None, colVisibility=None,):
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+        self.colVisibility = colVisibility
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.colVisibility = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Column')
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 1)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        if self.colVisibility is not None:
+            oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
+            oprot.writeBinary(self.colVisibility)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class Condition(object):
+    """
+    Attributes:
+     - column
+     - timestamp
+     - value
+     - iterators
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'column', (Column, Column.thrift_spec), None, ),  # 1
+        (2, TType.I64, 'timestamp', None, None, ),  # 2
+        (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
+        (4, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 4
+    )
+
+    def __init__(self, column=None, timestamp=None, value=None, iterators=None,):
+        self.column = column
+        self.timestamp = timestamp
+        self.value = value
+        self.iterators = iterators
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.column = Column()
+                    self.column.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.timestamp = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.value = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype75, _size72) = iprot.readListBegin()
+                    for _i76 in range(_size72):
+                        _elem77 = IteratorSetting()
+                        _elem77.read(iprot)
+                        self.iterators.append(_elem77)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Condition')
+        if self.column is not None:
+            oprot.writeFieldBegin('column', TType.STRUCT, 1)
+            self.column.write(oprot)
+            oprot.writeFieldEnd()
+        if self.timestamp is not None:
+            oprot.writeFieldBegin('timestamp', TType.I64, 2)
+            oprot.writeI64(self.timestamp)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 3)
+            oprot.writeBinary(self.value)
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 4)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter78 in self.iterators:
+                iter78.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ConditionalUpdates(object):
+    """
+    Attributes:
+     - conditions
+     - updates
+    """
+
+    thrift_spec = (
+        None,  # 0
+        None,  # 1
+        (2, TType.LIST, 'conditions', (TType.STRUCT, (Condition, Condition.thrift_spec), False), None, ),  # 2
+        (3, TType.LIST, 'updates', (TType.STRUCT, (ColumnUpdate, ColumnUpdate.thrift_spec), False), None, ),  # 3
+    )
+
+    def __init__(self, conditions=None, updates=None,):
+        self.conditions = conditions
+        self.updates = updates
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 2:
+                if ftype == TType.LIST:
+                    self.conditions = []
+                    (_etype82, _size79) = iprot.readListBegin()
+                    for _i83 in range(_size79):
+                        _elem84 = Condition()
+                        _elem84.read(iprot)
+                        self.conditions.append(_elem84)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.updates = []
+                    (_etype88, _size85) = iprot.readListBegin()
+                    for _i89 in range(_size85):
+                        _elem90 = ColumnUpdate()
+                        _elem90.read(iprot)
+                        self.updates.append(_elem90)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ConditionalUpdates')
+        if self.conditions is not None:
+            oprot.writeFieldBegin('conditions', TType.LIST, 2)
+            oprot.writeListBegin(TType.STRUCT, len(self.conditions))
+            for iter91 in self.conditions:
+                iter91.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.updates is not None:
+            oprot.writeFieldBegin('updates', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.updates))
+            for iter92 in self.updates:
+                iter92.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ConditionalWriterOptions(object):
+    """
+    Attributes:
+     - maxMemory
+     - timeoutMs
+     - threads
+     - authorizations
+     - durability
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.I64, 'maxMemory', None, None, ),  # 1
+        (2, TType.I64, 'timeoutMs', None, None, ),  # 2
+        (3, TType.I32, 'threads', None, None, ),  # 3
+        (4, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 4
+        (5, TType.I32, 'durability', None, None, ),  # 5
+    )
+
+    def __init__(self, maxMemory=None, timeoutMs=None, threads=None, authorizations=None, durability=None,):
+        self.maxMemory = maxMemory
+        self.timeoutMs = timeoutMs
+        self.threads = threads
+        self.authorizations = authorizations
+        self.durability = durability
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.maxMemory = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.timeoutMs = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.threads = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype96, _size93) = iprot.readSetBegin()
+                    for _i97 in range(_size93):
+                        _elem98 = iprot.readBinary()
+                        self.authorizations.add(_elem98)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.durability = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ConditionalWriterOptions')
+        if self.maxMemory is not None:
+            oprot.writeFieldBegin('maxMemory', TType.I64, 1)
+            oprot.writeI64(self.maxMemory)
+            oprot.writeFieldEnd()
+        if self.timeoutMs is not None:
+            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
+            oprot.writeI64(self.timeoutMs)
+            oprot.writeFieldEnd()
+        if self.threads is not None:
+            oprot.writeFieldBegin('threads', TType.I32, 3)
+            oprot.writeI32(self.threads)
+            oprot.writeFieldEnd()
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 4)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter99 in self.authorizations:
+                oprot.writeBinary(iter99)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.durability is not None:
+            oprot.writeFieldBegin('durability', TType.I32, 5)
+            oprot.writeI32(self.durability)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ActiveScan(object):
+    """
+    Attributes:
+     - client
+     - user
+     - table
+     - age
+     - idleTime
+     - type
+     - state
+     - extent
+     - columns
+     - iterators
+     - authorizations
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'client', 'UTF8', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I64, 'age', None, None, ),  # 4
+        (5, TType.I64, 'idleTime', None, None, ),  # 5
+        (6, TType.I32, 'type', None, None, ),  # 6
+        (7, TType.I32, 'state', None, None, ),  # 7
+        (8, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ),  # 8
+        (9, TType.LIST, 'columns', (TType.STRUCT, (Column, Column.thrift_spec), False), None, ),  # 9
+        (10, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 10
+        (11, TType.LIST, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 11
+    )
+
+    def __init__(self, client=None, user=None, table=None, age=None, idleTime=None, type=None, state=None, extent=None, columns=None, iterators=None, authorizations=None,):
+        self.client = client
+        self.user = user
+        self.table = table
+        self.age = age
+        self.idleTime = idleTime
+        self.type = type
+        self.state = state
+        self.extent = extent
+        self.columns = columns
+        self.iterators = iterators
+        self.authorizations = authorizations
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.client = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I64:
+                    self.age = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I64:
+                    self.idleTime = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.I32:
+                    self.type = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.I32:
+                    self.state = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.STRUCT:
+                    self.extent = KeyExtent()
+                    self.extent.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 9:
+                if ftype == TType.LIST:
+                    self.columns = []
+                    (_etype103, _size100) = iprot.readListBegin()
+                    for _i104 in range(_size100):
+                        _elem105 = Column()
+                        _elem105.read(iprot)
+                        self.columns.append(_elem105)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 10:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype109, _size106) = iprot.readListBegin()
+                    for _i110 in range(_size106):
+                        _elem111 = IteratorSetting()
+                        _elem111.read(iprot)
+                        self.iterators.append(_elem111)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 11:
+                if ftype == TType.LIST:
+                    self.authorizations = []
+                    (_etype115, _size112) = iprot.readListBegin()
+                    for _i116 in range(_size112):
+                        _elem117 = iprot.readBinary()
+                        self.authorizations.append(_elem117)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ActiveScan')
+        if self.client is not None:
+            oprot.writeFieldBegin('client', TType.STRING, 1)
+            oprot.writeString(self.client.encode('utf-8') if sys.version_info[0] == 2 else self.client)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.age is not None:
+            oprot.writeFieldBegin('age', TType.I64, 4)
+            oprot.writeI64(self.age)
+            oprot.writeFieldEnd()
+        if self.idleTime is not None:
+            oprot.writeFieldBegin('idleTime', TType.I64, 5)
+            oprot.writeI64(self.idleTime)
+            oprot.writeFieldEnd()
+        if self.type is not None:
+            oprot.writeFieldBegin('type', TType.I32, 6)
+            oprot.writeI32(self.type)
+            oprot.writeFieldEnd()
+        if self.state is not None:
+            oprot.writeFieldBegin('state', TType.I32, 7)
+            oprot.writeI32(self.state)
+            oprot.writeFieldEnd()
+        if self.extent is not None:
+            oprot.writeFieldBegin('extent', TType.STRUCT, 8)
+            self.extent.write(oprot)
+            oprot.writeFieldEnd()
+        if self.columns is not None:
+            oprot.writeFieldBegin('columns', TType.LIST, 9)
+            oprot.writeListBegin(TType.STRUCT, len(self.columns))
+            for iter118 in self.columns:
+                iter118.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 10)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter119 in self.iterators:
+                iter119.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.LIST, 11)
+            oprot.writeListBegin(TType.STRING, len(self.authorizations))
+            for iter120 in self.authorizations:
+                oprot.writeBinary(iter120)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ActiveCompaction(object):
+    """
+    Attributes:
+     - extent
+     - age
+     - inputFiles
+     - outputFile
+     - type
+     - reason
+     - localityGroup
+     - entriesRead
+     - entriesWritten
+     - iterators
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ),  # 1
+        (2, TType.I64, 'age', None, None, ),  # 2
+        (3, TType.LIST, 'inputFiles', (TType.STRING, 'UTF8', False), None, ),  # 3
+        (4, TType.STRING, 'outputFile', 'UTF8', None, ),  # 4
+        (5, TType.I32, 'type', None, None, ),  # 5
+        (6, TType.I32, 'reason', None, None, ),  # 6
+        (7, TType.STRING, 'localityGroup', 'UTF8', None, ),  # 7
+        (8, TType.I64, 'entriesRead', None, None, ),  # 8
+        (9, TType.I64, 'entriesWritten', None, None, ),  # 9
+        (10, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 10
+    )
+
+    def __init__(self, extent=None, age=None, inputFiles=None, outputFile=None, type=None, reason=None, localityGroup=None, entriesRead=None, entriesWritten=None, iterators=None,):
+        self.extent = extent
+        self.age = age
+        self.inputFiles = inputFiles
+        self.outputFile = outputFile
+        self.type = type
+        self.reason = reason
+        self.localityGroup = localityGroup
+        self.entriesRead = entriesRead
+        self.entriesWritten = entriesWritten
+        self.iterators = iterators
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.extent = KeyExtent()
+                    self.extent.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.age = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.inputFiles = []
+                    (_etype124, _size121) = iprot.readListBegin()
+                    for _i125 in range(_size121):
+                        _elem126 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.inputFiles.append(_elem126)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.outputFile = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.type = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.I32:
+                    self.reason = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.STRING:
+                    self.localityGroup = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.I64:
+                    self.entriesRead = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 9:
+                if ftype == TType.I64:
+                    self.entriesWritten = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 10:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype130, _size127) = iprot.readListBegin()
+                    for _i131 in range(_size127):
+                        _elem132 = IteratorSetting()
+                        _elem132.read(iprot)
+                        self.iterators.append(_elem132)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ActiveCompaction')
+        if self.extent is not None:
+            oprot.writeFieldBegin('extent', TType.STRUCT, 1)
+            self.extent.write(oprot)
+            oprot.writeFieldEnd()
+        if self.age is not None:
+            oprot.writeFieldBegin('age', TType.I64, 2)
+            oprot.writeI64(self.age)
+            oprot.writeFieldEnd()
+        if self.inputFiles is not None:
+            oprot.writeFieldBegin('inputFiles', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRING, len(self.inputFiles))
+            for iter133 in self.inputFiles:
+                oprot.writeString(iter133.encode('utf-8') if sys.version_info[0] == 2 else iter133)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.outputFile is not None:
+            oprot.writeFieldBegin('outputFile', TType.STRING, 4)
+            oprot.writeString(self.outputFile.encode('utf-8') if sys.version_info[0] == 2 else self.outputFile)
+            oprot.writeFieldEnd()
+        if self.type is not None:
+            oprot.writeFieldBegin('type', TType.I32, 5)
+            oprot.writeI32(self.type)
+            oprot.writeFieldEnd()
+        if self.reason is not None:
+            oprot.writeFieldBegin('reason', TType.I32, 6)
+            oprot.writeI32(self.reason)
+            oprot.writeFieldEnd()
+        if self.localityGroup is not None:
+            oprot.writeFieldBegin('localityGroup', TType.STRING, 7)
+            oprot.writeString(self.localityGroup.encode('utf-8') if sys.version_info[0] == 2 else self.localityGroup)
+            oprot.writeFieldEnd()
+        if self.entriesRead is not None:
+            oprot.writeFieldBegin('entriesRead', TType.I64, 8)
+            oprot.writeI64(self.entriesRead)
+            oprot.writeFieldEnd()
+        if self.entriesWritten is not None:
+            oprot.writeFieldBegin('entriesWritten', TType.I64, 9)
+            oprot.writeI64(self.entriesWritten)
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 10)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter134 in self.iterators:
+                iter134.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class WriterOptions(object):
+    """
+    Attributes:
+     - maxMemory
+     - latencyMs
+     - timeoutMs
+     - threads
+     - durability
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.I64, 'maxMemory', None, None, ),  # 1
+        (2, TType.I64, 'latencyMs', None, None, ),  # 2
+        (3, TType.I64, 'timeoutMs', None, None, ),  # 3
+        (4, TType.I32, 'threads', None, None, ),  # 4
+        (5, TType.I32, 'durability', None, None, ),  # 5
+    )
+
+    def __init__(self, maxMemory=None, latencyMs=None, timeoutMs=None, threads=None, durability=None,):
+        self.maxMemory = maxMemory
+        self.latencyMs = latencyMs
+        self.timeoutMs = timeoutMs
+        self.threads = threads
+        self.durability = durability
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.maxMemory = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.latencyMs = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I64:
+                    self.timeoutMs = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.threads = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.durability = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('WriterOptions')
+        if self.maxMemory is not None:
+            oprot.writeFieldBegin('maxMemory', TType.I64, 1)
+            oprot.writeI64(self.maxMemory)
+            oprot.writeFieldEnd()
+        if self.latencyMs is not None:
+            oprot.writeFieldBegin('latencyMs', TType.I64, 2)
+            oprot.writeI64(self.latencyMs)
+            oprot.writeFieldEnd()
+        if self.timeoutMs is not None:
+            oprot.writeFieldBegin('timeoutMs', TType.I64, 3)
+            oprot.writeI64(self.timeoutMs)
+            oprot.writeFieldEnd()
+        if self.threads is not None:
+            oprot.writeFieldBegin('threads', TType.I32, 4)
+            oprot.writeI32(self.threads)
+            oprot.writeFieldEnd()
+        if self.durability is not None:
+            oprot.writeFieldBegin('durability', TType.I32, 5)
+            oprot.writeI32(self.durability)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class CompactionStrategyConfig(object):
+    """
+    Attributes:
+     - className
+     - options
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'className', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'options', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
+    )
+
+    def __init__(self, className=None, options=None,):
+        self.className = className
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.options = {}
+                    (_ktype136, _vtype137, _size135) = iprot.readMapBegin()
+                    for _i139 in range(_size135):
+                        _key140 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val141 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.options[_key140] = _val141
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('CompactionStrategyConfig')
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 1)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.options))
+            for kiter142, viter143 in list(self.options.items()):
+                oprot.writeString(kiter142.encode('utf-8') if sys.version_info[0] == 2 else kiter142)
+                oprot.writeString(viter143.encode('utf-8') if sys.version_info[0] == 2 else viter143)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
 
 class UnknownScanner(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('UnknownScanner')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('UnknownScanner')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class UnknownWriter(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('UnknownWriter')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('UnknownWriter')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class NoMoreEntriesException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('NoMoreEntriesException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NoMoreEntriesException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class AccumuloException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('AccumuloException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('AccumuloException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class AccumuloSecurityException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('AccumuloSecurityException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('AccumuloSecurityException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class TableNotFoundException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('TableNotFoundException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('TableNotFoundException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class TableExistsException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('TableExistsException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('TableExistsException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class MutationsRejectedException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('MutationsRejectedException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class NamespaceExistsException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NamespaceExistsException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class NamespaceNotFoundException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NamespaceNotFoundException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class NamespaceNotEmptyException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NamespaceNotEmptyException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __ne__(self, other):
-    return not (self == other)
+    def __ne__(self, other):
+        return not (self == other)
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/RELEASE-VERSION pyaccumulo-new/RELEASE-VERSION
--- pyaccumulo/RELEASE-VERSION	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/RELEASE-VERSION	2017-03-15 22:29:03.102584651 +0000
@@ -0,0 +1 @@
+1.5.0.10.dev7,g8adc
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/setup.py pyaccumulo-new/setup.py
--- pyaccumulo/setup.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/setup.py	2017-03-15 22:31:52.214584651 +0000
@@ -32,14 +32,14 @@
             if status:
                 raise RuntimeError("RPM build failed")
 
-            print ""
-            print "RPM built"
+            print("")
+            print("RPM built")
         else:
-            print """
+            print("""
 `setup.py rpm` is not supported for this version of Python.
 
 Please ask in the user forums for help.
-"""
+""")
 
 class doc(Command):
     description = "generate or test documentation"
@@ -72,15 +72,15 @@
             if status:
                 raise RuntimeError("documentation step '%s' failed" % mode)
 
-            print ""
-            print "Documentation step '%s' performed, results here:" % mode
-            print "   %s/" % path
+            print("")
+            print("Documentation step '%s' performed, results here:" % mode)
+            print("   %s/" % path)
         else:
-            print """
+            print("""
 `setup.py doc` is not supported for this version of Python.
 
 Please ask in the user forums for help.
-"""
+""")
 
 class PyTest(Command):
     '''run py.test'''
@@ -108,7 +108,7 @@
         # reload sys.path for any new libraries installed
         import site
         site.main()
-        print sys.path
+        print(sys.path)
         # use pytest to run tests
         pytest = __import__('pytest')
         exitcode = pytest.main(['--cov', 'pyaccumulo', '--cov-report', 'term', '-vvs', 'tests'])
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/tests/test_core.py pyaccumulo-new/tests/test_core.py
--- pyaccumulo/tests/test_core.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/tests/test_core.py	2017-03-15 23:38:47.843403005 +0000
@@ -30,13 +30,13 @@
         return conn
 
     def test_get_scan_columns(self):
-        self.assertEquals(None, pyaccumulo._get_scan_columns([]))
-        self.assertEquals([ ScanColumn(colFamily="cf", colQualifier="cq") ], pyaccumulo._get_scan_columns([ ["cf", "cq"]]))
-        self.assertEquals([ ScanColumn(colFamily="cf", colQualifier="cq"), ScanColumn(colFamily="a") ], pyaccumulo._get_scan_columns([ ["cf", "cq"], ["a"]]))
+        self.assertEqual(None, pyaccumulo._get_scan_columns([]))
+        self.assertEqual([ ScanColumn(colFamily="cf", colQualifier="cq") ], pyaccumulo._get_scan_columns([ ["cf", "cq"]]))
+        self.assertEqual([ ScanColumn(colFamily="cf", colQualifier="cq"), ScanColumn(colFamily="a") ], pyaccumulo._get_scan_columns([ ["cf", "cq"], ["a"]]))
 
     def test_following_array(self):
-        self.assertEquals("test\0", pyaccumulo.following_array("test"))
-        self.assertEquals(None, pyaccumulo.following_array(None))
+        self.assertEqual("test\0", pyaccumulo.following_array("test"))
+        self.assertEqual(None, pyaccumulo.following_array(None))
 
     def test_list_tables(self):
         conn = self._get_mock_connection()
@@ -45,7 +45,7 @@
 
         res = conn.list_tables()
         conn.client.listTables.assert_called_with("Login")
-        self.assertEquals(set(["t1", "t2", "t3"]), set(res))
+        self.assertEqual(set(["t1", "t2", "t3"]), set(res))
 
 
     def test_table_exists(self):
@@ -55,7 +55,7 @@
 
         res = conn.table_exists("mytable")
         conn.client.tableExists.assert_called_with("Login", "mytable")
-        self.assertEquals(True, res)
+        self.assertEqual(True, res)
 
 
     def test_create_table(self):
@@ -86,10 +86,10 @@
 
         res = conn._get_range(r)
         r.to_range.assert_called_with()
-        self.assertEquals("xyz", res)
+        self.assertEqual("xyz", res)
 
         res = conn._get_range(None)
-        self.assertEquals(None, res)
+        self.assertEqual(None, res)
 
     def test_get_ranges(self):
         conn = Accumulo(_connect=False)
@@ -99,10 +99,10 @@
 
         res = conn._get_ranges([r])
         r.to_range.assert_called_with()
-        self.assertEquals(["xyz"], res)
+        self.assertEqual(["xyz"], res)
 
         res = conn._get_ranges(None)
-        self.assertEquals(None, res)
+        self.assertEqual(None, res)
 
     def test_write(self):
         conn = Accumulo(_connect=False)
@@ -134,16 +134,16 @@
         conn = Accumulo(_connect=False)
 
         res = conn._get_iterator_settings(None)
-        self.assertEquals(None, res)
+        self.assertEqual(None, res)
 
     def test_process_iterator(self):
         conn = Accumulo(_connect=False)
 
         res = conn._process_iterator(IteratorSetting(name="i1"))
-        self.assertEquals(IteratorSetting(name="i1"), res)
+        self.assertEqual(IteratorSetting(name="i1"), res)
 
         res = conn._process_iterator(BaseIterator(name="n1", priority=21, classname="c1"))
-        self.assertEquals(IteratorSetting(priority=21, iteratorClass='c1', name='n1', properties={}), res)
+        self.assertEqual(IteratorSetting(priority=21, iteratorClass='c1', name='n1', properties={}), res)
 
         with self.assertRaises(Exception):
             conn._process_iterator("not an iterator")
@@ -172,11 +172,11 @@
 
     def test_following_key(self):
         conn = self._get_mock_connection()
-        key = Key(row="aabbcc", colFamily="cf", colQualifier="cq")
+        key = Key(timestamp=None, row="aabbcc", colFamily="cf", colQualifier="cq")
         conn.client.getFollowing = Mock(return_value=following_key(key))
         fkey = conn.following_key(key, PartialKey.ROW_COLFAM_COLQUAL_COLVIS)
         conn.client.getFollowing.assert_called_with(key, PartialKey.ROW_COLFAM_COLQUAL_COLVIS)
-        self.assertEqual(fkey, Key(row="aabbcc", colFamily="cf", colQualifier="cq\0"))
+        self.assertEqual(fkey, Key(timestamp=None, row="aabbcc", colFamily="cf", colQualifier="cq\0"))
 
     def test_get_max_row(self):
         conn = self._get_mock_connection()
@@ -296,73 +296,111 @@
 
         r = Range(srow=None, erow=None)
         rng = r.to_range()
-        self.assertEquals(None, rng.start)
-        self.assertEquals(None, rng.stop)
+        self.assertEqual(None, rng.start)
+        self.assertEqual(None, rng.stop)
 
         r = Range(srow="r01", erow="r02")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01"), rng.start)
-        self.assertEquals(Key(row="r02\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02\0"), rng.stop)
 
         r = Range(erow="r02", einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r02"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r02"), rng.stop)
 
         r = Range(srow="r01", sinclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r01\0"), rng.start)
 
         r = Range(srow="r01", scf="cf1", erow="r02", ecf="cf2")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2\0"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2\0"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", scv="xy", ecv="zx")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx\0"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", sts=100, ets=101, scv="xy", ecv="zx")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=100, colVisibility="xy"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=100, colVisibility="zx"), rng.stop)
+        self.assertEqual(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=100, colVisibility="xy"), rng.start)
+        self.assertEqual(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=100, colVisibility="zx"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", erow="r02", ecf="cf2", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1\0"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1\0"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", scv="xy", ecv="zx", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy\0"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", sts=100, ets=101, scv="xy", ecv="zx", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=99, colVisibility="xy"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=101, colVisibility="zx"), rng.stop)
+        self.assertEqual(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=99, colVisibility="xy"), rng.start)
+        self.assertEqual(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=101, colVisibility="zx"), rng.stop)
+
+    def test_followingPrefix(self):
+        self.assertIsNone(Range.followingPrefix(b''))
+
+        self.assertIsNone(Range.followingPrefix(b'\xff'))
+
+        self.assertEqual(b'\xff',  Range.followingPrefix(b'\xfe'))
+
+        self.assertEqual(b'\x44\xff\xfe\x08',
+            Range.followingPrefix(b'\x44\xff\xfe\x07\xff\xff'))
+
+    def test_prefix(self):
+        r = Range.prefix(b'')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertIsNone(r.erow)
+
+        r = Range.prefix(b'\xff')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'\xff', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertIsNone(r.erow)
+
+        r = Range.prefix(b'\xfe')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'\xfe', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertEqual(b'\xff', r.erow)
+        self.assertFalse(r.einclude)
+
+        r = Range.prefix(b'\x44\xff\xfe\x07\xff\xff')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'\x44\xff\xfe\x07\xff\xff', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertEqual(b'\x44\xff\xfe\x08', r.erow)
+        self.assertFalse(r.einclude)
+
 
 class MutationTest(unittest.TestCase):
     def test_mutation(self):
         m = Mutation("row1")
-        self.assertEquals("row1", m.row)
-        self.assertEquals([], m.updates)
+        self.assertEqual("row1", m.row)
+        self.assertEqual([], m.updates)
 
     def test_put(self):
         m = Mutation("row1")
-        self.assertEquals([], m.updates)
+        self.assertEqual([], m.updates)
         m.put(cf="cf1", cq="cq1", cv="xy", ts=101, val="myval")
-        self.assertEquals([ColumnUpdate(colFamily="cf1", colQualifier="cq1", colVisibility="xy", timestamp=101, value="myval", deleteCell=None)], m.updates)
+        self.assertEqual([ColumnUpdate(colFamily="cf1", colQualifier="cq1", colVisibility="xy", timestamp=101, value="myval", deleteCell=None)], m.updates)
 
         
 class BatchWriterTest(unittest.TestCase):
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/tests/test_iterator.py pyaccumulo-new/tests/test_iterator.py
--- pyaccumulo/tests/test_iterator.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/tests/test_iterator.py	2017-03-15 22:32:50.690584651 +0000
@@ -15,6 +15,8 @@
 # limitations under the License.
 
 import unittest
+import base64
+
 from mock import Mock
 from pyaccumulo.iterators import *
 from pyaccumulo.proxy.ttypes import IteratorSetting, IteratorScope
@@ -22,15 +24,15 @@
 class BaseIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = BaseIterator(name="test123", priority=111, classname="com.test.Class")
-        self.assertEquals("test123", i.name)
-        self.assertEquals(111, i.priority)
-        self.assertEquals("com.test.Class", i.classname)
+        self.assertEqual("test123", i.name)
+        self.assertEqual(111, i.priority)
+        self.assertEqual("com.test.Class", i.classname)
 
         a = i.get_iterator_setting()
-        self.assertEquals("test123", a.name)
-        self.assertEquals(111, a.priority)
-        self.assertEquals("com.test.Class", a.iteratorClass)
-        self.assertEquals({}, a.properties)
+        self.assertEqual("test123", a.name)
+        self.assertEqual(111, a.priority)
+        self.assertEqual("com.test.Class", a.iteratorClass)
+        self.assertEqual({}, a.properties)
 
     def test_attach(self):
         i = BaseIterator(name="test123", priority=111, classname="com.test.Class")
@@ -49,18 +51,18 @@
 class BaseCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = BaseCombiner(name="test123", priority=111, classname="com.test.Class", columns=[["a", "b"], ["z", "y"]], encoding_type="STRING")
-        self.assertEquals("test123", i.name)
-        self.assertEquals(111, i.priority)
-        self.assertEquals("com.test.Class", i.classname)
-        self.assertEquals([["a", "b"], ["z", "y"]], i.columns)
-        self.assertEquals(False, i.combine_all_columns)
-        self.assertEquals("STRING", i.encoding_type)
+        self.assertEqual("test123", i.name)
+        self.assertEqual(111, i.priority)
+        self.assertEqual("com.test.Class", i.classname)
+        self.assertEqual([["a", "b"], ["z", "y"]], i.columns)
+        self.assertEqual(False, i.combine_all_columns)
+        self.assertEqual("STRING", i.encoding_type)
 
         a = i.get_iterator_setting()
-        self.assertEquals("test123", a.name)
-        self.assertEquals(111, a.priority)
-        self.assertEquals("com.test.Class", a.iteratorClass)
-        self.assertEquals(
+        self.assertEqual("test123", a.name)
+        self.assertEqual(111, a.priority)
+        self.assertEqual("com.test.Class", a.iteratorClass)
+        self.assertEqual(
             {
                 "type":"STRING",
                 "all": "false",
@@ -69,47 +71,47 @@
             a.properties)
 
         i.add_column(colf="c")
-        self.assertEquals([["a", "b"], ["z", "y"], ["c"]], i.columns)
+        self.assertEqual([["a", "b"], ["z", "y"], ["c"]], i.columns)
         
         i.add_column(colf="c", colq="d")
-        self.assertEquals([["a", "b"], ["z", "y"], ["c"], ["c", "d"]], i.columns)
+        self.assertEqual([["a", "b"], ["z", "y"], ["c"], ["c", "d"]], i.columns)
 
 
     def test_encode_col(self):
         i = BaseCombiner(name="test123", priority=111, classname="com.test.Class")
-        self.assertEquals("a", i._encode_column( ["a"] ) )
-        self.assertEquals("a:b", i._encode_column( ["a", "b"] ) )
+        self.assertEqual("a", i._encode_column( ["a"] ) )
+        self.assertEqual("a:b", i._encode_column( ["a", "b"] ) )
 
 
 class SummingCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = SummingCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.SummingCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.SummingCombiner", i.classname)
 
 class SummingArrayCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = SummingArrayCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.SummingArrayCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.SummingArrayCombiner", i.classname)
 
 class MaxCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = MaxCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.MaxCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.MaxCombiner", i.classname)
 
 class MinCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = MinCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.MinCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.MinCombiner", i.classname)
 
 class GrepIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = GrepIterator(term="grep")
-        self.assertEquals("grep", i.term)
-        self.assertEquals(False, i.negate) 
-        self.assertEquals("org.apache.accumulo.core.iterators.user.GrepIterator", i.classname)
+        self.assertEqual("grep", i.term)
+        self.assertEqual(False, i.negate) 
+        self.assertEqual("org.apache.accumulo.core.iterators.user.GrepIterator", i.classname)
 
         a = i.get_iterator_setting()
-        self.assertEquals(
+        self.assertEqual(
             {
                 "term":"grep",
                 "negate": "false"
@@ -119,22 +121,22 @@
 class RowDeletingIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = RowDeletingIterator()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.RowDeletingIterator", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.RowDeletingIterator", i.classname)
 
 class RegExFilterTest(unittest.TestCase):
     def test_iterator(self):
         i = RegExFilter()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.RegExFilter", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.RegExFilter", i.classname)
 
         i = RegExFilter(row_regex="xyz", cf_regex="abc", cq_regex="def", val_regex="jkl", or_fields=True, match_substring=False)
-        self.assertEquals("xyz", i.row_regex)
-        self.assertEquals("abc", i.cf_regex)
-        self.assertEquals("def", i.cq_regex)
-        self.assertEquals("jkl", i.val_regex)
-        self.assertEquals(True, i.or_fields)
-        self.assertEquals(False, i.match_substring)
+        self.assertEqual("xyz", i.row_regex)
+        self.assertEqual("abc", i.cf_regex)
+        self.assertEqual("def", i.cq_regex)
+        self.assertEqual("jkl", i.val_regex)
+        self.assertEqual(True, i.or_fields)
+        self.assertEqual(False, i.match_substring)
 
-        self.assertEquals(
+        self.assertEqual(
             {
                 "rowRegex": "xyz",
                 "colfRegex": "abc",
@@ -148,25 +150,25 @@
 class IntersectingIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = IntersectingIterator(terms=["quick", "brown", "fox"], not_flags=[False, True, False])
-        self.assertEquals("org.apache.accumulo.core.iterators.user.IntersectingIterator", i.classname)
-        self.assertEquals(["quick", "brown", "fox"], i.terms)
-        self.assertEquals([False, True, False], i.not_flags)
-
-        self.assertEquals("\001", i._convert_flag(True))
-        self.assertEquals("\0", i._convert_flag(False))
-
-        self.assertEquals("\001\0\001".encode("base64"), i._encode_not_flags([True, False, True]))
-        self.assertEquals("\0\001\0".encode("base64"), i._encode_not_flags([False, True, False]))
-        self.assertEquals(None, i._encode_not_flags([]))
+        self.assertEqual("org.apache.accumulo.core.iterators.user.IntersectingIterator", i.classname)
+        self.assertEqual(["quick", "brown", "fox"], i.terms)
+        self.assertEqual([False, True, False], i.not_flags)
+
+        self.assertEqual("\001", i._convert_flag(True))
+        self.assertEqual("\0", i._convert_flag(False))
+
+        self.assertEqual(base64.b64encode(b"\001\0\001").decode("utf-8"), i._encode_not_flags([True, False, True]))
+        self.assertEqual(base64.b64encode(b"\0\001\0").decode("utf-8"), i._encode_not_flags([False, True, False]))
+        self.assertEqual(None, i._encode_not_flags([]))
 
-        self.assertEquals(
-            "quick".encode("base64") + "brown".encode("base64")+ "fox".encode("base64").rstrip("\n"), 
+        self.assertEqual(
+            base64.b64encode(b"quick").decode("utf-8") + base64.b64encode(b"brown").decode("utf-8")+ base64.b64encode(b"fox").decode("utf-8").rstrip("\n"), 
             i._encode_columns(["quick", "brown", "fox"]))
 
-        self.assertEquals( 
+        self.assertEqual( 
             {
-                "columnFamilies": "quick".encode("base64") + "brown".encode("base64")+ "fox".encode("base64").rstrip("\n"), 
-                "notFlag": "\0\001\0".encode("base64")
+                "columnFamilies": base64.b64encode(b"quick").decode("utf-8") + base64.b64encode(b"brown").decode("utf-8")+ base64.b64encode(b"fox").decode("utf-8").rstrip("\n"), 
+                "notFlag": base64.b64encode(b"\0\001\0").decode("utf-8")
             },
             i._get_iterator_properties()
         )
@@ -174,16 +176,16 @@
 class IndexedDocIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = IndexedDocIterator(terms=["quick", "brown", "fox"], not_flags=[False, True, False], index_colf="index", doc_colf="docs")
-        self.assertEquals("org.apache.accumulo.core.iterators.user.IndexedDocIterator", i.classname)
-        self.assertEquals(["quick", "brown", "fox"], i.terms)
-        self.assertEquals([False, True, False], i.not_flags)
-        self.assertEquals("index", i.index_colf)
-        self.assertEquals("docs", i.doc_colf)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.IndexedDocIterator", i.classname)
+        self.assertEqual(["quick", "brown", "fox"], i.terms)
+        self.assertEqual([False, True, False], i.not_flags)
+        self.assertEqual("index", i.index_colf)
+        self.assertEqual("docs", i.doc_colf)
 
-        self.assertEquals( 
+        self.assertEqual( 
             {
-                "columnFamilies": "quick".encode("base64") + "brown".encode("base64")+ "fox".encode("base64").rstrip("\n"), 
-                "notFlag": "\0\001\0".encode("base64"),
+                "columnFamilies": base64.b64encode(b"quick").decode("utf-8") + base64.b64encode(b"brown").decode("utf-8")+ base64.b64encode(b"fox").decode("utf-8").rstrip("\n"), 
+                "notFlag": base64.b64encode(b"\0\001\0").decode("utf-8"),
                 "indexFamily": "index", 
                 "docFamily": "docs"
             },
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/version.py pyaccumulo-new/version.py
--- pyaccumulo/version.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/version.py	2017-03-15 22:36:52.582584651 +0000
@@ -53,7 +53,7 @@
                   stdout=PIPE, stderr=PIPE, 
                   cwd=os.path.dirname(os.path.abspath(__file__)))
         p.stderr.close()
-        describe_line = p.stdout.readlines()[0].strip()
+        describe_line = p.stdout.readlines()[0].strip().decode('utf-8')
 
         p = Popen(['git', 'rev-parse', 'HEAD'],
                   stdout=PIPE, stderr=PIPE)
@@ -75,16 +75,16 @@
 
         return version, source_hash
  
-    except Exception, exc:
+    except Exception as exc:
         sys.stderr.write('line: %r\n' % line)
         sys.stderr.write(traceback.format_exc(exc))
         try:
             sys.stderr.write('p.stderr.read()=%s\n' % p.stderr.read())
-        except Exception, exc:
+        except Exception as exc:
             sys.stderr.write(traceback.format_exc(exc))
         try:
             sys.stderr.write('os.getcwd()=%s\n' % os.getcwd())
-        except Exception, exc:
+        except Exception as exc:
             sys.stderr.write(traceback.format_exc(exc))
         return None, None
  
@@ -145,4 +145,4 @@
  
  
 if __name__ == "__main__":
-    print get_git_version()
+    print(get_git_version())
