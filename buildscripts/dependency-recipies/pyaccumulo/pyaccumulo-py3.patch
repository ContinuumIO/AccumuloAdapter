diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/analytics.py pyaccumulo-new/examples/analytics.py
--- pyaccumulo/examples/analytics.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/analytics.py	2017-03-15 22:31:52.126584651 +0000
@@ -57,6 +57,6 @@
 wr.close()
 
 for e in conn.scan(table):
-    print e
+    print(e)
     
 conn.close()
\ No newline at end of file
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/indexed_doc_iterator/ingest.py pyaccumulo-new/examples/indexed_doc_iterator/ingest.py
--- pyaccumulo/examples/indexed_doc_iterator/ingest.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/indexed_doc_iterator/ingest.py	2017-03-15 22:31:52.218584651 +0000
@@ -27,7 +27,7 @@
 NUM_SHARDS=4
 
 def usage(msg=None):
-    print "Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0]
+    print("Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0])
     sys.exit(1)
 
 def get_uuid(filePath):
@@ -60,7 +60,7 @@
 conn = Accumulo(host=settings.HOST, port=settings.PORT, user=settings.USER, password=settings.PASSWORD)
 
 if not conn.table_exists(table):
-    print "Creating table: %s"%table
+    print("Creating table: %s"%table)
     conn.create_table(table)
 
 wr = conn.create_batch_writer(table)
@@ -69,7 +69,7 @@
     for root, subFolders, files in os.walk(indir):
         for filename in files:
             filePath = os.path.join(root, filename)
-            print "indexing file %s"%filePath
+            print("indexing file %s"%filePath)
             uuid = get_uuid(filePath)
             with open( filePath, 'r' ) as f:
                 write_mutations(wr, get_shard(uuid), uuid, filePath, get_tokens(f))
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/indexed_doc_iterator/search.py pyaccumulo-new/examples/indexed_doc_iterator/search.py
--- pyaccumulo/examples/indexed_doc_iterator/search.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/indexed_doc_iterator/search.py	2017-03-15 22:31:52.250584651 +0000
@@ -27,15 +27,15 @@
 
 table = sys.argv[1]
 if not conn.table_exists(table):
-    print "Table '%s' does not exist."%table
+    print("Table '%s' does not exist."%table)
     sys.exit(1)
 
 search_terms = [term.lower() for term in sys.argv[2:] if len(term) > 3]
 
 if len(search_terms) < 2:
-    print "More than one term of length > 3 is required for this example"
+    print("More than one term of length > 3 is required for this example")
     sys.exit(1)
 
 for e in conn.batch_scan(table, iterators=[IndexedDocIterator(priority=21, terms=search_terms)]):
-    print e.val
+    print(e.val)
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/intersecting_iterator/ingest.py pyaccumulo-new/examples/intersecting_iterator/ingest.py
--- pyaccumulo/examples/intersecting_iterator/ingest.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/intersecting_iterator/ingest.py	2017-03-15 22:31:52.362584651 +0000
@@ -27,7 +27,7 @@
 NUM_SHARDS=4
 
 def usage(msg=None):
-    print "Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0]
+    print("Usage: %s <table> <dir1> [<dir2> <dir3> ...]"%sys.argv[0])
     sys.exit(1)
 
 def get_uuid(filePath):
@@ -63,7 +63,7 @@
 conn = Accumulo(host=settings.HOST, port=settings.PORT, user=settings.USER, password=settings.PASSWORD)
 
 if not conn.table_exists(table):
-    print "Creating table: %s"%table
+    print("Creating table: %s"%table)
     conn.create_table(table)
 
 wr = conn.create_batch_writer(table)
@@ -72,7 +72,7 @@
     for root, subFolders, files in os.walk(indir):
         for filename in files:
             filePath = os.path.join(root, filename)
-            print "indexing file %s"%filePath
+            print("indexing file %s"%filePath)
             uuid = get_uuid(filePath)
             with open( filePath, 'r' ) as f:
                 write_mutations(wr, get_shard(uuid), uuid, filePath, get_tokens(f))
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/intersecting_iterator/search.py pyaccumulo-new/examples/intersecting_iterator/search.py
--- pyaccumulo/examples/intersecting_iterator/search.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/intersecting_iterator/search.py	2017-03-15 22:31:52.258584651 +0000
@@ -27,13 +27,13 @@
 
 table = sys.argv[1]
 if not conn.table_exists(table):
-    print "Table '%s' does not exist."%table
+    print("Table '%s' does not exist."%table)
     sys.exit(1)
 
 search_terms = [term.lower() for term in sys.argv[2:] if len(term) > 3]
 
 if len(search_terms) < 2:
-    print "More than one term of length > 3 is required for this example"
+    print("More than one term of length > 3 is required for this example")
     sys.exit(1)
 
 uuids = []
@@ -42,8 +42,8 @@
 
 if len(uuids) > 0:
     for doc in conn.batch_scan(table, scanranges=[Range(srow=uuid, erow=uuid) for uuid in uuids]):
-        print doc.val
+        print(doc.val)
 else:
-    print "No results found"
+    print("No results found")
 
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/regex_search.py pyaccumulo-new/examples/regex_search.py
--- pyaccumulo/examples/regex_search.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/regex_search.py	2017-03-15 22:31:52.258584651 +0000
@@ -48,6 +48,6 @@
 regex3 = RegExFilter(priority=23, val_regex='have made', match_substring=True, name="RegExFilter3")
 
 for e in conn.batch_scan(table, cols=[["e"]], iterators=[regex1, regex2, regex3]):
-    print e
+    print(e)
 
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/examples/simple.py pyaccumulo-new/examples/simple.py
--- pyaccumulo/examples/simple.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/examples/simple.py	2017-03-15 22:31:52.214584651 +0000
@@ -27,7 +27,7 @@
 conn.create_table(table)
 wr = conn.create_batch_writer(table)
 
-print "Ingesting some data ..."
+print("Ingesting some data ...")
 for num in range(1, 100):
     label = '%03d'%num
     mut = Mutation('r_%s'%label)
@@ -37,12 +37,12 @@
 wr.close()
 
 
-print "Rows 001 through 003 ..."
+print("Rows 001 through 003 ...")
 for entry in conn.scan(table, scanrange=Range(srow='r_001', erow='r_003'), cols=[]):
-    print entry
+    print(entry)
 
-print "Rows 001 and 011 ..."
+print("Rows 001 and 011 ...")
 for entry in conn.batch_scan(table, scanranges=[Range(srow='r_001', erow='r_001'), Range(srow='r_011', erow='r_011')]):
-    print entry
+    print(entry)
 
 conn.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/__init__.py pyaccumulo-new/pyaccumulo/__init__.py
--- pyaccumulo/pyaccumulo/__init__.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/__init__.py	2017-03-15 23:32:47.887403005 +0000
@@ -26,6 +26,8 @@
 from collections import namedtuple
 from pyaccumulo.iterators import BaseIterator
 
+from array import array
+
 Cell = namedtuple("Cell", "row cf cq cv ts val")
 
 def _get_scan_columns(cols):
@@ -52,6 +54,7 @@
     :param key: the key to be followed
     :return: a key that immediately follows the input key
     """
+    #import pdb; pdb.set_trace()
     if key.timestamp is not None:
         key.timestamp -= 1
     elif key.colVisibility is not None:
@@ -94,6 +97,27 @@
         self.ets = ets
         self.einclude = einclude
 
+    @staticmethod
+    def followingPrefix(prefix):
+        """Returns a String that sorts just after all Strings beginning with a prefix"""
+        prefixBytes = array('B', prefix)
+
+        changeIndex = len(prefixBytes) - 1
+        while (changeIndex >= 0 and prefixBytes[changeIndex] == 0xff ):
+            changeIndex = changeIndex - 1;
+        if(changeIndex < 0):
+            return None
+        newBytes = array('B', prefix[0:changeIndex + 1])
+        newBytes[changeIndex] = newBytes[changeIndex] + 1
+        return newBytes.tostring()
+
+    @staticmethod
+    def prefix(rowPrefix):
+        """Returns a Range that covers all rows beginning with a prefix"""
+        fp = Range.followingPrefix(rowPrefix)
+        return Range(srow=rowPrefix, sinclude=True, erow=fp, einclude=False)
+
+
     def to_range(self):
         r = proxy.ttypes.Range()
         r.startInclusive = self.sinclude
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/iterators/__init__.py pyaccumulo-new/pyaccumulo/iterators/__init__.py
--- pyaccumulo/pyaccumulo/iterators/__init__.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/iterators/__init__.py	2017-03-15 22:32:50.690584651 +0000
@@ -15,6 +15,8 @@
 # limitations under the License.
 
 from pyaccumulo.proxy.ttypes import IteratorSetting, IteratorScope
+import base64
+
 
 class BaseIterator(object):
     """docstring for BaseIterator"""
@@ -167,11 +169,11 @@
         return props
 
     def _encode_columns(self, cols):
-        return "".join([ col.encode("base64") for col in cols ]).rstrip()
+        return "".join([ base64.b64encode(col.encode("utf-8")).decode("utf-8") for col in cols ]).rstrip()
 
     def _encode_not_flags(self, flags):
         if flags:
-            return "".join( [self._convert_flag(flag) for flag in flags]).encode("base64")
+            return base64.b64encode("".join( [self._convert_flag(flag) for flag in flags]).encode("utf-8")).decode("utf-8")
         else:
             return None
     
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/AccumuloProxy.py pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy.py
--- pyaccumulo/pyaccumulo/proxy/AccumuloProxy.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy.py	2017-03-15 22:32:50.598584651 +0000
@@ -1,80 +1,8507 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TException, TApplicationException
-from ttypes import *
+from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+from thrift.protocol.TProtocol import TProtocolException
+import sys
+import logging
+from .ttypes import *
 from thrift.Thrift import TProcessor
 from thrift.transport import TTransport
-from thrift.protocol import TBinaryProtocol, TProtocol
-try:
-  from thrift.protocol import fastbinary
-except:
-  fastbinary = None
 
 
-class Iface:
-  def login(self, principal, loginProperties):
+class Iface(object):
+    def login(self, principal, loginProperties):
+        """
+        Parameters:
+         - principal
+         - loginProperties
+        """
+        pass
+
+    def addConstraint(self, login, tableName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraintClassName
+        """
+        pass
+
+    def addSplits(self, login, tableName, splits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - splits
+        """
+        pass
+
+    def attachIterator(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        pass
+
+    def checkIteratorConflicts(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        pass
+
+    def clearLocatorCache(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+        """
+        Parameters:
+         - login
+         - tableName
+         - newTableName
+         - flush
+         - propertiesToSet
+         - propertiesToExclude
+        """
+        pass
+
+    def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - iterators
+         - flush
+         - wait
+         - compactionStrategy
+        """
+        pass
+
+    def cancelCompaction(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def createTable(self, login, tableName, versioningIter, type):
+        """
+        Parameters:
+         - login
+         - tableName
+         - versioningIter
+         - type
+        """
+        pass
+
+    def deleteTable(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def deleteRows(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        pass
+
+    def exportTable(self, login, tableName, exportDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - exportDir
+        """
+        pass
+
+    def flushTable(self, login, tableName, startRow, endRow, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - wait
+        """
+        pass
+
+    def getDiskUsage(self, login, tables):
+        """
+        Parameters:
+         - login
+         - tables
+        """
+        pass
+
+    def getLocalityGroups(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def getIteratorSetting(self, login, tableName, iteratorName, scope):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iteratorName
+         - scope
+        """
+        pass
+
+    def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+        """
+        Parameters:
+         - login
+         - tableName
+         - auths
+         - startRow
+         - startInclusive
+         - endRow
+         - endInclusive
+        """
+        pass
+
+    def getTableProperties(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def importDirectory(self, login, tableName, importDir, failureDir, setTime):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+         - failureDir
+         - setTime
+        """
+        pass
+
+    def importTable(self, login, tableName, importDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+        """
+        pass
+
+    def listSplits(self, login, tableName, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - maxSplits
+        """
+        pass
+
+    def listTables(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def listIterators(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def listConstraints(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def mergeTablets(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        pass
+
+    def offlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        pass
+
+    def onlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        pass
+
+    def removeConstraint(self, login, tableName, constraint):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraint
+        """
+        pass
+
+    def removeIterator(self, login, tableName, iterName, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iterName
+         - scopes
+        """
+        pass
+
+    def removeTableProperty(self, login, tableName, property):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+        """
+        pass
+
+    def renameTable(self, login, oldTableName, newTableName):
+        """
+        Parameters:
+         - login
+         - oldTableName
+         - newTableName
+        """
+        pass
+
+    def setLocalityGroups(self, login, tableName, groups):
+        """
+        Parameters:
+         - login
+         - tableName
+         - groups
+        """
+        pass
+
+    def setTableProperty(self, login, tableName, property, value):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+         - value
+        """
+        pass
+
+    def splitRangeByTablets(self, login, tableName, range, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - range
+         - maxSplits
+        """
+        pass
+
+    def tableExists(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        pass
+
+    def tableIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def testTableClassLoad(self, login, tableName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - className
+         - asTypeName
+        """
+        pass
+
+    def pingTabletServer(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        pass
+
+    def getActiveScans(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        pass
+
+    def getActiveCompactions(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        pass
+
+    def getSiteConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def getSystemConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def getTabletServers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def removeProperty(self, login, property):
+        """
+        Parameters:
+         - login
+         - property
+        """
+        pass
+
+    def setProperty(self, login, property, value):
+        """
+        Parameters:
+         - login
+         - property
+         - value
+        """
+        pass
+
+    def testClassLoad(self, login, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - className
+         - asTypeName
+        """
+        pass
+
+    def authenticateUser(self, login, user, properties):
+        """
+        Parameters:
+         - login
+         - user
+         - properties
+        """
+        pass
+
+    def changeUserAuthorizations(self, login, user, authorizations):
+        """
+        Parameters:
+         - login
+         - user
+         - authorizations
+        """
+        pass
+
+    def changeLocalUserPassword(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        pass
+
+    def createLocalUser(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        pass
+
+    def dropLocalUser(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        pass
+
+    def getUserAuthorizations(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        pass
+
+    def grantSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        pass
+
+    def grantTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        pass
+
+    def hasSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        pass
+
+    def hasTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        pass
+
+    def listLocalUsers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def revokeSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        pass
+
+    def revokeTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        pass
+
+    def grantNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        pass
+
+    def hasNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        pass
+
+    def revokeNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        pass
+
+    def createBatchScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        pass
+
+    def createScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        pass
+
+    def hasNext(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        pass
+
+    def nextEntry(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        pass
+
+    def nextK(self, scanner, k):
+        """
+        Parameters:
+         - scanner
+         - k
+        """
+        pass
+
+    def closeScanner(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        pass
+
+    def updateAndFlush(self, login, tableName, cells):
+        """
+        Parameters:
+         - login
+         - tableName
+         - cells
+        """
+        pass
+
+    def createWriter(self, login, tableName, opts):
+        """
+        Parameters:
+         - login
+         - tableName
+         - opts
+        """
+        pass
+
+    def update(self, writer, cells):
+        """
+        Parameters:
+         - writer
+         - cells
+        """
+        pass
+
+    def flush(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        pass
+
+    def closeWriter(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        pass
+
+    def updateRowConditionally(self, login, tableName, row, updates):
+        """
+        Parameters:
+         - login
+         - tableName
+         - row
+         - updates
+        """
+        pass
+
+    def createConditionalWriter(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        pass
+
+    def updateRowsConditionally(self, conditionalWriter, updates):
+        """
+        Parameters:
+         - conditionalWriter
+         - updates
+        """
+        pass
+
+    def closeConditionalWriter(self, conditionalWriter):
+        """
+        Parameters:
+         - conditionalWriter
+        """
+        pass
+
+    def getRowRange(self, row):
+        """
+        Parameters:
+         - row
+        """
+        pass
+
+    def getFollowing(self, key, part):
+        """
+        Parameters:
+         - key
+         - part
+        """
+        pass
+
+    def systemNamespace(self):
+        pass
+
+    def defaultNamespace(self):
+        pass
+
+    def listNamespaces(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def namespaceExists(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def createNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def deleteNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def renameNamespace(self, login, oldNamespaceName, newNamespaceName):
+        """
+        Parameters:
+         - login
+         - oldNamespaceName
+         - newNamespaceName
+        """
+        pass
+
+    def setNamespaceProperty(self, login, namespaceName, property, value):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+         - value
+        """
+        pass
+
+    def removeNamespaceProperty(self, login, namespaceName, property):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+        """
+        pass
+
+    def getNamespaceProperties(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def namespaceIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        pass
+
+    def attachNamespaceIterator(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        pass
+
+    def removeNamespaceIterator(self, login, namespaceName, name, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scopes
+        """
+        pass
+
+    def getNamespaceIteratorSetting(self, login, namespaceName, name, scope):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scope
+        """
+        pass
+
+    def listNamespaceIterators(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def checkNamespaceIteratorConflicts(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        pass
+
+    def addNamespaceConstraint(self, login, namespaceName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - constraintClassName
+        """
+        pass
+
+    def removeNamespaceConstraint(self, login, namespaceName, id):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - id
+        """
+        pass
+
+    def listNamespaceConstraints(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        pass
+
+    def testNamespaceClassLoad(self, login, namespaceName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - className
+         - asTypeName
+        """
+        pass
+
+
+class Client(Iface):
+    def __init__(self, iprot, oprot=None):
+        self._iprot = self._oprot = iprot
+        if oprot is not None:
+            self._oprot = oprot
+        self._seqid = 0
+
+    def login(self, principal, loginProperties):
+        """
+        Parameters:
+         - principal
+         - loginProperties
+        """
+        self.send_login(principal, loginProperties)
+        return self.recv_login()
+
+    def send_login(self, principal, loginProperties):
+        self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
+        args = login_args()
+        args.principal = principal
+        args.loginProperties = loginProperties
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_login(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = login_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result")
+
+    def addConstraint(self, login, tableName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraintClassName
+        """
+        self.send_addConstraint(login, tableName, constraintClassName)
+        return self.recv_addConstraint()
+
+    def send_addConstraint(self, login, tableName, constraintClassName):
+        self._oprot.writeMessageBegin('addConstraint', TMessageType.CALL, self._seqid)
+        args = addConstraint_args()
+        args.login = login
+        args.tableName = tableName
+        args.constraintClassName = constraintClassName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_addConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = addConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "addConstraint failed: unknown result")
+
+    def addSplits(self, login, tableName, splits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - splits
+        """
+        self.send_addSplits(login, tableName, splits)
+        self.recv_addSplits()
+
+    def send_addSplits(self, login, tableName, splits):
+        self._oprot.writeMessageBegin('addSplits', TMessageType.CALL, self._seqid)
+        args = addSplits_args()
+        args.login = login
+        args.tableName = tableName
+        args.splits = splits
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_addSplits(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = addSplits_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def attachIterator(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        self.send_attachIterator(login, tableName, setting, scopes)
+        self.recv_attachIterator()
+
+    def send_attachIterator(self, login, tableName, setting, scopes):
+        self._oprot.writeMessageBegin('attachIterator', TMessageType.CALL, self._seqid)
+        args = attachIterator_args()
+        args.login = login
+        args.tableName = tableName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_attachIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = attachIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def checkIteratorConflicts(self, login, tableName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - setting
+         - scopes
+        """
+        self.send_checkIteratorConflicts(login, tableName, setting, scopes)
+        self.recv_checkIteratorConflicts()
+
+    def send_checkIteratorConflicts(self, login, tableName, setting, scopes):
+        self._oprot.writeMessageBegin('checkIteratorConflicts', TMessageType.CALL, self._seqid)
+        args = checkIteratorConflicts_args()
+        args.login = login
+        args.tableName = tableName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_checkIteratorConflicts(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = checkIteratorConflicts_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def clearLocatorCache(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_clearLocatorCache(login, tableName)
+        self.recv_clearLocatorCache()
+
+    def send_clearLocatorCache(self, login, tableName):
+        self._oprot.writeMessageBegin('clearLocatorCache', TMessageType.CALL, self._seqid)
+        args = clearLocatorCache_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_clearLocatorCache(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = clearLocatorCache_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        return
+
+    def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+        """
+        Parameters:
+         - login
+         - tableName
+         - newTableName
+         - flush
+         - propertiesToSet
+         - propertiesToExclude
+        """
+        self.send_cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude)
+        self.recv_cloneTable()
+
+    def send_cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+        self._oprot.writeMessageBegin('cloneTable', TMessageType.CALL, self._seqid)
+        args = cloneTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.newTableName = newTableName
+        args.flush = flush
+        args.propertiesToSet = propertiesToSet
+        args.propertiesToExclude = propertiesToExclude
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_cloneTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = cloneTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - iterators
+         - flush
+         - wait
+         - compactionStrategy
+        """
+        self.send_compactTable(login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy)
+        self.recv_compactTable()
+
+    def send_compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait, compactionStrategy):
+        self._oprot.writeMessageBegin('compactTable', TMessageType.CALL, self._seqid)
+        args = compactTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.iterators = iterators
+        args.flush = flush
+        args.wait = wait
+        args.compactionStrategy = compactionStrategy
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_compactTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = compactTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def cancelCompaction(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_cancelCompaction(login, tableName)
+        self.recv_cancelCompaction()
+
+    def send_cancelCompaction(self, login, tableName):
+        self._oprot.writeMessageBegin('cancelCompaction', TMessageType.CALL, self._seqid)
+        args = cancelCompaction_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_cancelCompaction(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = cancelCompaction_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def createTable(self, login, tableName, versioningIter, type):
+        """
+        Parameters:
+         - login
+         - tableName
+         - versioningIter
+         - type
+        """
+        self.send_createTable(login, tableName, versioningIter, type)
+        self.recv_createTable()
+
+    def send_createTable(self, login, tableName, versioningIter, type):
+        self._oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
+        args = createTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.versioningIter = versioningIter
+        args.type = type
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def deleteTable(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_deleteTable(login, tableName)
+        self.recv_deleteTable()
+
+    def send_deleteTable(self, login, tableName):
+        self._oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
+        args = deleteTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_deleteTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = deleteTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def deleteRows(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        self.send_deleteRows(login, tableName, startRow, endRow)
+        self.recv_deleteRows()
+
+    def send_deleteRows(self, login, tableName, startRow, endRow):
+        self._oprot.writeMessageBegin('deleteRows', TMessageType.CALL, self._seqid)
+        args = deleteRows_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_deleteRows(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = deleteRows_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def exportTable(self, login, tableName, exportDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - exportDir
+        """
+        self.send_exportTable(login, tableName, exportDir)
+        self.recv_exportTable()
+
+    def send_exportTable(self, login, tableName, exportDir):
+        self._oprot.writeMessageBegin('exportTable', TMessageType.CALL, self._seqid)
+        args = exportTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.exportDir = exportDir
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_exportTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = exportTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def flushTable(self, login, tableName, startRow, endRow, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+         - wait
+        """
+        self.send_flushTable(login, tableName, startRow, endRow, wait)
+        self.recv_flushTable()
+
+    def send_flushTable(self, login, tableName, startRow, endRow, wait):
+        self._oprot.writeMessageBegin('flushTable', TMessageType.CALL, self._seqid)
+        args = flushTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.wait = wait
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_flushTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = flushTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def getDiskUsage(self, login, tables):
+        """
+        Parameters:
+         - login
+         - tables
+        """
+        self.send_getDiskUsage(login, tables)
+        return self.recv_getDiskUsage()
+
+    def send_getDiskUsage(self, login, tables):
+        self._oprot.writeMessageBegin('getDiskUsage', TMessageType.CALL, self._seqid)
+        args = getDiskUsage_args()
+        args.login = login
+        args.tables = tables
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getDiskUsage(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getDiskUsage_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getDiskUsage failed: unknown result")
+
+    def getLocalityGroups(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_getLocalityGroups(login, tableName)
+        return self.recv_getLocalityGroups()
+
+    def send_getLocalityGroups(self, login, tableName):
+        self._oprot.writeMessageBegin('getLocalityGroups', TMessageType.CALL, self._seqid)
+        args = getLocalityGroups_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getLocalityGroups(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getLocalityGroups_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLocalityGroups failed: unknown result")
+
+    def getIteratorSetting(self, login, tableName, iteratorName, scope):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iteratorName
+         - scope
+        """
+        self.send_getIteratorSetting(login, tableName, iteratorName, scope)
+        return self.recv_getIteratorSetting()
+
+    def send_getIteratorSetting(self, login, tableName, iteratorName, scope):
+        self._oprot.writeMessageBegin('getIteratorSetting', TMessageType.CALL, self._seqid)
+        args = getIteratorSetting_args()
+        args.login = login
+        args.tableName = tableName
+        args.iteratorName = iteratorName
+        args.scope = scope
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getIteratorSetting(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getIteratorSetting_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getIteratorSetting failed: unknown result")
+
+    def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+        """
+        Parameters:
+         - login
+         - tableName
+         - auths
+         - startRow
+         - startInclusive
+         - endRow
+         - endInclusive
+        """
+        self.send_getMaxRow(login, tableName, auths, startRow, startInclusive, endRow, endInclusive)
+        return self.recv_getMaxRow()
+
+    def send_getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+        self._oprot.writeMessageBegin('getMaxRow', TMessageType.CALL, self._seqid)
+        args = getMaxRow_args()
+        args.login = login
+        args.tableName = tableName
+        args.auths = auths
+        args.startRow = startRow
+        args.startInclusive = startInclusive
+        args.endRow = endRow
+        args.endInclusive = endInclusive
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getMaxRow(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getMaxRow_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMaxRow failed: unknown result")
+
+    def getTableProperties(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_getTableProperties(login, tableName)
+        return self.recv_getTableProperties()
+
+    def send_getTableProperties(self, login, tableName):
+        self._oprot.writeMessageBegin('getTableProperties', TMessageType.CALL, self._seqid)
+        args = getTableProperties_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getTableProperties(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getTableProperties_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableProperties failed: unknown result")
+
+    def importDirectory(self, login, tableName, importDir, failureDir, setTime):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+         - failureDir
+         - setTime
+        """
+        self.send_importDirectory(login, tableName, importDir, failureDir, setTime)
+        self.recv_importDirectory()
+
+    def send_importDirectory(self, login, tableName, importDir, failureDir, setTime):
+        self._oprot.writeMessageBegin('importDirectory', TMessageType.CALL, self._seqid)
+        args = importDirectory_args()
+        args.login = login
+        args.tableName = tableName
+        args.importDir = importDir
+        args.failureDir = failureDir
+        args.setTime = setTime
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_importDirectory(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = importDirectory_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def importTable(self, login, tableName, importDir):
+        """
+        Parameters:
+         - login
+         - tableName
+         - importDir
+        """
+        self.send_importTable(login, tableName, importDir)
+        self.recv_importTable()
+
+    def send_importTable(self, login, tableName, importDir):
+        self._oprot.writeMessageBegin('importTable', TMessageType.CALL, self._seqid)
+        args = importTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.importDir = importDir
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_importTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = importTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def listSplits(self, login, tableName, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - maxSplits
+        """
+        self.send_listSplits(login, tableName, maxSplits)
+        return self.recv_listSplits()
+
+    def send_listSplits(self, login, tableName, maxSplits):
+        self._oprot.writeMessageBegin('listSplits', TMessageType.CALL, self._seqid)
+        args = listSplits_args()
+        args.login = login
+        args.tableName = tableName
+        args.maxSplits = maxSplits
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listSplits(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listSplits_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listSplits failed: unknown result")
+
+    def listTables(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_listTables(login)
+        return self.recv_listTables()
+
+    def send_listTables(self, login):
+        self._oprot.writeMessageBegin('listTables', TMessageType.CALL, self._seqid)
+        args = listTables_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listTables(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listTables_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result")
+
+    def listIterators(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_listIterators(login, tableName)
+        return self.recv_listIterators()
+
+    def send_listIterators(self, login, tableName):
+        self._oprot.writeMessageBegin('listIterators', TMessageType.CALL, self._seqid)
+        args = listIterators_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listIterators(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listIterators_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listIterators failed: unknown result")
+
+    def listConstraints(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_listConstraints(login, tableName)
+        return self.recv_listConstraints()
+
+    def send_listConstraints(self, login, tableName):
+        self._oprot.writeMessageBegin('listConstraints', TMessageType.CALL, self._seqid)
+        args = listConstraints_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listConstraints(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listConstraints_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listConstraints failed: unknown result")
+
+    def mergeTablets(self, login, tableName, startRow, endRow):
+        """
+        Parameters:
+         - login
+         - tableName
+         - startRow
+         - endRow
+        """
+        self.send_mergeTablets(login, tableName, startRow, endRow)
+        self.recv_mergeTablets()
+
+    def send_mergeTablets(self, login, tableName, startRow, endRow):
+        self._oprot.writeMessageBegin('mergeTablets', TMessageType.CALL, self._seqid)
+        args = mergeTablets_args()
+        args.login = login
+        args.tableName = tableName
+        args.startRow = startRow
+        args.endRow = endRow
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_mergeTablets(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = mergeTablets_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def offlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        self.send_offlineTable(login, tableName, wait)
+        self.recv_offlineTable()
+
+    def send_offlineTable(self, login, tableName, wait):
+        self._oprot.writeMessageBegin('offlineTable', TMessageType.CALL, self._seqid)
+        args = offlineTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.wait = wait
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_offlineTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = offlineTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def onlineTable(self, login, tableName, wait):
+        """
+        Parameters:
+         - login
+         - tableName
+         - wait
+        """
+        self.send_onlineTable(login, tableName, wait)
+        self.recv_onlineTable()
+
+    def send_onlineTable(self, login, tableName, wait):
+        self._oprot.writeMessageBegin('onlineTable', TMessageType.CALL, self._seqid)
+        args = onlineTable_args()
+        args.login = login
+        args.tableName = tableName
+        args.wait = wait
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_onlineTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = onlineTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeConstraint(self, login, tableName, constraint):
+        """
+        Parameters:
+         - login
+         - tableName
+         - constraint
+        """
+        self.send_removeConstraint(login, tableName, constraint)
+        self.recv_removeConstraint()
+
+    def send_removeConstraint(self, login, tableName, constraint):
+        self._oprot.writeMessageBegin('removeConstraint', TMessageType.CALL, self._seqid)
+        args = removeConstraint_args()
+        args.login = login
+        args.tableName = tableName
+        args.constraint = constraint
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeIterator(self, login, tableName, iterName, scopes):
+        """
+        Parameters:
+         - login
+         - tableName
+         - iterName
+         - scopes
+        """
+        self.send_removeIterator(login, tableName, iterName, scopes)
+        self.recv_removeIterator()
+
+    def send_removeIterator(self, login, tableName, iterName, scopes):
+        self._oprot.writeMessageBegin('removeIterator', TMessageType.CALL, self._seqid)
+        args = removeIterator_args()
+        args.login = login
+        args.tableName = tableName
+        args.iterName = iterName
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeTableProperty(self, login, tableName, property):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+        """
+        self.send_removeTableProperty(login, tableName, property)
+        self.recv_removeTableProperty()
+
+    def send_removeTableProperty(self, login, tableName, property):
+        self._oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
+        args = removeTableProperty_args()
+        args.login = login
+        args.tableName = tableName
+        args.property = property
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeTableProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeTableProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def renameTable(self, login, oldTableName, newTableName):
+        """
+        Parameters:
+         - login
+         - oldTableName
+         - newTableName
+        """
+        self.send_renameTable(login, oldTableName, newTableName)
+        self.recv_renameTable()
+
+    def send_renameTable(self, login, oldTableName, newTableName):
+        self._oprot.writeMessageBegin('renameTable', TMessageType.CALL, self._seqid)
+        args = renameTable_args()
+        args.login = login
+        args.oldTableName = oldTableName
+        args.newTableName = newTableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_renameTable(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = renameTable_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def setLocalityGroups(self, login, tableName, groups):
+        """
+        Parameters:
+         - login
+         - tableName
+         - groups
+        """
+        self.send_setLocalityGroups(login, tableName, groups)
+        self.recv_setLocalityGroups()
+
+    def send_setLocalityGroups(self, login, tableName, groups):
+        self._oprot.writeMessageBegin('setLocalityGroups', TMessageType.CALL, self._seqid)
+        args = setLocalityGroups_args()
+        args.login = login
+        args.tableName = tableName
+        args.groups = groups
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setLocalityGroups(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setLocalityGroups_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def setTableProperty(self, login, tableName, property, value):
+        """
+        Parameters:
+         - login
+         - tableName
+         - property
+         - value
+        """
+        self.send_setTableProperty(login, tableName, property, value)
+        self.recv_setTableProperty()
+
+    def send_setTableProperty(self, login, tableName, property, value):
+        self._oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
+        args = setTableProperty_args()
+        args.login = login
+        args.tableName = tableName
+        args.property = property
+        args.value = value
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setTableProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setTableProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def splitRangeByTablets(self, login, tableName, range, maxSplits):
+        """
+        Parameters:
+         - login
+         - tableName
+         - range
+         - maxSplits
+        """
+        self.send_splitRangeByTablets(login, tableName, range, maxSplits)
+        return self.recv_splitRangeByTablets()
+
+    def send_splitRangeByTablets(self, login, tableName, range, maxSplits):
+        self._oprot.writeMessageBegin('splitRangeByTablets', TMessageType.CALL, self._seqid)
+        args = splitRangeByTablets_args()
+        args.login = login
+        args.tableName = tableName
+        args.range = range
+        args.maxSplits = maxSplits
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_splitRangeByTablets(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = splitRangeByTablets_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "splitRangeByTablets failed: unknown result")
+
+    def tableExists(self, login, tableName):
+        """
+        Parameters:
+         - login
+         - tableName
+        """
+        self.send_tableExists(login, tableName)
+        return self.recv_tableExists()
+
+    def send_tableExists(self, login, tableName):
+        self._oprot.writeMessageBegin('tableExists', TMessageType.CALL, self._seqid)
+        args = tableExists_args()
+        args.login = login
+        args.tableName = tableName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_tableExists(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = tableExists_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableExists failed: unknown result")
+
+    def tableIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_tableIdMap(login)
+        return self.recv_tableIdMap()
+
+    def send_tableIdMap(self, login):
+        self._oprot.writeMessageBegin('tableIdMap', TMessageType.CALL, self._seqid)
+        args = tableIdMap_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_tableIdMap(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = tableIdMap_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIdMap failed: unknown result")
+
+    def testTableClassLoad(self, login, tableName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - tableName
+         - className
+         - asTypeName
+        """
+        self.send_testTableClassLoad(login, tableName, className, asTypeName)
+        return self.recv_testTableClassLoad()
+
+    def send_testTableClassLoad(self, login, tableName, className, asTypeName):
+        self._oprot.writeMessageBegin('testTableClassLoad', TMessageType.CALL, self._seqid)
+        args = testTableClassLoad_args()
+        args.login = login
+        args.tableName = tableName
+        args.className = className
+        args.asTypeName = asTypeName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_testTableClassLoad(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = testTableClassLoad_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "testTableClassLoad failed: unknown result")
+
+    def pingTabletServer(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        self.send_pingTabletServer(login, tserver)
+        self.recv_pingTabletServer()
+
+    def send_pingTabletServer(self, login, tserver):
+        self._oprot.writeMessageBegin('pingTabletServer', TMessageType.CALL, self._seqid)
+        args = pingTabletServer_args()
+        args.login = login
+        args.tserver = tserver
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_pingTabletServer(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = pingTabletServer_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def getActiveScans(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        self.send_getActiveScans(login, tserver)
+        return self.recv_getActiveScans()
+
+    def send_getActiveScans(self, login, tserver):
+        self._oprot.writeMessageBegin('getActiveScans', TMessageType.CALL, self._seqid)
+        args = getActiveScans_args()
+        args.login = login
+        args.tserver = tserver
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getActiveScans(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getActiveScans_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveScans failed: unknown result")
+
+    def getActiveCompactions(self, login, tserver):
+        """
+        Parameters:
+         - login
+         - tserver
+        """
+        self.send_getActiveCompactions(login, tserver)
+        return self.recv_getActiveCompactions()
+
+    def send_getActiveCompactions(self, login, tserver):
+        self._oprot.writeMessageBegin('getActiveCompactions', TMessageType.CALL, self._seqid)
+        args = getActiveCompactions_args()
+        args.login = login
+        args.tserver = tserver
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getActiveCompactions(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getActiveCompactions_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveCompactions failed: unknown result")
+
+    def getSiteConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_getSiteConfiguration(login)
+        return self.recv_getSiteConfiguration()
+
+    def send_getSiteConfiguration(self, login):
+        self._oprot.writeMessageBegin('getSiteConfiguration', TMessageType.CALL, self._seqid)
+        args = getSiteConfiguration_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getSiteConfiguration(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getSiteConfiguration_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSiteConfiguration failed: unknown result")
+
+    def getSystemConfiguration(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_getSystemConfiguration(login)
+        return self.recv_getSystemConfiguration()
+
+    def send_getSystemConfiguration(self, login):
+        self._oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
+        args = getSystemConfiguration_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getSystemConfiguration(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getSystemConfiguration_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getSystemConfiguration failed: unknown result")
+
+    def getTabletServers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_getTabletServers(login)
+        return self.recv_getTabletServers()
+
+    def send_getTabletServers(self, login):
+        self._oprot.writeMessageBegin('getTabletServers', TMessageType.CALL, self._seqid)
+        args = getTabletServers_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getTabletServers(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getTabletServers_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getTabletServers failed: unknown result")
+
+    def removeProperty(self, login, property):
+        """
+        Parameters:
+         - login
+         - property
+        """
+        self.send_removeProperty(login, property)
+        self.recv_removeProperty()
+
+    def send_removeProperty(self, login, property):
+        self._oprot.writeMessageBegin('removeProperty', TMessageType.CALL, self._seqid)
+        args = removeProperty_args()
+        args.login = login
+        args.property = property
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def setProperty(self, login, property, value):
+        """
+        Parameters:
+         - login
+         - property
+         - value
+        """
+        self.send_setProperty(login, property, value)
+        self.recv_setProperty()
+
+    def send_setProperty(self, login, property, value):
+        self._oprot.writeMessageBegin('setProperty', TMessageType.CALL, self._seqid)
+        args = setProperty_args()
+        args.login = login
+        args.property = property
+        args.value = value
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def testClassLoad(self, login, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - className
+         - asTypeName
+        """
+        self.send_testClassLoad(login, className, asTypeName)
+        return self.recv_testClassLoad()
+
+    def send_testClassLoad(self, login, className, asTypeName):
+        self._oprot.writeMessageBegin('testClassLoad', TMessageType.CALL, self._seqid)
+        args = testClassLoad_args()
+        args.login = login
+        args.className = className
+        args.asTypeName = asTypeName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_testClassLoad(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = testClassLoad_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "testClassLoad failed: unknown result")
+
+    def authenticateUser(self, login, user, properties):
+        """
+        Parameters:
+         - login
+         - user
+         - properties
+        """
+        self.send_authenticateUser(login, user, properties)
+        return self.recv_authenticateUser()
+
+    def send_authenticateUser(self, login, user, properties):
+        self._oprot.writeMessageBegin('authenticateUser', TMessageType.CALL, self._seqid)
+        args = authenticateUser_args()
+        args.login = login
+        args.user = user
+        args.properties = properties
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_authenticateUser(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = authenticateUser_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateUser failed: unknown result")
+
+    def changeUserAuthorizations(self, login, user, authorizations):
+        """
+        Parameters:
+         - login
+         - user
+         - authorizations
+        """
+        self.send_changeUserAuthorizations(login, user, authorizations)
+        self.recv_changeUserAuthorizations()
+
+    def send_changeUserAuthorizations(self, login, user, authorizations):
+        self._oprot.writeMessageBegin('changeUserAuthorizations', TMessageType.CALL, self._seqid)
+        args = changeUserAuthorizations_args()
+        args.login = login
+        args.user = user
+        args.authorizations = authorizations
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_changeUserAuthorizations(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = changeUserAuthorizations_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def changeLocalUserPassword(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        self.send_changeLocalUserPassword(login, user, password)
+        self.recv_changeLocalUserPassword()
+
+    def send_changeLocalUserPassword(self, login, user, password):
+        self._oprot.writeMessageBegin('changeLocalUserPassword', TMessageType.CALL, self._seqid)
+        args = changeLocalUserPassword_args()
+        args.login = login
+        args.user = user
+        args.password = password
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_changeLocalUserPassword(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = changeLocalUserPassword_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def createLocalUser(self, login, user, password):
+        """
+        Parameters:
+         - login
+         - user
+         - password
+        """
+        self.send_createLocalUser(login, user, password)
+        self.recv_createLocalUser()
+
+    def send_createLocalUser(self, login, user, password):
+        self._oprot.writeMessageBegin('createLocalUser', TMessageType.CALL, self._seqid)
+        args = createLocalUser_args()
+        args.login = login
+        args.user = user
+        args.password = password
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createLocalUser(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createLocalUser_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def dropLocalUser(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        self.send_dropLocalUser(login, user)
+        self.recv_dropLocalUser()
+
+    def send_dropLocalUser(self, login, user):
+        self._oprot.writeMessageBegin('dropLocalUser', TMessageType.CALL, self._seqid)
+        args = dropLocalUser_args()
+        args.login = login
+        args.user = user
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_dropLocalUser(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = dropLocalUser_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def getUserAuthorizations(self, login, user):
+        """
+        Parameters:
+         - login
+         - user
+        """
+        self.send_getUserAuthorizations(login, user)
+        return self.recv_getUserAuthorizations()
+
+    def send_getUserAuthorizations(self, login, user):
+        self._oprot.writeMessageBegin('getUserAuthorizations', TMessageType.CALL, self._seqid)
+        args = getUserAuthorizations_args()
+        args.login = login
+        args.user = user
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getUserAuthorizations(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getUserAuthorizations_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserAuthorizations failed: unknown result")
+
+    def grantSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        self.send_grantSystemPermission(login, user, perm)
+        self.recv_grantSystemPermission()
+
+    def send_grantSystemPermission(self, login, user, perm):
+        self._oprot.writeMessageBegin('grantSystemPermission', TMessageType.CALL, self._seqid)
+        args = grantSystemPermission_args()
+        args.login = login
+        args.user = user
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_grantSystemPermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = grantSystemPermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def grantTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        self.send_grantTablePermission(login, user, table, perm)
+        self.recv_grantTablePermission()
+
+    def send_grantTablePermission(self, login, user, table, perm):
+        self._oprot.writeMessageBegin('grantTablePermission', TMessageType.CALL, self._seqid)
+        args = grantTablePermission_args()
+        args.login = login
+        args.user = user
+        args.table = table
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_grantTablePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = grantTablePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def hasSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        self.send_hasSystemPermission(login, user, perm)
+        return self.recv_hasSystemPermission()
+
+    def send_hasSystemPermission(self, login, user, perm):
+        self._oprot.writeMessageBegin('hasSystemPermission', TMessageType.CALL, self._seqid)
+        args = hasSystemPermission_args()
+        args.login = login
+        args.user = user
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasSystemPermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasSystemPermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasSystemPermission failed: unknown result")
+
+    def hasTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        self.send_hasTablePermission(login, user, table, perm)
+        return self.recv_hasTablePermission()
+
+    def send_hasTablePermission(self, login, user, table, perm):
+        self._oprot.writeMessageBegin('hasTablePermission', TMessageType.CALL, self._seqid)
+        args = hasTablePermission_args()
+        args.login = login
+        args.user = user
+        args.table = table
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasTablePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasTablePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasTablePermission failed: unknown result")
+
+    def listLocalUsers(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_listLocalUsers(login)
+        return self.recv_listLocalUsers()
+
+    def send_listLocalUsers(self, login):
+        self._oprot.writeMessageBegin('listLocalUsers', TMessageType.CALL, self._seqid)
+        args = listLocalUsers_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listLocalUsers(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listLocalUsers_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listLocalUsers failed: unknown result")
+
+    def revokeSystemPermission(self, login, user, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - perm
+        """
+        self.send_revokeSystemPermission(login, user, perm)
+        self.recv_revokeSystemPermission()
+
+    def send_revokeSystemPermission(self, login, user, perm):
+        self._oprot.writeMessageBegin('revokeSystemPermission', TMessageType.CALL, self._seqid)
+        args = revokeSystemPermission_args()
+        args.login = login
+        args.user = user
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_revokeSystemPermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = revokeSystemPermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def revokeTablePermission(self, login, user, table, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - table
+         - perm
+        """
+        self.send_revokeTablePermission(login, user, table, perm)
+        self.recv_revokeTablePermission()
+
+    def send_revokeTablePermission(self, login, user, table, perm):
+        self._oprot.writeMessageBegin('revokeTablePermission', TMessageType.CALL, self._seqid)
+        args = revokeTablePermission_args()
+        args.login = login
+        args.user = user
+        args.table = table
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_revokeTablePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = revokeTablePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def grantNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        self.send_grantNamespacePermission(login, user, namespaceName, perm)
+        self.recv_grantNamespacePermission()
+
+    def send_grantNamespacePermission(self, login, user, namespaceName, perm):
+        self._oprot.writeMessageBegin('grantNamespacePermission', TMessageType.CALL, self._seqid)
+        args = grantNamespacePermission_args()
+        args.login = login
+        args.user = user
+        args.namespaceName = namespaceName
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_grantNamespacePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = grantNamespacePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def hasNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        self.send_hasNamespacePermission(login, user, namespaceName, perm)
+        return self.recv_hasNamespacePermission()
+
+    def send_hasNamespacePermission(self, login, user, namespaceName, perm):
+        self._oprot.writeMessageBegin('hasNamespacePermission', TMessageType.CALL, self._seqid)
+        args = hasNamespacePermission_args()
+        args.login = login
+        args.user = user
+        args.namespaceName = namespaceName
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasNamespacePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasNamespacePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNamespacePermission failed: unknown result")
+
+    def revokeNamespacePermission(self, login, user, namespaceName, perm):
+        """
+        Parameters:
+         - login
+         - user
+         - namespaceName
+         - perm
+        """
+        self.send_revokeNamespacePermission(login, user, namespaceName, perm)
+        self.recv_revokeNamespacePermission()
+
+    def send_revokeNamespacePermission(self, login, user, namespaceName, perm):
+        self._oprot.writeMessageBegin('revokeNamespacePermission', TMessageType.CALL, self._seqid)
+        args = revokeNamespacePermission_args()
+        args.login = login
+        args.user = user
+        args.namespaceName = namespaceName
+        args.perm = perm
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_revokeNamespacePermission(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = revokeNamespacePermission_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def createBatchScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        self.send_createBatchScanner(login, tableName, options)
+        return self.recv_createBatchScanner()
+
+    def send_createBatchScanner(self, login, tableName, options):
+        self._oprot.writeMessageBegin('createBatchScanner', TMessageType.CALL, self._seqid)
+        args = createBatchScanner_args()
+        args.login = login
+        args.tableName = tableName
+        args.options = options
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createBatchScanner(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createBatchScanner_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createBatchScanner failed: unknown result")
+
+    def createScanner(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        self.send_createScanner(login, tableName, options)
+        return self.recv_createScanner()
+
+    def send_createScanner(self, login, tableName, options):
+        self._oprot.writeMessageBegin('createScanner', TMessageType.CALL, self._seqid)
+        args = createScanner_args()
+        args.login = login
+        args.tableName = tableName
+        args.options = options
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createScanner(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createScanner_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createScanner failed: unknown result")
+
+    def hasNext(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        self.send_hasNext(scanner)
+        return self.recv_hasNext()
+
+    def send_hasNext(self, scanner):
+        self._oprot.writeMessageBegin('hasNext', TMessageType.CALL, self._seqid)
+        args = hasNext_args()
+        args.scanner = scanner
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_hasNext(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = hasNext_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNext failed: unknown result")
+
+    def nextEntry(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        self.send_nextEntry(scanner)
+        return self.recv_nextEntry()
+
+    def send_nextEntry(self, scanner):
+        self._oprot.writeMessageBegin('nextEntry', TMessageType.CALL, self._seqid)
+        args = nextEntry_args()
+        args.scanner = scanner
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_nextEntry(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = nextEntry_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "nextEntry failed: unknown result")
+
+    def nextK(self, scanner, k):
+        """
+        Parameters:
+         - scanner
+         - k
+        """
+        self.send_nextK(scanner, k)
+        return self.recv_nextK()
+
+    def send_nextK(self, scanner, k):
+        self._oprot.writeMessageBegin('nextK', TMessageType.CALL, self._seqid)
+        args = nextK_args()
+        args.scanner = scanner
+        args.k = k
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_nextK(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = nextK_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "nextK failed: unknown result")
+
+    def closeScanner(self, scanner):
+        """
+        Parameters:
+         - scanner
+        """
+        self.send_closeScanner(scanner)
+        self.recv_closeScanner()
+
+    def send_closeScanner(self, scanner):
+        self._oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
+        args = closeScanner_args()
+        args.scanner = scanner
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_closeScanner(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = closeScanner_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        return
+
+    def updateAndFlush(self, login, tableName, cells):
+        """
+        Parameters:
+         - login
+         - tableName
+         - cells
+        """
+        self.send_updateAndFlush(login, tableName, cells)
+        self.recv_updateAndFlush()
+
+    def send_updateAndFlush(self, login, tableName, cells):
+        self._oprot.writeMessageBegin('updateAndFlush', TMessageType.CALL, self._seqid)
+        args = updateAndFlush_args()
+        args.login = login
+        args.tableName = tableName
+        args.cells = cells
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_updateAndFlush(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = updateAndFlush_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.outch1 is not None:
+            raise result.outch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def createWriter(self, login, tableName, opts):
+        """
+        Parameters:
+         - login
+         - tableName
+         - opts
+        """
+        self.send_createWriter(login, tableName, opts)
+        return self.recv_createWriter()
+
+    def send_createWriter(self, login, tableName, opts):
+        self._oprot.writeMessageBegin('createWriter', TMessageType.CALL, self._seqid)
+        args = createWriter_args()
+        args.login = login
+        args.tableName = tableName
+        args.opts = opts
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.outch1 is not None:
+            raise result.outch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createWriter failed: unknown result")
+
+    def update(self, writer, cells):
+        """
+        Parameters:
+         - writer
+         - cells
+        """
+        self.send_update(writer, cells)
+
+    def send_update(self, writer, cells):
+        self._oprot.writeMessageBegin('update', TMessageType.ONEWAY, self._seqid)
+        args = update_args()
+        args.writer = writer
+        args.cells = cells
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def flush(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        self.send_flush(writer)
+        self.recv_flush()
+
+    def send_flush(self, writer):
+        self._oprot.writeMessageBegin('flush', TMessageType.CALL, self._seqid)
+        args = flush_args()
+        args.writer = writer
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_flush(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = flush_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def closeWriter(self, writer):
+        """
+        Parameters:
+         - writer
+        """
+        self.send_closeWriter(writer)
+        self.recv_closeWriter()
+
+    def send_closeWriter(self, writer):
+        self._oprot.writeMessageBegin('closeWriter', TMessageType.CALL, self._seqid)
+        args = closeWriter_args()
+        args.writer = writer
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_closeWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = closeWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        return
+
+    def updateRowConditionally(self, login, tableName, row, updates):
+        """
+        Parameters:
+         - login
+         - tableName
+         - row
+         - updates
+        """
+        self.send_updateRowConditionally(login, tableName, row, updates)
+        return self.recv_updateRowConditionally()
+
+    def send_updateRowConditionally(self, login, tableName, row, updates):
+        self._oprot.writeMessageBegin('updateRowConditionally', TMessageType.CALL, self._seqid)
+        args = updateRowConditionally_args()
+        args.login = login
+        args.tableName = tableName
+        args.row = row
+        args.updates = updates
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_updateRowConditionally(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = updateRowConditionally_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRowConditionally failed: unknown result")
+
+    def createConditionalWriter(self, login, tableName, options):
+        """
+        Parameters:
+         - login
+         - tableName
+         - options
+        """
+        self.send_createConditionalWriter(login, tableName, options)
+        return self.recv_createConditionalWriter()
+
+    def send_createConditionalWriter(self, login, tableName, options):
+        self._oprot.writeMessageBegin('createConditionalWriter', TMessageType.CALL, self._seqid)
+        args = createConditionalWriter_args()
+        args.login = login
+        args.tableName = tableName
+        args.options = options
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createConditionalWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createConditionalWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "createConditionalWriter failed: unknown result")
+
+    def updateRowsConditionally(self, conditionalWriter, updates):
+        """
+        Parameters:
+         - conditionalWriter
+         - updates
+        """
+        self.send_updateRowsConditionally(conditionalWriter, updates)
+        return self.recv_updateRowsConditionally()
+
+    def send_updateRowsConditionally(self, conditionalWriter, updates):
+        self._oprot.writeMessageBegin('updateRowsConditionally', TMessageType.CALL, self._seqid)
+        args = updateRowsConditionally_args()
+        args.conditionalWriter = conditionalWriter
+        args.updates = updates
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_updateRowsConditionally(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = updateRowsConditionally_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateRowsConditionally failed: unknown result")
+
+    def closeConditionalWriter(self, conditionalWriter):
+        """
+        Parameters:
+         - conditionalWriter
+        """
+        self.send_closeConditionalWriter(conditionalWriter)
+        self.recv_closeConditionalWriter()
+
+    def send_closeConditionalWriter(self, conditionalWriter):
+        self._oprot.writeMessageBegin('closeConditionalWriter', TMessageType.CALL, self._seqid)
+        args = closeConditionalWriter_args()
+        args.conditionalWriter = conditionalWriter
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_closeConditionalWriter(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = closeConditionalWriter_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        return
+
+    def getRowRange(self, row):
+        """
+        Parameters:
+         - row
+        """
+        self.send_getRowRange(row)
+        return self.recv_getRowRange()
+
+    def send_getRowRange(self, row):
+        self._oprot.writeMessageBegin('getRowRange', TMessageType.CALL, self._seqid)
+        args = getRowRange_args()
+        args.row = row
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getRowRange(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getRowRange_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRowRange failed: unknown result")
+
+    def getFollowing(self, key, part):
+        """
+        Parameters:
+         - key
+         - part
+        """
+        self.send_getFollowing(key, part)
+        return self.recv_getFollowing()
+
+    def send_getFollowing(self, key, part):
+        self._oprot.writeMessageBegin('getFollowing', TMessageType.CALL, self._seqid)
+        args = getFollowing_args()
+        args.key = key
+        args.part = part
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getFollowing(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getFollowing_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getFollowing failed: unknown result")
+
+    def systemNamespace(self):
+        self.send_systemNamespace()
+        return self.recv_systemNamespace()
+
+    def send_systemNamespace(self):
+        self._oprot.writeMessageBegin('systemNamespace', TMessageType.CALL, self._seqid)
+        args = systemNamespace_args()
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_systemNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = systemNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "systemNamespace failed: unknown result")
+
+    def defaultNamespace(self):
+        self.send_defaultNamespace()
+        return self.recv_defaultNamespace()
+
+    def send_defaultNamespace(self):
+        self._oprot.writeMessageBegin('defaultNamespace', TMessageType.CALL, self._seqid)
+        args = defaultNamespace_args()
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_defaultNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = defaultNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "defaultNamespace failed: unknown result")
+
+    def listNamespaces(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_listNamespaces(login)
+        return self.recv_listNamespaces()
+
+    def send_listNamespaces(self, login):
+        self._oprot.writeMessageBegin('listNamespaces', TMessageType.CALL, self._seqid)
+        args = listNamespaces_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listNamespaces(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listNamespaces_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaces failed: unknown result")
+
+    def namespaceExists(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_namespaceExists(login, namespaceName)
+        return self.recv_namespaceExists()
+
+    def send_namespaceExists(self, login, namespaceName):
+        self._oprot.writeMessageBegin('namespaceExists', TMessageType.CALL, self._seqid)
+        args = namespaceExists_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_namespaceExists(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = namespaceExists_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespaceExists failed: unknown result")
+
+    def createNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_createNamespace(login, namespaceName)
+        self.recv_createNamespace()
+
+    def send_createNamespace(self, login, namespaceName):
+        self._oprot.writeMessageBegin('createNamespace', TMessageType.CALL, self._seqid)
+        args = createNamespace_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_createNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = createNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def deleteNamespace(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_deleteNamespace(login, namespaceName)
+        self.recv_deleteNamespace()
+
+    def send_deleteNamespace(self, login, namespaceName):
+        self._oprot.writeMessageBegin('deleteNamespace', TMessageType.CALL, self._seqid)
+        args = deleteNamespace_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_deleteNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = deleteNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def renameNamespace(self, login, oldNamespaceName, newNamespaceName):
+        """
+        Parameters:
+         - login
+         - oldNamespaceName
+         - newNamespaceName
+        """
+        self.send_renameNamespace(login, oldNamespaceName, newNamespaceName)
+        self.recv_renameNamespace()
+
+    def send_renameNamespace(self, login, oldNamespaceName, newNamespaceName):
+        self._oprot.writeMessageBegin('renameNamespace', TMessageType.CALL, self._seqid)
+        args = renameNamespace_args()
+        args.login = login
+        args.oldNamespaceName = oldNamespaceName
+        args.newNamespaceName = newNamespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_renameNamespace(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = renameNamespace_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        if result.ouch4 is not None:
+            raise result.ouch4
+        return
+
+    def setNamespaceProperty(self, login, namespaceName, property, value):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+         - value
+        """
+        self.send_setNamespaceProperty(login, namespaceName, property, value)
+        self.recv_setNamespaceProperty()
+
+    def send_setNamespaceProperty(self, login, namespaceName, property, value):
+        self._oprot.writeMessageBegin('setNamespaceProperty', TMessageType.CALL, self._seqid)
+        args = setNamespaceProperty_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.property = property
+        args.value = value
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_setNamespaceProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = setNamespaceProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeNamespaceProperty(self, login, namespaceName, property):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - property
+        """
+        self.send_removeNamespaceProperty(login, namespaceName, property)
+        self.recv_removeNamespaceProperty()
+
+    def send_removeNamespaceProperty(self, login, namespaceName, property):
+        self._oprot.writeMessageBegin('removeNamespaceProperty', TMessageType.CALL, self._seqid)
+        args = removeNamespaceProperty_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.property = property
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeNamespaceProperty(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeNamespaceProperty_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def getNamespaceProperties(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_getNamespaceProperties(login, namespaceName)
+        return self.recv_getNamespaceProperties()
+
+    def send_getNamespaceProperties(self, login, namespaceName):
+        self._oprot.writeMessageBegin('getNamespaceProperties', TMessageType.CALL, self._seqid)
+        args = getNamespaceProperties_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getNamespaceProperties(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getNamespaceProperties_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNamespaceProperties failed: unknown result")
+
+    def namespaceIdMap(self, login):
+        """
+        Parameters:
+         - login
+        """
+        self.send_namespaceIdMap(login)
+        return self.recv_namespaceIdMap()
+
+    def send_namespaceIdMap(self, login):
+        self._oprot.writeMessageBegin('namespaceIdMap', TMessageType.CALL, self._seqid)
+        args = namespaceIdMap_args()
+        args.login = login
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_namespaceIdMap(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = namespaceIdMap_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "namespaceIdMap failed: unknown result")
+
+    def attachNamespaceIterator(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        self.send_attachNamespaceIterator(login, namespaceName, setting, scopes)
+        self.recv_attachNamespaceIterator()
+
+    def send_attachNamespaceIterator(self, login, namespaceName, setting, scopes):
+        self._oprot.writeMessageBegin('attachNamespaceIterator', TMessageType.CALL, self._seqid)
+        args = attachNamespaceIterator_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_attachNamespaceIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = attachNamespaceIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def removeNamespaceIterator(self, login, namespaceName, name, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scopes
+        """
+        self.send_removeNamespaceIterator(login, namespaceName, name, scopes)
+        self.recv_removeNamespaceIterator()
+
+    def send_removeNamespaceIterator(self, login, namespaceName, name, scopes):
+        self._oprot.writeMessageBegin('removeNamespaceIterator', TMessageType.CALL, self._seqid)
+        args = removeNamespaceIterator_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.name = name
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeNamespaceIterator(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeNamespaceIterator_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def getNamespaceIteratorSetting(self, login, namespaceName, name, scope):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - name
+         - scope
+        """
+        self.send_getNamespaceIteratorSetting(login, namespaceName, name, scope)
+        return self.recv_getNamespaceIteratorSetting()
+
+    def send_getNamespaceIteratorSetting(self, login, namespaceName, name, scope):
+        self._oprot.writeMessageBegin('getNamespaceIteratorSetting', TMessageType.CALL, self._seqid)
+        args = getNamespaceIteratorSetting_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.name = name
+        args.scope = scope
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_getNamespaceIteratorSetting(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = getNamespaceIteratorSetting_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNamespaceIteratorSetting failed: unknown result")
+
+    def listNamespaceIterators(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_listNamespaceIterators(login, namespaceName)
+        return self.recv_listNamespaceIterators()
+
+    def send_listNamespaceIterators(self, login, namespaceName):
+        self._oprot.writeMessageBegin('listNamespaceIterators', TMessageType.CALL, self._seqid)
+        args = listNamespaceIterators_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listNamespaceIterators(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listNamespaceIterators_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaceIterators failed: unknown result")
+
+    def checkNamespaceIteratorConflicts(self, login, namespaceName, setting, scopes):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - setting
+         - scopes
+        """
+        self.send_checkNamespaceIteratorConflicts(login, namespaceName, setting, scopes)
+        self.recv_checkNamespaceIteratorConflicts()
+
+    def send_checkNamespaceIteratorConflicts(self, login, namespaceName, setting, scopes):
+        self._oprot.writeMessageBegin('checkNamespaceIteratorConflicts', TMessageType.CALL, self._seqid)
+        args = checkNamespaceIteratorConflicts_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.setting = setting
+        args.scopes = scopes
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_checkNamespaceIteratorConflicts(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = checkNamespaceIteratorConflicts_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def addNamespaceConstraint(self, login, namespaceName, constraintClassName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - constraintClassName
+        """
+        self.send_addNamespaceConstraint(login, namespaceName, constraintClassName)
+        return self.recv_addNamespaceConstraint()
+
+    def send_addNamespaceConstraint(self, login, namespaceName, constraintClassName):
+        self._oprot.writeMessageBegin('addNamespaceConstraint', TMessageType.CALL, self._seqid)
+        args = addNamespaceConstraint_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.constraintClassName = constraintClassName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_addNamespaceConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = addNamespaceConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "addNamespaceConstraint failed: unknown result")
+
+    def removeNamespaceConstraint(self, login, namespaceName, id):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - id
+        """
+        self.send_removeNamespaceConstraint(login, namespaceName, id)
+        self.recv_removeNamespaceConstraint()
+
+    def send_removeNamespaceConstraint(self, login, namespaceName, id):
+        self._oprot.writeMessageBegin('removeNamespaceConstraint', TMessageType.CALL, self._seqid)
+        args = removeNamespaceConstraint_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.id = id
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_removeNamespaceConstraint(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = removeNamespaceConstraint_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        return
+
+    def listNamespaceConstraints(self, login, namespaceName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+        """
+        self.send_listNamespaceConstraints(login, namespaceName)
+        return self.recv_listNamespaceConstraints()
+
+    def send_listNamespaceConstraints(self, login, namespaceName):
+        self._oprot.writeMessageBegin('listNamespaceConstraints', TMessageType.CALL, self._seqid)
+        args = listNamespaceConstraints_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_listNamespaceConstraints(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = listNamespaceConstraints_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "listNamespaceConstraints failed: unknown result")
+
+    def testNamespaceClassLoad(self, login, namespaceName, className, asTypeName):
+        """
+        Parameters:
+         - login
+         - namespaceName
+         - className
+         - asTypeName
+        """
+        self.send_testNamespaceClassLoad(login, namespaceName, className, asTypeName)
+        return self.recv_testNamespaceClassLoad()
+
+    def send_testNamespaceClassLoad(self, login, namespaceName, className, asTypeName):
+        self._oprot.writeMessageBegin('testNamespaceClassLoad', TMessageType.CALL, self._seqid)
+        args = testNamespaceClassLoad_args()
+        args.login = login
+        args.namespaceName = namespaceName
+        args.className = className
+        args.asTypeName = asTypeName
+        args.write(self._oprot)
+        self._oprot.writeMessageEnd()
+        self._oprot.trans.flush()
+
+    def recv_testNamespaceClassLoad(self):
+        iprot = self._iprot
+        (fname, mtype, rseqid) = iprot.readMessageBegin()
+        if mtype == TMessageType.EXCEPTION:
+            x = TApplicationException()
+            x.read(iprot)
+            iprot.readMessageEnd()
+            raise x
+        result = testNamespaceClassLoad_result()
+        result.read(iprot)
+        iprot.readMessageEnd()
+        if result.success is not None:
+            return result.success
+        if result.ouch1 is not None:
+            raise result.ouch1
+        if result.ouch2 is not None:
+            raise result.ouch2
+        if result.ouch3 is not None:
+            raise result.ouch3
+        raise TApplicationException(TApplicationException.MISSING_RESULT, "testNamespaceClassLoad failed: unknown result")
+
+
+class Processor(Iface, TProcessor):
+    def __init__(self, handler):
+        self._handler = handler
+        self._processMap = {}
+        self._processMap["login"] = Processor.process_login
+        self._processMap["addConstraint"] = Processor.process_addConstraint
+        self._processMap["addSplits"] = Processor.process_addSplits
+        self._processMap["attachIterator"] = Processor.process_attachIterator
+        self._processMap["checkIteratorConflicts"] = Processor.process_checkIteratorConflicts
+        self._processMap["clearLocatorCache"] = Processor.process_clearLocatorCache
+        self._processMap["cloneTable"] = Processor.process_cloneTable
+        self._processMap["compactTable"] = Processor.process_compactTable
+        self._processMap["cancelCompaction"] = Processor.process_cancelCompaction
+        self._processMap["createTable"] = Processor.process_createTable
+        self._processMap["deleteTable"] = Processor.process_deleteTable
+        self._processMap["deleteRows"] = Processor.process_deleteRows
+        self._processMap["exportTable"] = Processor.process_exportTable
+        self._processMap["flushTable"] = Processor.process_flushTable
+        self._processMap["getDiskUsage"] = Processor.process_getDiskUsage
+        self._processMap["getLocalityGroups"] = Processor.process_getLocalityGroups
+        self._processMap["getIteratorSetting"] = Processor.process_getIteratorSetting
+        self._processMap["getMaxRow"] = Processor.process_getMaxRow
+        self._processMap["getTableProperties"] = Processor.process_getTableProperties
+        self._processMap["importDirectory"] = Processor.process_importDirectory
+        self._processMap["importTable"] = Processor.process_importTable
+        self._processMap["listSplits"] = Processor.process_listSplits
+        self._processMap["listTables"] = Processor.process_listTables
+        self._processMap["listIterators"] = Processor.process_listIterators
+        self._processMap["listConstraints"] = Processor.process_listConstraints
+        self._processMap["mergeTablets"] = Processor.process_mergeTablets
+        self._processMap["offlineTable"] = Processor.process_offlineTable
+        self._processMap["onlineTable"] = Processor.process_onlineTable
+        self._processMap["removeConstraint"] = Processor.process_removeConstraint
+        self._processMap["removeIterator"] = Processor.process_removeIterator
+        self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
+        self._processMap["renameTable"] = Processor.process_renameTable
+        self._processMap["setLocalityGroups"] = Processor.process_setLocalityGroups
+        self._processMap["setTableProperty"] = Processor.process_setTableProperty
+        self._processMap["splitRangeByTablets"] = Processor.process_splitRangeByTablets
+        self._processMap["tableExists"] = Processor.process_tableExists
+        self._processMap["tableIdMap"] = Processor.process_tableIdMap
+        self._processMap["testTableClassLoad"] = Processor.process_testTableClassLoad
+        self._processMap["pingTabletServer"] = Processor.process_pingTabletServer
+        self._processMap["getActiveScans"] = Processor.process_getActiveScans
+        self._processMap["getActiveCompactions"] = Processor.process_getActiveCompactions
+        self._processMap["getSiteConfiguration"] = Processor.process_getSiteConfiguration
+        self._processMap["getSystemConfiguration"] = Processor.process_getSystemConfiguration
+        self._processMap["getTabletServers"] = Processor.process_getTabletServers
+        self._processMap["removeProperty"] = Processor.process_removeProperty
+        self._processMap["setProperty"] = Processor.process_setProperty
+        self._processMap["testClassLoad"] = Processor.process_testClassLoad
+        self._processMap["authenticateUser"] = Processor.process_authenticateUser
+        self._processMap["changeUserAuthorizations"] = Processor.process_changeUserAuthorizations
+        self._processMap["changeLocalUserPassword"] = Processor.process_changeLocalUserPassword
+        self._processMap["createLocalUser"] = Processor.process_createLocalUser
+        self._processMap["dropLocalUser"] = Processor.process_dropLocalUser
+        self._processMap["getUserAuthorizations"] = Processor.process_getUserAuthorizations
+        self._processMap["grantSystemPermission"] = Processor.process_grantSystemPermission
+        self._processMap["grantTablePermission"] = Processor.process_grantTablePermission
+        self._processMap["hasSystemPermission"] = Processor.process_hasSystemPermission
+        self._processMap["hasTablePermission"] = Processor.process_hasTablePermission
+        self._processMap["listLocalUsers"] = Processor.process_listLocalUsers
+        self._processMap["revokeSystemPermission"] = Processor.process_revokeSystemPermission
+        self._processMap["revokeTablePermission"] = Processor.process_revokeTablePermission
+        self._processMap["grantNamespacePermission"] = Processor.process_grantNamespacePermission
+        self._processMap["hasNamespacePermission"] = Processor.process_hasNamespacePermission
+        self._processMap["revokeNamespacePermission"] = Processor.process_revokeNamespacePermission
+        self._processMap["createBatchScanner"] = Processor.process_createBatchScanner
+        self._processMap["createScanner"] = Processor.process_createScanner
+        self._processMap["hasNext"] = Processor.process_hasNext
+        self._processMap["nextEntry"] = Processor.process_nextEntry
+        self._processMap["nextK"] = Processor.process_nextK
+        self._processMap["closeScanner"] = Processor.process_closeScanner
+        self._processMap["updateAndFlush"] = Processor.process_updateAndFlush
+        self._processMap["createWriter"] = Processor.process_createWriter
+        self._processMap["update"] = Processor.process_update
+        self._processMap["flush"] = Processor.process_flush
+        self._processMap["closeWriter"] = Processor.process_closeWriter
+        self._processMap["updateRowConditionally"] = Processor.process_updateRowConditionally
+        self._processMap["createConditionalWriter"] = Processor.process_createConditionalWriter
+        self._processMap["updateRowsConditionally"] = Processor.process_updateRowsConditionally
+        self._processMap["closeConditionalWriter"] = Processor.process_closeConditionalWriter
+        self._processMap["getRowRange"] = Processor.process_getRowRange
+        self._processMap["getFollowing"] = Processor.process_getFollowing
+        self._processMap["systemNamespace"] = Processor.process_systemNamespace
+        self._processMap["defaultNamespace"] = Processor.process_defaultNamespace
+        self._processMap["listNamespaces"] = Processor.process_listNamespaces
+        self._processMap["namespaceExists"] = Processor.process_namespaceExists
+        self._processMap["createNamespace"] = Processor.process_createNamespace
+        self._processMap["deleteNamespace"] = Processor.process_deleteNamespace
+        self._processMap["renameNamespace"] = Processor.process_renameNamespace
+        self._processMap["setNamespaceProperty"] = Processor.process_setNamespaceProperty
+        self._processMap["removeNamespaceProperty"] = Processor.process_removeNamespaceProperty
+        self._processMap["getNamespaceProperties"] = Processor.process_getNamespaceProperties
+        self._processMap["namespaceIdMap"] = Processor.process_namespaceIdMap
+        self._processMap["attachNamespaceIterator"] = Processor.process_attachNamespaceIterator
+        self._processMap["removeNamespaceIterator"] = Processor.process_removeNamespaceIterator
+        self._processMap["getNamespaceIteratorSetting"] = Processor.process_getNamespaceIteratorSetting
+        self._processMap["listNamespaceIterators"] = Processor.process_listNamespaceIterators
+        self._processMap["checkNamespaceIteratorConflicts"] = Processor.process_checkNamespaceIteratorConflicts
+        self._processMap["addNamespaceConstraint"] = Processor.process_addNamespaceConstraint
+        self._processMap["removeNamespaceConstraint"] = Processor.process_removeNamespaceConstraint
+        self._processMap["listNamespaceConstraints"] = Processor.process_listNamespaceConstraints
+        self._processMap["testNamespaceClassLoad"] = Processor.process_testNamespaceClassLoad
+
+    def process(self, iprot, oprot):
+        (name, type, seqid) = iprot.readMessageBegin()
+        if name not in self._processMap:
+            iprot.skip(TType.STRUCT)
+            iprot.readMessageEnd()
+            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
+            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
+            x.write(oprot)
+            oprot.writeMessageEnd()
+            oprot.trans.flush()
+            return
+        else:
+            self._processMap[name](self, seqid, iprot, oprot)
+        return True
+
+    def process_login(self, seqid, iprot, oprot):
+        args = login_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = login_result()
+        try:
+            result.success = self._handler.login(args.principal, args.loginProperties)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("login", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_addConstraint(self, seqid, iprot, oprot):
+        args = addConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = addConstraint_result()
+        try:
+            result.success = self._handler.addConstraint(args.login, args.tableName, args.constraintClassName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("addConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_addSplits(self, seqid, iprot, oprot):
+        args = addSplits_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = addSplits_result()
+        try:
+            self._handler.addSplits(args.login, args.tableName, args.splits)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("addSplits", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_attachIterator(self, seqid, iprot, oprot):
+        args = attachIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = attachIterator_result()
+        try:
+            self._handler.attachIterator(args.login, args.tableName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("attachIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_checkIteratorConflicts(self, seqid, iprot, oprot):
+        args = checkIteratorConflicts_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = checkIteratorConflicts_result()
+        try:
+            self._handler.checkIteratorConflicts(args.login, args.tableName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("checkIteratorConflicts", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_clearLocatorCache(self, seqid, iprot, oprot):
+        args = clearLocatorCache_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = clearLocatorCache_result()
+        try:
+            self._handler.clearLocatorCache(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except TableNotFoundException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("clearLocatorCache", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_cloneTable(self, seqid, iprot, oprot):
+        args = cloneTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = cloneTable_result()
+        try:
+            self._handler.cloneTable(args.login, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except TableExistsException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("cloneTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_compactTable(self, seqid, iprot, oprot):
+        args = compactTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = compactTable_result()
+        try:
+            self._handler.compactTable(args.login, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait, args.compactionStrategy)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except TableNotFoundException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("compactTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_cancelCompaction(self, seqid, iprot, oprot):
+        args = cancelCompaction_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = cancelCompaction_result()
+        try:
+            self._handler.cancelCompaction(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloSecurityException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except TableNotFoundException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("cancelCompaction", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createTable(self, seqid, iprot, oprot):
+        args = createTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createTable_result()
+        try:
+            self._handler.createTable(args.login, args.tableName, args.versioningIter, args.type)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableExistsException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_deleteTable(self, seqid, iprot, oprot):
+        args = deleteTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = deleteTable_result()
+        try:
+            self._handler.deleteTable(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("deleteTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_deleteRows(self, seqid, iprot, oprot):
+        args = deleteRows_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = deleteRows_result()
+        try:
+            self._handler.deleteRows(args.login, args.tableName, args.startRow, args.endRow)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("deleteRows", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_exportTable(self, seqid, iprot, oprot):
+        args = exportTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = exportTable_result()
+        try:
+            self._handler.exportTable(args.login, args.tableName, args.exportDir)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("exportTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_flushTable(self, seqid, iprot, oprot):
+        args = flushTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = flushTable_result()
+        try:
+            self._handler.flushTable(args.login, args.tableName, args.startRow, args.endRow, args.wait)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("flushTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getDiskUsage(self, seqid, iprot, oprot):
+        args = getDiskUsage_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getDiskUsage_result()
+        try:
+            result.success = self._handler.getDiskUsage(args.login, args.tables)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getDiskUsage", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getLocalityGroups(self, seqid, iprot, oprot):
+        args = getLocalityGroups_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getLocalityGroups_result()
+        try:
+            result.success = self._handler.getLocalityGroups(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getLocalityGroups", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getIteratorSetting(self, seqid, iprot, oprot):
+        args = getIteratorSetting_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getIteratorSetting_result()
+        try:
+            result.success = self._handler.getIteratorSetting(args.login, args.tableName, args.iteratorName, args.scope)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getIteratorSetting", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getMaxRow(self, seqid, iprot, oprot):
+        args = getMaxRow_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getMaxRow_result()
+        try:
+            result.success = self._handler.getMaxRow(args.login, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getMaxRow", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getTableProperties(self, seqid, iprot, oprot):
+        args = getTableProperties_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getTableProperties_result()
+        try:
+            result.success = self._handler.getTableProperties(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getTableProperties", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_importDirectory(self, seqid, iprot, oprot):
+        args = importDirectory_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = importDirectory_result()
+        try:
+            self._handler.importDirectory(args.login, args.tableName, args.importDir, args.failureDir, args.setTime)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except TableNotFoundException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except AccumuloSecurityException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("importDirectory", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_importTable(self, seqid, iprot, oprot):
+        args = importTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = importTable_result()
+        try:
+            self._handler.importTable(args.login, args.tableName, args.importDir)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except TableExistsException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("importTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listSplits(self, seqid, iprot, oprot):
+        args = listSplits_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listSplits_result()
+        try:
+            result.success = self._handler.listSplits(args.login, args.tableName, args.maxSplits)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listSplits", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listTables(self, seqid, iprot, oprot):
+        args = listTables_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listTables_result()
+        try:
+            result.success = self._handler.listTables(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listTables", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listIterators(self, seqid, iprot, oprot):
+        args = listIterators_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listIterators_result()
+        try:
+            result.success = self._handler.listIterators(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listIterators", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listConstraints(self, seqid, iprot, oprot):
+        args = listConstraints_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listConstraints_result()
+        try:
+            result.success = self._handler.listConstraints(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listConstraints", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_mergeTablets(self, seqid, iprot, oprot):
+        args = mergeTablets_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = mergeTablets_result()
+        try:
+            self._handler.mergeTablets(args.login, args.tableName, args.startRow, args.endRow)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("mergeTablets", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_offlineTable(self, seqid, iprot, oprot):
+        args = offlineTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = offlineTable_result()
+        try:
+            self._handler.offlineTable(args.login, args.tableName, args.wait)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("offlineTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_onlineTable(self, seqid, iprot, oprot):
+        args = onlineTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = onlineTable_result()
+        try:
+            self._handler.onlineTable(args.login, args.tableName, args.wait)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("onlineTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeConstraint(self, seqid, iprot, oprot):
+        args = removeConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeConstraint_result()
+        try:
+            self._handler.removeConstraint(args.login, args.tableName, args.constraint)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeIterator(self, seqid, iprot, oprot):
+        args = removeIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeIterator_result()
+        try:
+            self._handler.removeIterator(args.login, args.tableName, args.iterName, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeTableProperty(self, seqid, iprot, oprot):
+        args = removeTableProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeTableProperty_result()
+        try:
+            self._handler.removeTableProperty(args.login, args.tableName, args.property)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeTableProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_renameTable(self, seqid, iprot, oprot):
+        args = renameTable_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = renameTable_result()
+        try:
+            self._handler.renameTable(args.login, args.oldTableName, args.newTableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except TableExistsException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("renameTable", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setLocalityGroups(self, seqid, iprot, oprot):
+        args = setLocalityGroups_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setLocalityGroups_result()
+        try:
+            self._handler.setLocalityGroups(args.login, args.tableName, args.groups)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setLocalityGroups", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setTableProperty(self, seqid, iprot, oprot):
+        args = setTableProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setTableProperty_result()
+        try:
+            self._handler.setTableProperty(args.login, args.tableName, args.property, args.value)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setTableProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_splitRangeByTablets(self, seqid, iprot, oprot):
+        args = splitRangeByTablets_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = splitRangeByTablets_result()
+        try:
+            result.success = self._handler.splitRangeByTablets(args.login, args.tableName, args.range, args.maxSplits)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("splitRangeByTablets", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_tableExists(self, seqid, iprot, oprot):
+        args = tableExists_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = tableExists_result()
+        try:
+            result.success = self._handler.tableExists(args.login, args.tableName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("tableExists", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_tableIdMap(self, seqid, iprot, oprot):
+        args = tableIdMap_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = tableIdMap_result()
+        try:
+            result.success = self._handler.tableIdMap(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("tableIdMap", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_testTableClassLoad(self, seqid, iprot, oprot):
+        args = testTableClassLoad_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = testTableClassLoad_result()
+        try:
+            result.success = self._handler.testTableClassLoad(args.login, args.tableName, args.className, args.asTypeName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("testTableClassLoad", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_pingTabletServer(self, seqid, iprot, oprot):
+        args = pingTabletServer_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = pingTabletServer_result()
+        try:
+            self._handler.pingTabletServer(args.login, args.tserver)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("pingTabletServer", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getActiveScans(self, seqid, iprot, oprot):
+        args = getActiveScans_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getActiveScans_result()
+        try:
+            result.success = self._handler.getActiveScans(args.login, args.tserver)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getActiveScans", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getActiveCompactions(self, seqid, iprot, oprot):
+        args = getActiveCompactions_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getActiveCompactions_result()
+        try:
+            result.success = self._handler.getActiveCompactions(args.login, args.tserver)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getActiveCompactions", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getSiteConfiguration(self, seqid, iprot, oprot):
+        args = getSiteConfiguration_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getSiteConfiguration_result()
+        try:
+            result.success = self._handler.getSiteConfiguration(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getSiteConfiguration", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getSystemConfiguration(self, seqid, iprot, oprot):
+        args = getSystemConfiguration_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getSystemConfiguration_result()
+        try:
+            result.success = self._handler.getSystemConfiguration(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getSystemConfiguration", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getTabletServers(self, seqid, iprot, oprot):
+        args = getTabletServers_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getTabletServers_result()
+        try:
+            result.success = self._handler.getTabletServers(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getTabletServers", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeProperty(self, seqid, iprot, oprot):
+        args = removeProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeProperty_result()
+        try:
+            self._handler.removeProperty(args.login, args.property)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setProperty(self, seqid, iprot, oprot):
+        args = setProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setProperty_result()
+        try:
+            self._handler.setProperty(args.login, args.property, args.value)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_testClassLoad(self, seqid, iprot, oprot):
+        args = testClassLoad_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = testClassLoad_result()
+        try:
+            result.success = self._handler.testClassLoad(args.login, args.className, args.asTypeName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("testClassLoad", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_authenticateUser(self, seqid, iprot, oprot):
+        args = authenticateUser_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = authenticateUser_result()
+        try:
+            result.success = self._handler.authenticateUser(args.login, args.user, args.properties)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("authenticateUser", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_changeUserAuthorizations(self, seqid, iprot, oprot):
+        args = changeUserAuthorizations_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = changeUserAuthorizations_result()
+        try:
+            self._handler.changeUserAuthorizations(args.login, args.user, args.authorizations)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("changeUserAuthorizations", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_changeLocalUserPassword(self, seqid, iprot, oprot):
+        args = changeLocalUserPassword_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = changeLocalUserPassword_result()
+        try:
+            self._handler.changeLocalUserPassword(args.login, args.user, args.password)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("changeLocalUserPassword", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createLocalUser(self, seqid, iprot, oprot):
+        args = createLocalUser_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createLocalUser_result()
+        try:
+            self._handler.createLocalUser(args.login, args.user, args.password)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createLocalUser", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_dropLocalUser(self, seqid, iprot, oprot):
+        args = dropLocalUser_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = dropLocalUser_result()
+        try:
+            self._handler.dropLocalUser(args.login, args.user)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("dropLocalUser", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getUserAuthorizations(self, seqid, iprot, oprot):
+        args = getUserAuthorizations_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getUserAuthorizations_result()
+        try:
+            result.success = self._handler.getUserAuthorizations(args.login, args.user)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getUserAuthorizations", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_grantSystemPermission(self, seqid, iprot, oprot):
+        args = grantSystemPermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = grantSystemPermission_result()
+        try:
+            self._handler.grantSystemPermission(args.login, args.user, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("grantSystemPermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_grantTablePermission(self, seqid, iprot, oprot):
+        args = grantTablePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = grantTablePermission_result()
+        try:
+            self._handler.grantTablePermission(args.login, args.user, args.table, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("grantTablePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasSystemPermission(self, seqid, iprot, oprot):
+        args = hasSystemPermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasSystemPermission_result()
+        try:
+            result.success = self._handler.hasSystemPermission(args.login, args.user, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasSystemPermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasTablePermission(self, seqid, iprot, oprot):
+        args = hasTablePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasTablePermission_result()
+        try:
+            result.success = self._handler.hasTablePermission(args.login, args.user, args.table, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasTablePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listLocalUsers(self, seqid, iprot, oprot):
+        args = listLocalUsers_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listLocalUsers_result()
+        try:
+            result.success = self._handler.listLocalUsers(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listLocalUsers", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_revokeSystemPermission(self, seqid, iprot, oprot):
+        args = revokeSystemPermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = revokeSystemPermission_result()
+        try:
+            self._handler.revokeSystemPermission(args.login, args.user, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("revokeSystemPermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_revokeTablePermission(self, seqid, iprot, oprot):
+        args = revokeTablePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = revokeTablePermission_result()
+        try:
+            self._handler.revokeTablePermission(args.login, args.user, args.table, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("revokeTablePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_grantNamespacePermission(self, seqid, iprot, oprot):
+        args = grantNamespacePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = grantNamespacePermission_result()
+        try:
+            self._handler.grantNamespacePermission(args.login, args.user, args.namespaceName, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("grantNamespacePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasNamespacePermission(self, seqid, iprot, oprot):
+        args = hasNamespacePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasNamespacePermission_result()
+        try:
+            result.success = self._handler.hasNamespacePermission(args.login, args.user, args.namespaceName, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasNamespacePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_revokeNamespacePermission(self, seqid, iprot, oprot):
+        args = revokeNamespacePermission_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = revokeNamespacePermission_result()
+        try:
+            self._handler.revokeNamespacePermission(args.login, args.user, args.namespaceName, args.perm)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("revokeNamespacePermission", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createBatchScanner(self, seqid, iprot, oprot):
+        args = createBatchScanner_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createBatchScanner_result()
+        try:
+            result.success = self._handler.createBatchScanner(args.login, args.tableName, args.options)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createBatchScanner", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createScanner(self, seqid, iprot, oprot):
+        args = createScanner_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createScanner_result()
+        try:
+            result.success = self._handler.createScanner(args.login, args.tableName, args.options)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createScanner", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_hasNext(self, seqid, iprot, oprot):
+        args = hasNext_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = hasNext_result()
+        try:
+            result.success = self._handler.hasNext(args.scanner)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownScanner as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("hasNext", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_nextEntry(self, seqid, iprot, oprot):
+        args = nextEntry_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = nextEntry_result()
+        try:
+            result.success = self._handler.nextEntry(args.scanner)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except NoMoreEntriesException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except UnknownScanner as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("nextEntry", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_nextK(self, seqid, iprot, oprot):
+        args = nextK_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = nextK_result()
+        try:
+            result.success = self._handler.nextK(args.scanner, args.k)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except NoMoreEntriesException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except UnknownScanner as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("nextK", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_closeScanner(self, seqid, iprot, oprot):
+        args = closeScanner_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = closeScanner_result()
+        try:
+            self._handler.closeScanner(args.scanner)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownScanner as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("closeScanner", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_updateAndFlush(self, seqid, iprot, oprot):
+        args = updateAndFlush_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = updateAndFlush_result()
+        try:
+            self._handler.updateAndFlush(args.login, args.tableName, args.cells)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as outch1:
+            msg_type = TMessageType.REPLY
+            result.outch1 = outch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except MutationsRejectedException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("updateAndFlush", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createWriter(self, seqid, iprot, oprot):
+        args = createWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createWriter_result()
+        try:
+            result.success = self._handler.createWriter(args.login, args.tableName, args.opts)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as outch1:
+            msg_type = TMessageType.REPLY
+            result.outch1 = outch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_update(self, seqid, iprot, oprot):
+        args = update_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        try:
+            self._handler.update(args.writer, args.cells)
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except:
+            pass
+
+    def process_flush(self, seqid, iprot, oprot):
+        args = flush_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = flush_result()
+        try:
+            self._handler.flush(args.writer)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownWriter as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except MutationsRejectedException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("flush", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_closeWriter(self, seqid, iprot, oprot):
+        args = closeWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = closeWriter_result()
+        try:
+            self._handler.closeWriter(args.writer)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownWriter as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except MutationsRejectedException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("closeWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_updateRowConditionally(self, seqid, iprot, oprot):
+        args = updateRowConditionally_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = updateRowConditionally_result()
+        try:
+            result.success = self._handler.updateRowConditionally(args.login, args.tableName, args.row, args.updates)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("updateRowConditionally", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createConditionalWriter(self, seqid, iprot, oprot):
+        args = createConditionalWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createConditionalWriter_result()
+        try:
+            result.success = self._handler.createConditionalWriter(args.login, args.tableName, args.options)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except TableNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createConditionalWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_updateRowsConditionally(self, seqid, iprot, oprot):
+        args = updateRowsConditionally_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = updateRowsConditionally_result()
+        try:
+            result.success = self._handler.updateRowsConditionally(args.conditionalWriter, args.updates)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except UnknownWriter as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except AccumuloSecurityException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("updateRowsConditionally", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_closeConditionalWriter(self, seqid, iprot, oprot):
+        args = closeConditionalWriter_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = closeConditionalWriter_result()
+        try:
+            self._handler.closeConditionalWriter(args.conditionalWriter)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("closeConditionalWriter", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getRowRange(self, seqid, iprot, oprot):
+        args = getRowRange_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getRowRange_result()
+        try:
+            result.success = self._handler.getRowRange(args.row)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getRowRange", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getFollowing(self, seqid, iprot, oprot):
+        args = getFollowing_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getFollowing_result()
+        try:
+            result.success = self._handler.getFollowing(args.key, args.part)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getFollowing", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_systemNamespace(self, seqid, iprot, oprot):
+        args = systemNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = systemNamespace_result()
+        try:
+            result.success = self._handler.systemNamespace()
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("systemNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_defaultNamespace(self, seqid, iprot, oprot):
+        args = defaultNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = defaultNamespace_result()
+        try:
+            result.success = self._handler.defaultNamespace()
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("defaultNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listNamespaces(self, seqid, iprot, oprot):
+        args = listNamespaces_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listNamespaces_result()
+        try:
+            result.success = self._handler.listNamespaces(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listNamespaces", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_namespaceExists(self, seqid, iprot, oprot):
+        args = namespaceExists_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = namespaceExists_result()
+        try:
+            result.success = self._handler.namespaceExists(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("namespaceExists", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_createNamespace(self, seqid, iprot, oprot):
+        args = createNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = createNamespace_result()
+        try:
+            self._handler.createNamespace(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceExistsException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("createNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_deleteNamespace(self, seqid, iprot, oprot):
+        args = deleteNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = deleteNamespace_result()
+        try:
+            self._handler.deleteNamespace(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except NamespaceNotEmptyException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("deleteNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_renameNamespace(self, seqid, iprot, oprot):
+        args = renameNamespace_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = renameNamespace_result()
+        try:
+            self._handler.renameNamespace(args.login, args.oldNamespaceName, args.newNamespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except NamespaceExistsException as ouch4:
+            msg_type = TMessageType.REPLY
+            result.ouch4 = ouch4
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("renameNamespace", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_setNamespaceProperty(self, seqid, iprot, oprot):
+        args = setNamespaceProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = setNamespaceProperty_result()
+        try:
+            self._handler.setNamespaceProperty(args.login, args.namespaceName, args.property, args.value)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("setNamespaceProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeNamespaceProperty(self, seqid, iprot, oprot):
+        args = removeNamespaceProperty_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeNamespaceProperty_result()
+        try:
+            self._handler.removeNamespaceProperty(args.login, args.namespaceName, args.property)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeNamespaceProperty", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getNamespaceProperties(self, seqid, iprot, oprot):
+        args = getNamespaceProperties_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getNamespaceProperties_result()
+        try:
+            result.success = self._handler.getNamespaceProperties(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getNamespaceProperties", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_namespaceIdMap(self, seqid, iprot, oprot):
+        args = namespaceIdMap_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = namespaceIdMap_result()
+        try:
+            result.success = self._handler.namespaceIdMap(args.login)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("namespaceIdMap", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_attachNamespaceIterator(self, seqid, iprot, oprot):
+        args = attachNamespaceIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = attachNamespaceIterator_result()
+        try:
+            self._handler.attachNamespaceIterator(args.login, args.namespaceName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("attachNamespaceIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeNamespaceIterator(self, seqid, iprot, oprot):
+        args = removeNamespaceIterator_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeNamespaceIterator_result()
+        try:
+            self._handler.removeNamespaceIterator(args.login, args.namespaceName, args.name, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeNamespaceIterator", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_getNamespaceIteratorSetting(self, seqid, iprot, oprot):
+        args = getNamespaceIteratorSetting_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getNamespaceIteratorSetting_result()
+        try:
+            result.success = self._handler.getNamespaceIteratorSetting(args.login, args.namespaceName, args.name, args.scope)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("getNamespaceIteratorSetting", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listNamespaceIterators(self, seqid, iprot, oprot):
+        args = listNamespaceIterators_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listNamespaceIterators_result()
+        try:
+            result.success = self._handler.listNamespaceIterators(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listNamespaceIterators", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_checkNamespaceIteratorConflicts(self, seqid, iprot, oprot):
+        args = checkNamespaceIteratorConflicts_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = checkNamespaceIteratorConflicts_result()
+        try:
+            self._handler.checkNamespaceIteratorConflicts(args.login, args.namespaceName, args.setting, args.scopes)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("checkNamespaceIteratorConflicts", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_addNamespaceConstraint(self, seqid, iprot, oprot):
+        args = addNamespaceConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = addNamespaceConstraint_result()
+        try:
+            result.success = self._handler.addNamespaceConstraint(args.login, args.namespaceName, args.constraintClassName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("addNamespaceConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_removeNamespaceConstraint(self, seqid, iprot, oprot):
+        args = removeNamespaceConstraint_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = removeNamespaceConstraint_result()
+        try:
+            self._handler.removeNamespaceConstraint(args.login, args.namespaceName, args.id)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("removeNamespaceConstraint", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_listNamespaceConstraints(self, seqid, iprot, oprot):
+        args = listNamespaceConstraints_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = listNamespaceConstraints_result()
+        try:
+            result.success = self._handler.listNamespaceConstraints(args.login, args.namespaceName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("listNamespaceConstraints", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+    def process_testNamespaceClassLoad(self, seqid, iprot, oprot):
+        args = testNamespaceClassLoad_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = testNamespaceClassLoad_result()
+        try:
+            result.success = self._handler.testNamespaceClassLoad(args.login, args.namespaceName, args.className, args.asTypeName)
+            msg_type = TMessageType.REPLY
+        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
+            raise
+        except AccumuloException as ouch1:
+            msg_type = TMessageType.REPLY
+            result.ouch1 = ouch1
+        except AccumuloSecurityException as ouch2:
+            msg_type = TMessageType.REPLY
+            result.ouch2 = ouch2
+        except NamespaceNotFoundException as ouch3:
+            msg_type = TMessageType.REPLY
+            result.ouch3 = ouch3
+        except Exception as ex:
+            msg_type = TMessageType.EXCEPTION
+            logging.exception(ex)
+            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+        oprot.writeMessageBegin("testNamespaceClassLoad", msg_type, seqid)
+        result.write(oprot)
+        oprot.writeMessageEnd()
+        oprot.trans.flush()
+
+# HELPER FUNCTIONS AND STRUCTURES
+
+
+class login_args(object):
     """
-    Parameters:
+    Attributes:
      - principal
      - loginProperties
     """
-    pass
 
-  def addConstraint(self, login, tableName, constraintClassName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'principal', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'loginProperties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
+    )
+
+    def __init__(self, principal=None, loginProperties=None,):
+        self.principal = principal
+        self.loginProperties = loginProperties
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.principal = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.loginProperties = {}
+                    (_ktype145, _vtype146, _size144) = iprot.readMapBegin()
+                    for _i148 in range(_size144):
+                        _key149 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val150 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.loginProperties[_key149] = _val150
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('login_args')
+        if self.principal is not None:
+            oprot.writeFieldBegin('principal', TType.STRING, 1)
+            oprot.writeString(self.principal.encode('utf-8') if sys.version_info[0] == 2 else self.principal)
+            oprot.writeFieldEnd()
+        if self.loginProperties is not None:
+            oprot.writeFieldBegin('loginProperties', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.loginProperties))
+            for kiter151, viter152 in list(self.loginProperties.items()):
+                oprot.writeString(kiter151.encode('utf-8') if sys.version_info[0] == 2 else kiter151)
+                oprot.writeString(viter152.encode('utf-8') if sys.version_info[0] == 2 else viter152)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class login_result(object):
+    """
+    Attributes:
+     - success
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
+        (1, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, success=None, ouch2=None,):
+        self.success = success
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('login_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeBinary(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 1)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addConstraint_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - constraintClassName
     """
-    pass
 
-  def addSplits(self, login, tableName, splits):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'constraintClassName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, constraintClassName=None,):
+        self.login = login
+        self.tableName = tableName
+        self.constraintClassName = constraintClassName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.constraintClassName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.constraintClassName is not None:
+            oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
+            oprot.writeString(self.constraintClassName.encode('utf-8') if sys.version_info[0] == 2 else self.constraintClassName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addConstraint_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.I32, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addConstraint_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addSplits_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - splits
     """
-    pass
 
-  def attachIterator(self, login, tableName, setting, scopes):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.SET, 'splits', (TType.STRING, 'BINARY', False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, splits=None,):
+        self.login = login
+        self.tableName = tableName
+        self.splits = splits
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.SET:
+                    self.splits = set()
+                    (_etype156, _size153) = iprot.readSetBegin()
+                    for _i157 in range(_size153):
+                        _elem158 = iprot.readBinary()
+                        self.splits.add(_elem158)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addSplits_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.splits is not None:
+            oprot.writeFieldBegin('splits', TType.SET, 3)
+            oprot.writeSetBegin(TType.STRING, len(self.splits))
+            for iter159 in self.splits:
+                oprot.writeBinary(iter159)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addSplits_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addSplits_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class attachIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - setting
      - scopes
     """
-    pass
 
-  def checkIteratorConflicts(self, login, tableName, setting, scopes):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
+        self.login = login
+        self.tableName = tableName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype163, _size160) = iprot.readSetBegin()
+                    for _i164 in range(_size160):
+                        _elem165 = iprot.readI32()
+                        self.scopes.add(_elem165)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter166 in self.scopes:
+                oprot.writeI32(iter166)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class attachIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class checkIteratorConflicts_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - setting
      - scopes
     """
-    pass
 
-  def clearLocatorCache(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
+        self.login = login
+        self.tableName = tableName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype170, _size167) = iprot.readSetBegin()
+                    for _i171 in range(_size167):
+                        _elem172 = iprot.readI32()
+                        self.scopes.add(_elem172)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkIteratorConflicts_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter173 in self.scopes:
+                oprot.writeI32(iter173)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class checkIteratorConflicts_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkIteratorConflicts_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class clearLocatorCache_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('clearLocatorCache_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class clearLocatorCache_result(object):
+    """
+    Attributes:
+     - ouch1
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, ouch1=None,):
+        self.ouch1 = ouch1
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = TableNotFoundException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('clearLocatorCache_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cloneTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - newTableName
@@ -82,11 +8509,237 @@
      - propertiesToSet
      - propertiesToExclude
     """
-    pass
 
-  def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'newTableName', 'UTF8', None, ),  # 3
+        (4, TType.BOOL, 'flush', None, None, ),  # 4
+        (5, TType.MAP, 'propertiesToSet', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
+        (6, TType.SET, 'propertiesToExclude', (TType.STRING, 'UTF8', False), None, ),  # 6
+    )
+
+    def __init__(self, login=None, tableName=None, newTableName=None, flush=None, propertiesToSet=None, propertiesToExclude=None,):
+        self.login = login
+        self.tableName = tableName
+        self.newTableName = newTableName
+        self.flush = flush
+        self.propertiesToSet = propertiesToSet
+        self.propertiesToExclude = propertiesToExclude
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.newTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.BOOL:
+                    self.flush = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.MAP:
+                    self.propertiesToSet = {}
+                    (_ktype175, _vtype176, _size174) = iprot.readMapBegin()
+                    for _i178 in range(_size174):
+                        _key179 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val180 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.propertiesToSet[_key179] = _val180
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.SET:
+                    self.propertiesToExclude = set()
+                    (_etype184, _size181) = iprot.readSetBegin()
+                    for _i185 in range(_size181):
+                        _elem186 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.propertiesToExclude.add(_elem186)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cloneTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.newTableName is not None:
+            oprot.writeFieldBegin('newTableName', TType.STRING, 3)
+            oprot.writeString(self.newTableName.encode('utf-8') if sys.version_info[0] == 2 else self.newTableName)
+            oprot.writeFieldEnd()
+        if self.flush is not None:
+            oprot.writeFieldBegin('flush', TType.BOOL, 4)
+            oprot.writeBool(self.flush)
+            oprot.writeFieldEnd()
+        if self.propertiesToSet is not None:
+            oprot.writeFieldBegin('propertiesToSet', TType.MAP, 5)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.propertiesToSet))
+            for kiter187, viter188 in list(self.propertiesToSet.items()):
+                oprot.writeString(kiter187.encode('utf-8') if sys.version_info[0] == 2 else kiter187)
+                oprot.writeString(viter188.encode('utf-8') if sys.version_info[0] == 2 else viter188)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.propertiesToExclude is not None:
+            oprot.writeFieldBegin('propertiesToExclude', TType.SET, 6)
+            oprot.writeSetBegin(TType.STRING, len(self.propertiesToExclude))
+            for iter189 in self.propertiesToExclude:
+                oprot.writeString(iter189.encode('utf-8') if sys.version_info[0] == 2 else iter189)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cloneTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = TableExistsException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cloneTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class compactTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
@@ -94,86 +8747,1860 @@
      - iterators
      - flush
      - wait
+     - compactionStrategy
     """
-    pass
 
-  def cancelCompaction(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+        (5, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 5
+        (6, TType.BOOL, 'flush', None, None, ),  # 6
+        (7, TType.BOOL, 'wait', None, None, ),  # 7
+        (8, TType.STRUCT, 'compactionStrategy', (CompactionStrategyConfig, CompactionStrategyConfig.thrift_spec), None, ),  # 8
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None, iterators=None, flush=None, wait=None, compactionStrategy=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+        self.iterators = iterators
+        self.flush = flush
+        self.wait = wait
+        self.compactionStrategy = compactionStrategy
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype193, _size190) = iprot.readListBegin()
+                    for _i194 in range(_size190):
+                        _elem195 = IteratorSetting()
+                        _elem195.read(iprot)
+                        self.iterators.append(_elem195)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.BOOL:
+                    self.flush = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.STRUCT:
+                    self.compactionStrategy = CompactionStrategyConfig()
+                    self.compactionStrategy.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('compactTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 5)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter196 in self.iterators:
+                iter196.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.flush is not None:
+            oprot.writeFieldBegin('flush', TType.BOOL, 6)
+            oprot.writeBool(self.flush)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 7)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        if self.compactionStrategy is not None:
+            oprot.writeFieldBegin('compactionStrategy', TType.STRUCT, 8)
+            self.compactionStrategy.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class compactTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = TableNotFoundException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('compactTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cancelCompaction_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def createTable(self, login, tableName, versioningIter, type):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cancelCompaction_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class cancelCompaction_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloSecurityException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = TableNotFoundException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('cancelCompaction_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - versioningIter
      - type
     """
-    pass
 
-  def deleteTable(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.BOOL, 'versioningIter', None, None, ),  # 3
+        (4, TType.I32, 'type', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, versioningIter=None, type=None,):
+        self.login = login
+        self.tableName = tableName
+        self.versioningIter = versioningIter
+        self.type = type
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.BOOL:
+                    self.versioningIter = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.type = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.versioningIter is not None:
+            oprot.writeFieldBegin('versioningIter', TType.BOOL, 3)
+            oprot.writeBool(self.versioningIter)
+            oprot.writeFieldEnd()
+        if self.type is not None:
+            oprot.writeFieldBegin('type', TType.I32, 4)
+            oprot.writeI32(self.type)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableExistsException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def deleteRows(self, login, tableName, startRow, endRow):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteRows_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
      - endRow
     """
-    pass
 
-  def exportTable(self, login, tableName, exportDir):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteRows_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteRows_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteRows_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class exportTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - exportDir
     """
-    pass
 
-  def flushTable(self, login, tableName, startRow, endRow, wait):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'exportDir', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, exportDir=None,):
+        self.login = login
+        self.tableName = tableName
+        self.exportDir = exportDir
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.exportDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('exportTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.exportDir is not None:
+            oprot.writeFieldBegin('exportDir', TType.STRING, 3)
+            oprot.writeString(self.exportDir.encode('utf-8') if sys.version_info[0] == 2 else self.exportDir)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class exportTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('exportTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flushTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
      - endRow
      - wait
     """
-    pass
 
-  def getLocalityGroups(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+        (5, TType.BOOL, 'wait', None, None, ),  # 5
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None, wait=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+        self.wait = wait
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flushTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 5)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flushTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flushTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getDiskUsage_args(object):
+    """
+    Attributes:
+     - login
+     - tables
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.SET, 'tables', (TType.STRING, 'UTF8', False), None, ),  # 2
+    )
+
+    def __init__(self, login=None, tables=None,):
+        self.login = login
+        self.tables = tables
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.SET:
+                    self.tables = set()
+                    (_etype200, _size197) = iprot.readSetBegin()
+                    for _i201 in range(_size197):
+                        _elem202 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.tables.add(_elem202)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getDiskUsage_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tables is not None:
+            oprot.writeFieldBegin('tables', TType.SET, 2)
+            oprot.writeSetBegin(TType.STRING, len(self.tables))
+            for iter203 in self.tables:
+                oprot.writeString(iter203.encode('utf-8') if sys.version_info[0] == 2 else iter203)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getDiskUsage_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRUCT, (DiskUsage, DiskUsage.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype207, _size204) = iprot.readListBegin()
+                    for _i208 in range(_size204):
+                        _elem209 = DiskUsage()
+                        _elem209.read(iprot)
+                        self.success.append(_elem209)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getDiskUsage_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRUCT, len(self.success))
+            for iter210 in self.success:
+                iter210.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getLocalityGroups_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def getIteratorSetting(self, login, tableName, iteratorName, scope):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getLocalityGroups_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getLocalityGroups_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype212, _vtype213, _size211) = iprot.readMapBegin()
+                    for _i215 in range(_size211):
+                        _key216 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val217 = set()
+                        (_etype221, _size218) = iprot.readSetBegin()
+                        for _i222 in range(_size218):
+                            _elem223 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                            _val217.add(_elem223)
+                        iprot.readSetEnd()
+                        self.success[_key216] = _val217
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getLocalityGroups_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
+            for kiter224, viter225 in list(self.success.items()):
+                oprot.writeString(kiter224.encode('utf-8') if sys.version_info[0] == 2 else kiter224)
+                oprot.writeSetBegin(TType.STRING, len(viter225))
+                for iter226 in viter225:
+                    oprot.writeString(iter226.encode('utf-8') if sys.version_info[0] == 2 else iter226)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getIteratorSetting_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - iteratorName
      - scope
     """
-    pass
 
-  def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'iteratorName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'scope', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, iteratorName=None, scope=None,):
+        self.login = login
+        self.tableName = tableName
+        self.iteratorName = iteratorName
+        self.scope = scope
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.iteratorName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.scope = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getIteratorSetting_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.iteratorName is not None:
+            oprot.writeFieldBegin('iteratorName', TType.STRING, 3)
+            oprot.writeString(self.iteratorName.encode('utf-8') if sys.version_info[0] == 2 else self.iteratorName)
+            oprot.writeFieldEnd()
+        if self.scope is not None:
+            oprot.writeFieldBegin('scope', TType.I32, 4)
+            oprot.writeI32(self.scope)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getIteratorSetting_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = IteratorSetting()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getIteratorSetting_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getMaxRow_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - auths
@@ -182,16013 +10609,13842 @@
      - endRow
      - endInclusive
     """
-    pass
 
-  def getTableProperties(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    pass
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.SET, 'auths', (TType.STRING, 'BINARY', False), None, ),  # 3
+        (4, TType.STRING, 'startRow', 'BINARY', None, ),  # 4
+        (5, TType.BOOL, 'startInclusive', None, None, ),  # 5
+        (6, TType.STRING, 'endRow', 'BINARY', None, ),  # 6
+        (7, TType.BOOL, 'endInclusive', None, None, ),  # 7
+    )
+
+    def __init__(self, login=None, tableName=None, auths=None, startRow=None, startInclusive=None, endRow=None, endInclusive=None,):
+        self.login = login
+        self.tableName = tableName
+        self.auths = auths
+        self.startRow = startRow
+        self.startInclusive = startInclusive
+        self.endRow = endRow
+        self.endInclusive = endInclusive
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.SET:
+                    self.auths = set()
+                    (_etype230, _size227) = iprot.readSetBegin()
+                    for _i231 in range(_size227):
+                        _elem232 = iprot.readBinary()
+                        self.auths.add(_elem232)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.BOOL:
+                    self.startInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.BOOL:
+                    self.endInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getMaxRow_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.auths is not None:
+            oprot.writeFieldBegin('auths', TType.SET, 3)
+            oprot.writeSetBegin(TType.STRING, len(self.auths))
+            for iter233 in self.auths:
+                oprot.writeBinary(iter233)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 4)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.startInclusive is not None:
+            oprot.writeFieldBegin('startInclusive', TType.BOOL, 5)
+            oprot.writeBool(self.startInclusive)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 6)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.endInclusive is not None:
+            oprot.writeFieldBegin('endInclusive', TType.BOOL, 7)
+            oprot.writeBool(self.endInclusive)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getMaxRow_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getMaxRow_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeBinary(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def getSplits(self, login, tableName, maxSplits):
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTableProperties_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
-     - maxSplits
     """
-    pass
 
-  def importDirectory(self, login, tableName, importDir, failureDir, setTime):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTableProperties_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTableProperties_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype235, _vtype236, _size234) = iprot.readMapBegin()
+                    for _i238 in range(_size234):
+                        _key239 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val240 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key239] = _val240
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTableProperties_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter241, viter242 in list(self.success.items()):
+                oprot.writeString(kiter241.encode('utf-8') if sys.version_info[0] == 2 else kiter241)
+                oprot.writeString(viter242.encode('utf-8') if sys.version_info[0] == 2 else viter242)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importDirectory_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - importDir
      - failureDir
      - setTime
     """
-    pass
 
-  def importTable(self, login, tableName, importDir):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'importDir', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'failureDir', 'UTF8', None, ),  # 4
+        (5, TType.BOOL, 'setTime', None, None, ),  # 5
+    )
+
+    def __init__(self, login=None, tableName=None, importDir=None, failureDir=None, setTime=None,):
+        self.login = login
+        self.tableName = tableName
+        self.importDir = importDir
+        self.failureDir = failureDir
+        self.setTime = setTime
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.importDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.failureDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.BOOL:
+                    self.setTime = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importDirectory_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.importDir is not None:
+            oprot.writeFieldBegin('importDir', TType.STRING, 3)
+            oprot.writeString(self.importDir.encode('utf-8') if sys.version_info[0] == 2 else self.importDir)
+            oprot.writeFieldEnd()
+        if self.failureDir is not None:
+            oprot.writeFieldBegin('failureDir', TType.STRING, 4)
+            oprot.writeString(self.failureDir.encode('utf-8') if sys.version_info[0] == 2 else self.failureDir)
+            oprot.writeFieldEnd()
+        if self.setTime is not None:
+            oprot.writeFieldBegin('setTime', TType.BOOL, 5)
+            oprot.writeBool(self.setTime)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importDirectory_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch4', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = TableNotFoundException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = AccumuloSecurityException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importDirectory_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 2)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 3)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - importDir
     """
-    pass
 
-  def listTables(self, login):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'importDir', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, importDir=None,):
+        self.login = login
+        self.tableName = tableName
+        self.importDir = importDir
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.importDir = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.importDir is not None:
+            oprot.writeFieldBegin('importDir', TType.STRING, 3)
+            oprot.writeString(self.importDir.encode('utf-8') if sys.version_info[0] == 2 else self.importDir)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class importTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = TableExistsException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('importTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listSplits_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - tableName
+     - maxSplits
     """
-    pass
 
-  def listIterators(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'maxSplits', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, maxSplits=None,):
+        self.login = login
+        self.tableName = tableName
+        self.maxSplits = maxSplits
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.maxSplits = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listSplits_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.maxSplits is not None:
+            oprot.writeFieldBegin('maxSplits', TType.I32, 3)
+            oprot.writeI32(self.maxSplits)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listSplits_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'BINARY', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype246, _size243) = iprot.readListBegin()
+                    for _i247 in range(_size243):
+                        _elem248 = iprot.readBinary()
+                        self.success.append(_elem248)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listSplits_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter249 in self.success:
+                oprot.writeBinary(iter249)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listTables_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listTables_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listTables_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.SET:
+                    self.success = set()
+                    (_etype253, _size250) = iprot.readSetBegin()
+                    for _i254 in range(_size250):
+                        _elem255 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.add(_elem255)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listTables_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.SET, 0)
+            oprot.writeSetBegin(TType.STRING, len(self.success))
+            for iter256 in self.success:
+                oprot.writeString(iter256.encode('utf-8') if sys.version_info[0] == 2 else iter256)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listIterators_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def listConstraints(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listIterators_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listIterators_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.I32, None, False), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype258, _vtype259, _size257) = iprot.readMapBegin()
+                    for _i261 in range(_size257):
+                        _key262 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val263 = set()
+                        (_etype267, _size264) = iprot.readSetBegin()
+                        for _i268 in range(_size264):
+                            _elem269 = iprot.readI32()
+                            _val263.add(_elem269)
+                        iprot.readSetEnd()
+                        self.success[_key262] = _val263
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listIterators_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
+            for kiter270, viter271 in list(self.success.items()):
+                oprot.writeString(kiter270.encode('utf-8') if sys.version_info[0] == 2 else kiter270)
+                oprot.writeSetBegin(TType.I32, len(viter271))
+                for iter272 in viter271:
+                    oprot.writeI32(iter272)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listConstraints_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def mergeTablets(self, login, tableName, startRow, endRow):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listConstraints_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listConstraints_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype274, _vtype275, _size273) = iprot.readMapBegin()
+                    for _i277 in range(_size273):
+                        _key278 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val279 = iprot.readI32()
+                        self.success[_key278] = _val279
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listConstraints_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
+            for kiter280, viter281 in list(self.success.items()):
+                oprot.writeString(kiter280.encode('utf-8') if sys.version_info[0] == 2 else kiter280)
+                oprot.writeI32(viter281)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class mergeTablets_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - startRow
      - endRow
     """
-    pass
 
-  def offlineTable(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'startRow', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'endRow', 'BINARY', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
+        self.login = login
+        self.tableName = tableName
+        self.startRow = startRow
+        self.endRow = endRow
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.startRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('mergeTablets_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.startRow is not None:
+            oprot.writeFieldBegin('startRow', TType.STRING, 3)
+            oprot.writeBinary(self.startRow)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 4)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class mergeTablets_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('mergeTablets_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class offlineTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
+     - wait
     """
-    pass
 
-  def onlineTable(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.BOOL, 'wait', None, False, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, wait=thrift_spec[3][4],):
+        self.login = login
+        self.tableName = tableName
+        self.wait = wait
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('offlineTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 3)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class offlineTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('offlineTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class onlineTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
+     - wait
     """
-    pass
 
-  def removeConstraint(self, login, tableName, constraint):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.BOOL, 'wait', None, False, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, wait=thrift_spec[3][4],):
+        self.login = login
+        self.tableName = tableName
+        self.wait = wait
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.BOOL:
+                    self.wait = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('onlineTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.wait is not None:
+            oprot.writeFieldBegin('wait', TType.BOOL, 3)
+            oprot.writeBool(self.wait)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class onlineTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('onlineTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeConstraint_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - constraint
     """
-    pass
 
-  def removeIterator(self, login, tableName, iterName, scopes):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'constraint', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, constraint=None,):
+        self.login = login
+        self.tableName = tableName
+        self.constraint = constraint
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.constraint = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.constraint is not None:
+            oprot.writeFieldBegin('constraint', TType.I32, 3)
+            oprot.writeI32(self.constraint)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeConstraint_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeConstraint_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - iterName
      - scopes
     """
-    pass
 
-  def removeTableProperty(self, login, tableName, property):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'iterName', 'UTF8', None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, iterName=None, scopes=None,):
+        self.login = login
+        self.tableName = tableName
+        self.iterName = iterName
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.iterName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype285, _size282) = iprot.readSetBegin()
+                    for _i286 in range(_size282):
+                        _elem287 = iprot.readI32()
+                        self.scopes.add(_elem287)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.iterName is not None:
+            oprot.writeFieldBegin('iterName', TType.STRING, 3)
+            oprot.writeString(self.iterName.encode('utf-8') if sys.version_info[0] == 2 else self.iterName)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter288 in self.scopes:
+                oprot.writeI32(iter288)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeTableProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - property
     """
-    pass
 
-  def renameTable(self, login, oldTableName, newTableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, property=None,):
+        self.login = login
+        self.tableName = tableName
+        self.property = property
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeTableProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeTableProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeTableProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameTable_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - oldTableName
      - newTableName
     """
-    pass
 
-  def setLocalityGroups(self, login, tableName, groups):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'oldTableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'newTableName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, oldTableName=None, newTableName=None,):
+        self.login = login
+        self.oldTableName = oldTableName
+        self.newTableName = newTableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.oldTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.newTableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameTable_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.oldTableName is not None:
+            oprot.writeFieldBegin('oldTableName', TType.STRING, 2)
+            oprot.writeString(self.oldTableName.encode('utf-8') if sys.version_info[0] == 2 else self.oldTableName)
+            oprot.writeFieldEnd()
+        if self.newTableName is not None:
+            oprot.writeFieldBegin('newTableName', TType.STRING, 3)
+            oprot.writeString(self.newTableName.encode('utf-8') if sys.version_info[0] == 2 else self.newTableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameTable_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = TableExistsException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameTable_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setLocalityGroups_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - groups
     """
-    pass
 
-  def setTableProperty(self, login, tableName, property, value):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.MAP, 'groups', (TType.STRING, 'UTF8', TType.SET, (TType.STRING, 'UTF8', False), False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, groups=None,):
+        self.login = login
+        self.tableName = tableName
+        self.groups = groups
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.MAP:
+                    self.groups = {}
+                    (_ktype290, _vtype291, _size289) = iprot.readMapBegin()
+                    for _i293 in range(_size289):
+                        _key294 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val295 = set()
+                        (_etype299, _size296) = iprot.readSetBegin()
+                        for _i300 in range(_size296):
+                            _elem301 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                            _val295.add(_elem301)
+                        iprot.readSetEnd()
+                        self.groups[_key294] = _val295
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setLocalityGroups_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.groups is not None:
+            oprot.writeFieldBegin('groups', TType.MAP, 3)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.groups))
+            for kiter302, viter303 in list(self.groups.items()):
+                oprot.writeString(kiter302.encode('utf-8') if sys.version_info[0] == 2 else kiter302)
+                oprot.writeSetBegin(TType.STRING, len(viter303))
+                for iter304 in viter303:
+                    oprot.writeString(iter304.encode('utf-8') if sys.version_info[0] == 2 else iter304)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setLocalityGroups_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setLocalityGroups_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setTableProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - property
      - value
     """
-    pass
 
-  def splitRangeByTablets(self, login, tableName, range, maxSplits):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, property=None, value=None,):
+        self.login = login
+        self.tableName = tableName
+        self.property = property
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setTableProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 4)
+            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setTableProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setTableProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class splitRangeByTablets_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - range
      - maxSplits
     """
-    pass
 
-  def tableExists(self, login, tableName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ),  # 3
+        (4, TType.I32, 'maxSplits', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, range=None, maxSplits=None,):
+        self.login = login
+        self.tableName = tableName
+        self.range = range
+        self.maxSplits = maxSplits
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.range = Range()
+                    self.range.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.maxSplits = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('splitRangeByTablets_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.range is not None:
+            oprot.writeFieldBegin('range', TType.STRUCT, 3)
+            self.range.write(oprot)
+            oprot.writeFieldEnd()
+        if self.maxSplits is not None:
+            oprot.writeFieldBegin('maxSplits', TType.I32, 4)
+            oprot.writeI32(self.maxSplits)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class splitRangeByTablets_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.SET, 'success', (TType.STRUCT, (Range, Range.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.SET:
+                    self.success = set()
+                    (_etype308, _size305) = iprot.readSetBegin()
+                    for _i309 in range(_size305):
+                        _elem310 = Range()
+                        _elem310.read(iprot)
+                        self.success.add(_elem310)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('splitRangeByTablets_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.SET, 0)
+            oprot.writeSetBegin(TType.STRUCT, len(self.success))
+            for iter311 in self.success:
+                iter311.write(oprot)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableExists_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
     """
-    pass
 
-  def tableIdMap(self, login):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tableName=None,):
+        self.login = login
+        self.tableName = tableName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableExists_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableExists_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableExists_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableIdMap_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableIdMap_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class tableIdMap_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype313, _vtype314, _size312) = iprot.readMapBegin()
+                    for _i316 in range(_size312):
+                        _key317 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val318 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key317] = _val318
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('tableIdMap_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter319, viter320 in list(self.success.items()):
+                oprot.writeString(kiter319.encode('utf-8') if sys.version_info[0] == 2 else kiter319)
+                oprot.writeString(viter320.encode('utf-8') if sys.version_info[0] == 2 else viter320)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testTableClassLoad_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - tableName
+     - className
+     - asTypeName
     """
-    pass
 
-  def pingTabletServer(self, login, tserver):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, className=None, asTypeName=None,):
+        self.login = login
+        self.tableName = tableName
+        self.className = className
+        self.asTypeName = asTypeName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.asTypeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testTableClassLoad_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 3)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.asTypeName is not None:
+            oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
+            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testTableClassLoad_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testTableClassLoad_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class pingTabletServer_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tserver
     """
-    pass
 
-  def getActiveScans(self, login, tserver):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tserver=None,):
+        self.login = login
+        self.tserver = tserver
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tserver = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('pingTabletServer_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tserver is not None:
+            oprot.writeFieldBegin('tserver', TType.STRING, 2)
+            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class pingTabletServer_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('pingTabletServer_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveScans_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tserver
     """
-    pass
 
-  def getActiveCompactions(self, login, tserver):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tserver=None,):
+        self.login = login
+        self.tserver = tserver
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tserver = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveScans_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tserver is not None:
+            oprot.writeFieldBegin('tserver', TType.STRING, 2)
+            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveScans_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRUCT, (ActiveScan, ActiveScan.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype324, _size321) = iprot.readListBegin()
+                    for _i325 in range(_size321):
+                        _elem326 = ActiveScan()
+                        _elem326.read(iprot)
+                        self.success.append(_elem326)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveScans_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRUCT, len(self.success))
+            for iter327 in self.success:
+                iter327.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveCompactions_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tserver
     """
-    pass
 
-  def getSiteConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    pass
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tserver', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, tserver=None,):
+        self.login = login
+        self.tserver = tserver
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tserver = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveCompactions_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tserver is not None:
+            oprot.writeFieldBegin('tserver', TType.STRING, 2)
+            oprot.writeString(self.tserver.encode('utf-8') if sys.version_info[0] == 2 else self.tserver)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getActiveCompactions_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRUCT, (ActiveCompaction, ActiveCompaction.thrift_spec), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype331, _size328) = iprot.readListBegin()
+                    for _i332 in range(_size328):
+                        _elem333 = ActiveCompaction()
+                        _elem333.read(iprot)
+                        self.success.append(_elem333)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getActiveCompactions_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRUCT, len(self.success))
+            for iter334 in self.success:
+                iter334.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSiteConfiguration_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSiteConfiguration_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSiteConfiguration_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype336, _vtype337, _size335) = iprot.readMapBegin()
+                    for _i339 in range(_size335):
+                        _key340 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val341 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key340] = _val341
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSiteConfiguration_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter342, viter343 in list(self.success.items()):
+                oprot.writeString(kiter342.encode('utf-8') if sys.version_info[0] == 2 else kiter342)
+                oprot.writeString(viter343.encode('utf-8') if sys.version_info[0] == 2 else viter343)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSystemConfiguration_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSystemConfiguration_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getSystemConfiguration_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype345, _vtype346, _size344) = iprot.readMapBegin()
+                    for _i348 in range(_size344):
+                        _key349 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val350 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key349] = _val350
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getSystemConfiguration_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter351, viter352 in list(self.success.items()):
+                oprot.writeString(kiter351.encode('utf-8') if sys.version_info[0] == 2 else kiter351)
+                oprot.writeString(viter352.encode('utf-8') if sys.version_info[0] == 2 else viter352)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTabletServers_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTabletServers_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getTabletServers_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype356, _size353) = iprot.readListBegin()
+                    for _i357 in range(_size353):
+                        _elem358 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.append(_elem358)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getTabletServers_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter359 in self.success:
+                oprot.writeString(iter359.encode('utf-8') if sys.version_info[0] == 2 else iter359)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def getSystemConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    pass
+    def __ne__(self, other):
+        return not (self == other)
 
-  def getTabletServers(self, login):
-    """
-    Parameters:
-     - login
-    """
-    pass
 
-  def removeProperty(self, login, property):
+class removeProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - property
     """
-    pass
 
-  def setProperty(self, login, property, value):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'property', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, property=None,):
+        self.login = login
+        self.property = property
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 2)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - property
      - value
     """
-    pass
 
-  def testClassLoad(self, login, className, asTypeName):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'property', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'value', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, property=None, value=None,):
+        self.login = login
+        self.property = property
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 2)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 3)
+            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testClassLoad_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - className
      - asTypeName
     """
-    pass
 
-  def authenticateUser(self, login, user, properties):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'className', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, className=None, asTypeName=None,):
+        self.login = login
+        self.className = className
+        self.asTypeName = asTypeName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.asTypeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testClassLoad_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 2)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.asTypeName is not None:
+            oprot.writeFieldBegin('asTypeName', TType.STRING, 3)
+            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testClassLoad_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testClassLoad_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class authenticateUser_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - properties
     """
-    pass
 
-  def changeUserAuthorizations(self, login, user, authorizations):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, properties=None,):
+        self.login = login
+        self.user = user
+        self.properties = properties
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.MAP:
+                    self.properties = {}
+                    (_ktype361, _vtype362, _size360) = iprot.readMapBegin()
+                    for _i364 in range(_size360):
+                        _key365 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val366 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.properties[_key365] = _val366
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('authenticateUser_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.properties is not None:
+            oprot.writeFieldBegin('properties', TType.MAP, 3)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
+            for kiter367, viter368 in list(self.properties.items()):
+                oprot.writeString(kiter367.encode('utf-8') if sys.version_info[0] == 2 else kiter367)
+                oprot.writeString(viter368.encode('utf-8') if sys.version_info[0] == 2 else viter368)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class authenticateUser_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('authenticateUser_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeUserAuthorizations_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - authorizations
     """
-    pass
 
-  def changeLocalUserPassword(self, login, user, password):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, authorizations=None,):
+        self.login = login
+        self.user = user
+        self.authorizations = authorizations
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype372, _size369) = iprot.readSetBegin()
+                    for _i373 in range(_size369):
+                        _elem374 = iprot.readBinary()
+                        self.authorizations.add(_elem374)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeUserAuthorizations_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 3)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter375 in self.authorizations:
+                oprot.writeBinary(iter375)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeUserAuthorizations_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeUserAuthorizations_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeLocalUserPassword_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - password
     """
-    pass
 
-  def createLocalUser(self, login, user, password):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'password', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, password=None,):
+        self.login = login
+        self.user = user
+        self.password = password
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.password = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeLocalUserPassword_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.password is not None:
+            oprot.writeFieldBegin('password', TType.STRING, 3)
+            oprot.writeBinary(self.password)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class changeLocalUserPassword_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('changeLocalUserPassword_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createLocalUser_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - password
     """
-    pass
 
-  def dropLocalUser(self, login, user):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'password', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, password=None,):
+        self.login = login
+        self.user = user
+        self.password = password
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.password = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createLocalUser_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.password is not None:
+            oprot.writeFieldBegin('password', TType.STRING, 3)
+            oprot.writeBinary(self.password)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createLocalUser_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createLocalUser_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class dropLocalUser_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
     """
-    pass
 
-  def getUserAuthorizations(self, login, user):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, user=None,):
+        self.login = login
+        self.user = user
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('dropLocalUser_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class dropLocalUser_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('dropLocalUser_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getUserAuthorizations_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
     """
-    pass
 
-  def grantSystemPermission(self, login, user, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, user=None,):
+        self.login = login
+        self.user = user
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getUserAuthorizations_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getUserAuthorizations_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'BINARY', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype379, _size376) = iprot.readListBegin()
+                    for _i380 in range(_size376):
+                        _elem381 = iprot.readBinary()
+                        self.success.append(_elem381)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getUserAuthorizations_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter382 in self.success:
+                oprot.writeBinary(iter382)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantSystemPermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - perm
     """
-    pass
 
-  def grantTablePermission(self, login, user, table, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'perm', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantSystemPermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 3)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantSystemPermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantSystemPermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantTablePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - table
      - perm
     """
-    pass
 
-  def hasSystemPermission(self, login, user, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, table=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.table = table
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantTablePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantTablePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantTablePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasSystemPermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - perm
     """
-    pass
 
-  def hasTablePermission(self, login, user, table, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'perm', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasSystemPermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 3)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasSystemPermission_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasSystemPermission_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasTablePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
      - table
      - perm
     """
-    pass
 
-  def listLocalUsers(self, login):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, table=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.table = table
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasTablePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasTablePermission_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasTablePermission_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listLocalUsers_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listLocalUsers_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listLocalUsers_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.SET:
+                    self.success = set()
+                    (_etype386, _size383) = iprot.readSetBegin()
+                    for _i387 in range(_size383):
+                        _elem388 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.add(_elem388)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listLocalUsers_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.SET, 0)
+            oprot.writeSetBegin(TType.STRING, len(self.success))
+            for iter389 in self.success:
+                oprot.writeString(iter389.encode('utf-8') if sys.version_info[0] == 2 else iter389)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeSystemPermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - user
+     - perm
     """
-    pass
 
-  def revokeSystemPermission(self, login, user, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'perm', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, user=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeSystemPermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 3)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeSystemPermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeSystemPermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeTablePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
+     - table
      - perm
     """
-    pass
 
-  def revokeTablePermission(self, login, user, table, perm):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, table=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.table = table
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeTablePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeTablePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeTablePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantNamespacePermission_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - user
-     - table
+     - namespaceName
      - perm
     """
-    pass
 
-  def createBatchScanner(self, login, tableName, options):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, namespaceName=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.namespaceName = namespaceName
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantNamespacePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class grantNamespacePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('grantNamespacePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNamespacePermission_args(object):
+    """
+    Attributes:
+     - login
+     - user
+     - namespaceName
+     - perm
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, namespaceName=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.namespaceName = namespaceName
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNamespacePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNamespacePermission_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNamespacePermission_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeNamespacePermission_args(object):
+    """
+    Attributes:
+     - login
+     - user
+     - namespaceName
+     - perm
     """
-    Parameters:
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'perm', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, user=None, namespaceName=None, perm=None,):
+        self.login = login
+        self.user = user
+        self.namespaceName = namespaceName
+        self.perm = perm
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.perm = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeNamespacePermission_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 3)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.perm is not None:
+            oprot.writeFieldBegin('perm', TType.I32, 4)
+            oprot.writeI32(self.perm)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class revokeNamespacePermission_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('revokeNamespacePermission_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createBatchScanner_args(object):
+    """
+    Attributes:
      - login
      - tableName
      - options
     """
-    pass
 
-  def createScanner(self, login, tableName, options):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'options', (BatchScanOptions, BatchScanOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, options=None,):
+        self.login = login
+        self.tableName = tableName
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.options = BatchScanOptions()
+                    self.options.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createBatchScanner_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.STRUCT, 3)
+            self.options.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createBatchScanner_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createBatchScanner_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createScanner_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - options
     """
-    pass
 
-  def hasNext(self, scanner):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'options', (ScanOptions, ScanOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, options=None,):
+        self.login = login
+        self.tableName = tableName
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.options = ScanOptions()
+                    self.options.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createScanner_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.STRUCT, 3)
+            self.options.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createScanner_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createScanner_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNext_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
     """
-    pass
 
-  def nextEntry(self, scanner):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, scanner=None,):
+        self.scanner = scanner
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNext_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class hasNext_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, success=None, ouch1=None,):
+        self.success = success
+        self.ouch1 = ouch1
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownScanner()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('hasNext_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextEntry_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
     """
-    pass
 
-  def nextK(self, scanner, k):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, scanner=None,):
+        self.scanner = scanner
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextEntry_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextEntry_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (KeyValueAndPeek, KeyValueAndPeek.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = KeyValueAndPeek()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = NoMoreEntriesException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = UnknownScanner()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextEntry_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextK_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
      - k
     """
-    pass
 
-  def closeScanner(self, scanner):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+        (2, TType.I32, 'k', None, None, ),  # 2
+    )
+
+    def __init__(self, scanner=None, k=None,):
+        self.scanner = scanner
+        self.k = k
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I32:
+                    self.k = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextK_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        if self.k is not None:
+            oprot.writeFieldBegin('k', TType.I32, 2)
+            oprot.writeI32(self.k)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class nextK_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = ScanResult()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = NoMoreEntriesException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = UnknownScanner()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('nextK_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeScanner_args(object):
     """
-    Parameters:
+    Attributes:
      - scanner
     """
-    pass
 
-  def updateAndFlush(self, login, tableName, cells):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'scanner', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, scanner=None,):
+        self.scanner = scanner
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.scanner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeScanner_args')
+        if self.scanner is not None:
+            oprot.writeFieldBegin('scanner', TType.STRING, 1)
+            oprot.writeString(self.scanner.encode('utf-8') if sys.version_info[0] == 2 else self.scanner)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeScanner_result(object):
+    """
+    Attributes:
+     - ouch1
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ),  # 1
+    )
+
+    def __init__(self, ouch1=None,):
+        self.ouch1 = ouch1
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownScanner()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeScanner_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateAndFlush_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - cells
     """
-    pass
 
-  def createWriter(self, login, tableName, opts):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.MAP, 'cells', (TType.STRING, 'BINARY', TType.LIST, (TType.STRUCT, (ColumnUpdate, ColumnUpdate.thrift_spec), False), False), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, cells=None,):
+        self.login = login
+        self.tableName = tableName
+        self.cells = cells
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.MAP:
+                    self.cells = {}
+                    (_ktype391, _vtype392, _size390) = iprot.readMapBegin()
+                    for _i394 in range(_size390):
+                        _key395 = iprot.readBinary()
+                        _val396 = []
+                        (_etype400, _size397) = iprot.readListBegin()
+                        for _i401 in range(_size397):
+                            _elem402 = ColumnUpdate()
+                            _elem402.read(iprot)
+                            _val396.append(_elem402)
+                        iprot.readListEnd()
+                        self.cells[_key395] = _val396
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateAndFlush_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.cells is not None:
+            oprot.writeFieldBegin('cells', TType.MAP, 3)
+            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
+            for kiter403, viter404 in list(self.cells.items()):
+                oprot.writeBinary(kiter403)
+                oprot.writeListBegin(TType.STRUCT, len(viter404))
+                for iter405 in viter404:
+                    iter405.write(oprot)
+                oprot.writeListEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateAndFlush_result(object):
+    """
+    Attributes:
+     - outch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, outch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.outch1 = outch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.outch1 = AccumuloException()
+                    self.outch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = MutationsRejectedException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateAndFlush_result')
+        if self.outch1 is not None:
+            oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
+            self.outch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createWriter_args(object):
     """
-    Parameters:
+    Attributes:
      - login
      - tableName
      - opts
     """
-    pass
 
-  def update(self, writer, cells):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'opts', (WriterOptions, WriterOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, opts=None,):
+        self.login = login
+        self.tableName = tableName
+        self.opts = opts
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.opts = WriterOptions()
+                    self.opts.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createWriter_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.opts is not None:
+            oprot.writeFieldBegin('opts', TType.STRUCT, 3)
+            self.opts.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createWriter_result(object):
+    """
+    Attributes:
+     - success
+     - outch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, outch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.outch1 = outch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.outch1 = AccumuloException()
+                    self.outch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createWriter_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.outch1 is not None:
+            oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
+            self.outch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class update_args(object):
     """
-    Parameters:
+    Attributes:
      - writer
      - cells
     """
-    pass
 
-  def flush(self, writer):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'cells', (TType.STRING, 'BINARY', TType.LIST, (TType.STRUCT, (ColumnUpdate, ColumnUpdate.thrift_spec), False), False), None, ),  # 2
+    )
+
+    def __init__(self, writer=None, cells=None,):
+        self.writer = writer
+        self.cells = cells
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.writer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.cells = {}
+                    (_ktype407, _vtype408, _size406) = iprot.readMapBegin()
+                    for _i410 in range(_size406):
+                        _key411 = iprot.readBinary()
+                        _val412 = []
+                        (_etype416, _size413) = iprot.readListBegin()
+                        for _i417 in range(_size413):
+                            _elem418 = ColumnUpdate()
+                            _elem418.read(iprot)
+                            _val412.append(_elem418)
+                        iprot.readListEnd()
+                        self.cells[_key411] = _val412
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('update_args')
+        if self.writer is not None:
+            oprot.writeFieldBegin('writer', TType.STRING, 1)
+            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
+            oprot.writeFieldEnd()
+        if self.cells is not None:
+            oprot.writeFieldBegin('cells', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
+            for kiter419, viter420 in list(self.cells.items()):
+                oprot.writeBinary(kiter419)
+                oprot.writeListBegin(TType.STRUCT, len(viter420))
+                for iter421 in viter420:
+                    iter421.write(oprot)
+                oprot.writeListEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flush_args(object):
     """
-    Parameters:
+    Attributes:
      - writer
     """
-    pass
 
-  def closeWriter(self, writer):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, writer=None,):
+        self.writer = writer
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.writer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flush_args')
+        if self.writer is not None:
+            oprot.writeFieldBegin('writer', TType.STRING, 1)
+            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class flush_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownWriter()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = MutationsRejectedException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('flush_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeWriter_args(object):
     """
-    Parameters:
+    Attributes:
      - writer
     """
-    pass
 
-  def getRowRange(self, row):
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'writer', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, writer=None,):
+        self.writer = writer
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.writer = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeWriter_args')
+        if self.writer is not None:
+            oprot.writeFieldBegin('writer', TType.STRING, 1)
+            oprot.writeString(self.writer.encode('utf-8') if sys.version_info[0] == 2 else self.writer)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeWriter_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (MutationsRejectedException, MutationsRejectedException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, ouch1=None, ouch2=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownWriter()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = MutationsRejectedException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeWriter_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowConditionally_args(object):
     """
-    Parameters:
+    Attributes:
+     - login
+     - tableName
      - row
+     - updates
     """
-    pass
 
-  def getFollowing(self, key, part):
-    """
-    Parameters:
-     - key
-     - part
-    """
-    pass
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'row', 'BINARY', None, ),  # 3
+        (4, TType.STRUCT, 'updates', (ConditionalUpdates, ConditionalUpdates.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, login=None, tableName=None, row=None, updates=None,):
+        self.login = login
+        self.tableName = tableName
+        self.row = row
+        self.updates = updates
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.row = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.updates = ConditionalUpdates()
+                    self.updates.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowConditionally_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.row is not None:
+            oprot.writeFieldBegin('row', TType.STRING, 3)
+            oprot.writeBinary(self.row)
+            oprot.writeFieldEnd()
+        if self.updates is not None:
+            oprot.writeFieldBegin('updates', TType.STRUCT, 4)
+            self.updates.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowConditionally_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.I32, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowConditionally_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
+    def __ne__(self, other):
+        return not (self == other)
 
-class Client(Iface):
-  def __init__(self, iprot, oprot=None):
-    self._iprot = self._oprot = iprot
-    if oprot is not None:
-      self._oprot = oprot
-    self._seqid = 0
 
-  def login(self, principal, loginProperties):
-    """
-    Parameters:
-     - principal
-     - loginProperties
+class createConditionalWriter_args(object):
     """
-    self.send_login(principal, loginProperties)
-    return self.recv_login()
-
-  def send_login(self, principal, loginProperties):
-    self._oprot.writeMessageBegin('login', TMessageType.CALL, self._seqid)
-    args = login_args()
-    args.principal = principal
-    args.loginProperties = loginProperties
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_login(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = login_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");
-
-  def addConstraint(self, login, tableName, constraintClassName):
-    """
-    Parameters:
+    Attributes:
      - login
      - tableName
-     - constraintClassName
+     - options
     """
-    self.send_addConstraint(login, tableName, constraintClassName)
-    return self.recv_addConstraint()
 
-  def send_addConstraint(self, login, tableName, constraintClassName):
-    self._oprot.writeMessageBegin('addConstraint', TMessageType.CALL, self._seqid)
-    args = addConstraint_args()
-    args.login = login
-    args.tableName = tableName
-    args.constraintClassName = constraintClassName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_addConstraint(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = addConstraint_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "addConstraint failed: unknown result");
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'tableName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'options', (ConditionalWriterOptions, ConditionalWriterOptions.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, login=None, tableName=None, options=None,):
+        self.login = login
+        self.tableName = tableName
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.options = ConditionalWriterOptions()
+                    self.options.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createConditionalWriter_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.tableName is not None:
+            oprot.writeFieldBegin('tableName', TType.STRING, 2)
+            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.STRUCT, 3)
+            self.options.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createConditionalWriter_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = TableNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createConditionalWriter_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowsConditionally_args(object):
+    """
+    Attributes:
+     - conditionalWriter
+     - updates
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'conditionalWriter', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'updates', (TType.STRING, 'BINARY', TType.STRUCT, (ConditionalUpdates, ConditionalUpdates.thrift_spec), False), None, ),  # 2
+    )
+
+    def __init__(self, conditionalWriter=None, updates=None,):
+        self.conditionalWriter = conditionalWriter
+        self.updates = updates
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.conditionalWriter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.updates = {}
+                    (_ktype423, _vtype424, _size422) = iprot.readMapBegin()
+                    for _i426 in range(_size422):
+                        _key427 = iprot.readBinary()
+                        _val428 = ConditionalUpdates()
+                        _val428.read(iprot)
+                        self.updates[_key427] = _val428
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowsConditionally_args')
+        if self.conditionalWriter is not None:
+            oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
+            oprot.writeString(self.conditionalWriter.encode('utf-8') if sys.version_info[0] == 2 else self.conditionalWriter)
+            oprot.writeFieldEnd()
+        if self.updates is not None:
+            oprot.writeFieldBegin('updates', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.updates))
+            for kiter429, viter430 in list(self.updates.items()):
+                oprot.writeBinary(kiter429)
+                viter430.write(oprot)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class updateRowsConditionally_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'BINARY', TType.I32, None, False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype432, _vtype433, _size431) = iprot.readMapBegin()
+                    for _i435 in range(_size431):
+                        _key436 = iprot.readBinary()
+                        _val437 = iprot.readI32()
+                        self.success[_key436] = _val437
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = UnknownWriter()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = AccumuloSecurityException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('updateRowsConditionally_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
+            for kiter438, viter439 in list(self.success.items()):
+                oprot.writeBinary(kiter438)
+                oprot.writeI32(viter439)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeConditionalWriter_args(object):
+    """
+    Attributes:
+     - conditionalWriter
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'conditionalWriter', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, conditionalWriter=None,):
+        self.conditionalWriter = conditionalWriter
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.conditionalWriter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeConditionalWriter_args')
+        if self.conditionalWriter is not None:
+            oprot.writeFieldBegin('conditionalWriter', TType.STRING, 1)
+            oprot.writeString(self.conditionalWriter.encode('utf-8') if sys.version_info[0] == 2 else self.conditionalWriter)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class closeConditionalWriter_result(object):
+
+    thrift_spec = (
+    )
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('closeConditionalWriter_result')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def addSplits(self, login, tableName, splits):
-    """
-    Parameters:
-     - login
-     - tableName
-     - splits
-    """
-    self.send_addSplits(login, tableName, splits)
-    self.recv_addSplits()
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_addSplits(self, login, tableName, splits):
-    self._oprot.writeMessageBegin('addSplits', TMessageType.CALL, self._seqid)
-    args = addSplits_args()
-    args.login = login
-    args.tableName = tableName
-    args.splits = splits
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_addSplits(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = addSplits_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def attachIterator(self, login, tableName, setting, scopes):
+class getRowRange_args(object):
     """
-    Parameters:
-     - login
-     - tableName
-     - setting
-     - scopes
+    Attributes:
+     - row
     """
-    self.send_attachIterator(login, tableName, setting, scopes)
-    self.recv_attachIterator()
 
-  def send_attachIterator(self, login, tableName, setting, scopes):
-    self._oprot.writeMessageBegin('attachIterator', TMessageType.CALL, self._seqid)
-    args = attachIterator_args()
-    args.login = login
-    args.tableName = tableName
-    args.setting = setting
-    args.scopes = scopes
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_attachIterator(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = attachIterator_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, row=None,):
+        self.row = row
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.row = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getRowRange_args')
+        if self.row is not None:
+            oprot.writeFieldBegin('row', TType.STRING, 1)
+            oprot.writeBinary(self.row)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getRowRange_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (Range, Range.thrift_spec), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = Range()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getRowRange_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def checkIteratorConflicts(self, login, tableName, setting, scopes):
-    """
-    Parameters:
-     - login
-     - tableName
-     - setting
-     - scopes
-    """
-    self.send_checkIteratorConflicts(login, tableName, setting, scopes)
-    self.recv_checkIteratorConflicts()
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_checkIteratorConflicts(self, login, tableName, setting, scopes):
-    self._oprot.writeMessageBegin('checkIteratorConflicts', TMessageType.CALL, self._seqid)
-    args = checkIteratorConflicts_args()
-    args.login = login
-    args.tableName = tableName
-    args.setting = setting
-    args.scopes = scopes
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_checkIteratorConflicts(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = checkIteratorConflicts_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
 
-  def clearLocatorCache(self, login, tableName):
+class getFollowing_args(object):
     """
-    Parameters:
-     - login
-     - tableName
+    Attributes:
+     - key
+     - part
     """
-    self.send_clearLocatorCache(login, tableName)
-    self.recv_clearLocatorCache()
-
-  def send_clearLocatorCache(self, login, tableName):
-    self._oprot.writeMessageBegin('clearLocatorCache', TMessageType.CALL, self._seqid)
-    args = clearLocatorCache_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_clearLocatorCache(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = clearLocatorCache_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    return
 
-  def cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
-    """
-    Parameters:
-     - login
-     - tableName
-     - newTableName
-     - flush
-     - propertiesToSet
-     - propertiesToExclude
-    """
-    self.send_cloneTable(login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude)
-    self.recv_cloneTable()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ),  # 1
+        (2, TType.I32, 'part', None, None, ),  # 2
+    )
+
+    def __init__(self, key=None, part=None,):
+        self.key = key
+        self.part = part
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.key = Key()
+                    self.key.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I32:
+                    self.part = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getFollowing_args')
+        if self.key is not None:
+            oprot.writeFieldBegin('key', TType.STRUCT, 1)
+            self.key.write(oprot)
+            oprot.writeFieldEnd()
+        if self.part is not None:
+            oprot.writeFieldBegin('part', TType.I32, 2)
+            oprot.writeI32(self.part)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getFollowing_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (Key, Key.thrift_spec), None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = Key()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getFollowing_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class systemNamespace_args(object):
+
+    thrift_spec = (
+    )
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('systemNamespace_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class systemNamespace_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('systemNamespace_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class defaultNamespace_args(object):
+
+    thrift_spec = (
+    )
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('defaultNamespace_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class defaultNamespace_result(object):
+    """
+    Attributes:
+     - success
+    """
+
+    thrift_spec = (
+        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
+    )
+
+    def __init__(self, success=None,):
+        self.success = success
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('defaultNamespace_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaces_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaces_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaces_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_etype443, _size440) = iprot.readListBegin()
+                    for _i444 in range(_size440):
+                        _elem445 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success.append(_elem445)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaces_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.STRING, len(self.success))
+            for iter446 in self.success:
+                oprot.writeString(iter446.encode('utf-8') if sys.version_info[0] == 2 else iter446)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceExists_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceExists_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceExists_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceExists_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createNamespace_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createNamespace_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class createNamespace_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceExistsException, NamespaceExistsException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceExistsException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('createNamespace_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteNamespace_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteNamespace_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class deleteNamespace_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (NamespaceNotEmptyException, NamespaceNotEmptyException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = NamespaceNotEmptyException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('deleteNamespace_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameNamespace_args(object):
+    """
+    Attributes:
+     - login
+     - oldNamespaceName
+     - newNamespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'oldNamespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'newNamespaceName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, oldNamespaceName=None, newNamespaceName=None,):
+        self.login = login
+        self.oldNamespaceName = oldNamespaceName
+        self.newNamespaceName = newNamespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.oldNamespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.newNamespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameNamespace_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.oldNamespaceName is not None:
+            oprot.writeFieldBegin('oldNamespaceName', TType.STRING, 2)
+            oprot.writeString(self.oldNamespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.oldNamespaceName)
+            oprot.writeFieldEnd()
+        if self.newNamespaceName is not None:
+            oprot.writeFieldBegin('newNamespaceName', TType.STRING, 3)
+            oprot.writeString(self.newNamespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.newNamespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class renameNamespace_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+     - ouch4
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+        (4, TType.STRUCT, 'ouch4', (NamespaceExistsException, NamespaceExistsException.thrift_spec), None, ),  # 4
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+        self.ouch4 = ouch4
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRUCT:
+                    self.ouch4 = NamespaceExistsException()
+                    self.ouch4.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('renameNamespace_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch4 is not None:
+            oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
+            self.ouch4.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_cloneTable(self, login, tableName, newTableName, flush, propertiesToSet, propertiesToExclude):
-    self._oprot.writeMessageBegin('cloneTable', TMessageType.CALL, self._seqid)
-    args = cloneTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.newTableName = newTableName
-    args.flush = flush
-    args.propertiesToSet = propertiesToSet
-    args.propertiesToExclude = propertiesToExclude
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_cloneTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = cloneTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    if result.ouch4 is not None:
-      raise result.ouch4
-    return
 
-  def compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
+class setNamespaceProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - startRow
-     - endRow
-     - iterators
-     - flush
-     - wait
+     - namespaceName
+     - property
+     - value
     """
-    self.send_compactTable(login, tableName, startRow, endRow, iterators, flush, wait)
-    self.recv_compactTable()
 
-  def send_compactTable(self, login, tableName, startRow, endRow, iterators, flush, wait):
-    self._oprot.writeMessageBegin('compactTable', TMessageType.CALL, self._seqid)
-    args = compactTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.iterators = iterators
-    args.flush = flush
-    args.wait = wait
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_compactTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = compactTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def cancelCompaction(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_cancelCompaction(login, tableName)
-    self.recv_cancelCompaction()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'value', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, property=None, value=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.property = property
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setNamespaceProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 4)
+            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class setNamespaceProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('setNamespaceProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_cancelCompaction(self, login, tableName):
-    self._oprot.writeMessageBegin('cancelCompaction', TMessageType.CALL, self._seqid)
-    args = cancelCompaction_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_cancelCompaction(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = cancelCompaction_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def createTable(self, login, tableName, versioningIter, type):
+class removeNamespaceProperty_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - versioningIter
-     - type
+     - namespaceName
+     - property
     """
-    self.send_createTable(login, tableName, versioningIter, type)
-    self.recv_createTable()
-
-  def send_createTable(self, login, tableName, versioningIter, type):
-    self._oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
-    args = createTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.versioningIter = versioningIter
-    args.type = type
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def deleteTable(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_deleteTable(login, tableName)
-    self.recv_deleteTable()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'property', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, namespaceName=None, property=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.property = property
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.property = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceProperty_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.property is not None:
+            oprot.writeFieldBegin('property', TType.STRING, 3)
+            oprot.writeString(self.property.encode('utf-8') if sys.version_info[0] == 2 else self.property)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceProperty_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceProperty_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getNamespaceProperties_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceProperties_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getNamespaceProperties_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype448, _vtype449, _size447) = iprot.readMapBegin()
+                    for _i451 in range(_size447):
+                        _key452 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val453 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key452] = _val453
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceProperties_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter454, viter455 in list(self.success.items()):
+                oprot.writeString(kiter454.encode('utf-8') if sys.version_info[0] == 2 else kiter454)
+                oprot.writeString(viter455.encode('utf-8') if sys.version_info[0] == 2 else viter455)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceIdMap_args(object):
+    """
+    Attributes:
+     - login
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+    )
+
+    def __init__(self, login=None,):
+        self.login = login
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceIdMap_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class namespaceIdMap_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype457, _vtype458, _size456) = iprot.readMapBegin()
+                    for _i460 in range(_size456):
+                        _key461 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val462 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.success[_key461] = _val462
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('namespaceIdMap_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
+            for kiter463, viter464 in list(self.success.items()):
+                oprot.writeString(kiter463.encode('utf-8') if sys.version_info[0] == 2 else kiter463)
+                oprot.writeString(viter464.encode('utf-8') if sys.version_info[0] == 2 else viter464)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_deleteTable(self, login, tableName):
-    self._oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
-    args = deleteTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_deleteTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = deleteTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def deleteRows(self, login, tableName, startRow, endRow):
+class attachNamespaceIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - startRow
-     - endRow
+     - namespaceName
+     - setting
+     - scopes
     """
-    self.send_deleteRows(login, tableName, startRow, endRow)
-    self.recv_deleteRows()
-
-  def send_deleteRows(self, login, tableName, startRow, endRow):
-    self._oprot.writeMessageBegin('deleteRows', TMessageType.CALL, self._seqid)
-    args = deleteRows_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_deleteRows(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = deleteRows_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def exportTable(self, login, tableName, exportDir):
-    """
-    Parameters:
-     - login
-     - tableName
-     - exportDir
-    """
-    self.send_exportTable(login, tableName, exportDir)
-    self.recv_exportTable()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, setting=None, scopes=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype468, _size465) = iprot.readSetBegin()
+                    for _i469 in range(_size465):
+                        _elem470 = iprot.readI32()
+                        self.scopes.add(_elem470)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachNamespaceIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter471 in self.scopes:
+                oprot.writeI32(iter471)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class attachNamespaceIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('attachNamespaceIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_exportTable(self, login, tableName, exportDir):
-    self._oprot.writeMessageBegin('exportTable', TMessageType.CALL, self._seqid)
-    args = exportTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.exportDir = exportDir
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_exportTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = exportTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def flushTable(self, login, tableName, startRow, endRow, wait):
+class removeNamespaceIterator_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - startRow
-     - endRow
-     - wait
+     - namespaceName
+     - name
+     - scopes
     """
-    self.send_flushTable(login, tableName, startRow, endRow, wait)
-    self.recv_flushTable()
 
-  def send_flushTable(self, login, tableName, startRow, endRow, wait):
-    self._oprot.writeMessageBegin('flushTable', TMessageType.CALL, self._seqid)
-    args = flushTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.wait = wait
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_flushTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = flushTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, name=None, scopes=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.name = name
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype475, _size472) = iprot.readSetBegin()
+                    for _i476 in range(_size472):
+                        _elem477 = iprot.readI32()
+                        self.scopes.add(_elem477)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceIterator_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 3)
+            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter478 in self.scopes:
+                oprot.writeI32(iter478)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceIterator_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceIterator_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def getLocalityGroups(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_getLocalityGroups(login, tableName)
-    return self.recv_getLocalityGroups()
 
-  def send_getLocalityGroups(self, login, tableName):
-    self._oprot.writeMessageBegin('getLocalityGroups', TMessageType.CALL, self._seqid)
-    args = getLocalityGroups_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getLocalityGroups(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getLocalityGroups_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getLocalityGroups failed: unknown result");
-
-  def getIteratorSetting(self, login, tableName, iteratorName, scope):
+class getNamespaceIteratorSetting_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - iteratorName
+     - namespaceName
+     - name
      - scope
     """
-    self.send_getIteratorSetting(login, tableName, iteratorName, scope)
-    return self.recv_getIteratorSetting()
-
-  def send_getIteratorSetting(self, login, tableName, iteratorName, scope):
-    self._oprot.writeMessageBegin('getIteratorSetting', TMessageType.CALL, self._seqid)
-    args = getIteratorSetting_args()
-    args.login = login
-    args.tableName = tableName
-    args.iteratorName = iteratorName
-    args.scope = scope
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getIteratorSetting(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getIteratorSetting_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getIteratorSetting failed: unknown result");
-
-  def getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
-    """
-    Parameters:
-     - login
-     - tableName
-     - auths
-     - startRow
-     - startInclusive
-     - endRow
-     - endInclusive
-    """
-    self.send_getMaxRow(login, tableName, auths, startRow, startInclusive, endRow, endInclusive)
-    return self.recv_getMaxRow()
-
-  def send_getMaxRow(self, login, tableName, auths, startRow, startInclusive, endRow, endInclusive):
-    self._oprot.writeMessageBegin('getMaxRow', TMessageType.CALL, self._seqid)
-    args = getMaxRow_args()
-    args.login = login
-    args.tableName = tableName
-    args.auths = auths
-    args.startRow = startRow
-    args.startInclusive = startInclusive
-    args.endRow = endRow
-    args.endInclusive = endInclusive
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getMaxRow(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getMaxRow_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getMaxRow failed: unknown result");
-
-  def getTableProperties(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_getTableProperties(login, tableName)
-    return self.recv_getTableProperties()
-
-  def send_getTableProperties(self, login, tableName):
-    self._oprot.writeMessageBegin('getTableProperties', TMessageType.CALL, self._seqid)
-    args = getTableProperties_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getTableProperties(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getTableProperties_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTableProperties failed: unknown result");
-
-  def getSplits(self, login, tableName, maxSplits):
-    """
-    Parameters:
-     - login
-     - tableName
-     - maxSplits
-    """
-    self.send_getSplits(login, tableName, maxSplits)
-    return self.recv_getSplits()
-
-  def send_getSplits(self, login, tableName, maxSplits):
-    self._oprot.writeMessageBegin('getSplits', TMessageType.CALL, self._seqid)
-    args = getSplits_args()
-    args.login = login
-    args.tableName = tableName
-    args.maxSplits = maxSplits
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getSplits(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getSplits_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSplits failed: unknown result");
-
-  def importDirectory(self, login, tableName, importDir, failureDir, setTime):
-    """
-    Parameters:
-     - login
-     - tableName
-     - importDir
-     - failureDir
-     - setTime
-    """
-    self.send_importDirectory(login, tableName, importDir, failureDir, setTime)
-    self.recv_importDirectory()
-
-  def send_importDirectory(self, login, tableName, importDir, failureDir, setTime):
-    self._oprot.writeMessageBegin('importDirectory', TMessageType.CALL, self._seqid)
-    args = importDirectory_args()
-    args.login = login
-    args.tableName = tableName
-    args.importDir = importDir
-    args.failureDir = failureDir
-    args.setTime = setTime
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_importDirectory(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = importDirectory_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch3 is not None:
-      raise result.ouch3
-    if result.ouch4 is not None:
-      raise result.ouch4
-    return
-
-  def importTable(self, login, tableName, importDir):
-    """
-    Parameters:
-     - login
-     - tableName
-     - importDir
-    """
-    self.send_importTable(login, tableName, importDir)
-    self.recv_importTable()
-
-  def send_importTable(self, login, tableName, importDir):
-    self._oprot.writeMessageBegin('importTable', TMessageType.CALL, self._seqid)
-    args = importTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.importDir = importDir
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_importTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = importTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def listTables(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_listTables(login)
-    return self.recv_listTables()
-
-  def send_listTables(self, login):
-    self._oprot.writeMessageBegin('listTables', TMessageType.CALL, self._seqid)
-    args = listTables_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listTables(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listTables_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listTables failed: unknown result");
-
-  def listIterators(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_listIterators(login, tableName)
-    return self.recv_listIterators()
-
-  def send_listIterators(self, login, tableName):
-    self._oprot.writeMessageBegin('listIterators', TMessageType.CALL, self._seqid)
-    args = listIterators_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listIterators(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listIterators_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listIterators failed: unknown result");
-
-  def listConstraints(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_listConstraints(login, tableName)
-    return self.recv_listConstraints()
-
-  def send_listConstraints(self, login, tableName):
-    self._oprot.writeMessageBegin('listConstraints', TMessageType.CALL, self._seqid)
-    args = listConstraints_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listConstraints(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listConstraints_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listConstraints failed: unknown result");
-
-  def mergeTablets(self, login, tableName, startRow, endRow):
-    """
-    Parameters:
-     - login
-     - tableName
-     - startRow
-     - endRow
-    """
-    self.send_mergeTablets(login, tableName, startRow, endRow)
-    self.recv_mergeTablets()
-
-  def send_mergeTablets(self, login, tableName, startRow, endRow):
-    self._oprot.writeMessageBegin('mergeTablets', TMessageType.CALL, self._seqid)
-    args = mergeTablets_args()
-    args.login = login
-    args.tableName = tableName
-    args.startRow = startRow
-    args.endRow = endRow
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_mergeTablets(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = mergeTablets_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def offlineTable(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_offlineTable(login, tableName)
-    self.recv_offlineTable()
-
-  def send_offlineTable(self, login, tableName):
-    self._oprot.writeMessageBegin('offlineTable', TMessageType.CALL, self._seqid)
-    args = offlineTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_offlineTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = offlineTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def onlineTable(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_onlineTable(login, tableName)
-    self.recv_onlineTable()
-
-  def send_onlineTable(self, login, tableName):
-    self._oprot.writeMessageBegin('onlineTable', TMessageType.CALL, self._seqid)
-    args = onlineTable_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_onlineTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = onlineTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
 
-  def removeConstraint(self, login, tableName, constraint):
-    """
-    Parameters:
-     - login
-     - tableName
-     - constraint
-    """
-    self.send_removeConstraint(login, tableName, constraint)
-    self.recv_removeConstraint()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
+        (4, TType.I32, 'scope', None, None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, name=None, scope=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.name = name
+        self.scope = scope
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.scope = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceIteratorSetting_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 3)
+            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldEnd()
+        if self.scope is not None:
+            oprot.writeFieldBegin('scope', TType.I32, 4)
+            oprot.writeI32(self.scope)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class getNamespaceIteratorSetting_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = IteratorSetting()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('getNamespaceIteratorSetting_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceIterators_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceIterators_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceIterators_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.SET, (TType.I32, None, False), False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype480, _vtype481, _size479) = iprot.readMapBegin()
+                    for _i483 in range(_size479):
+                        _key484 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val485 = set()
+                        (_etype489, _size486) = iprot.readSetBegin()
+                        for _i490 in range(_size486):
+                            _elem491 = iprot.readI32()
+                            _val485.add(_elem491)
+                        iprot.readSetEnd()
+                        self.success[_key484] = _val485
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceIterators_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
+            for kiter492, viter493 in list(self.success.items()):
+                oprot.writeString(kiter492.encode('utf-8') if sys.version_info[0] == 2 else kiter492)
+                oprot.writeSetBegin(TType.I32, len(viter493))
+                for iter494 in viter493:
+                    oprot.writeI32(iter494)
+                oprot.writeSetEnd()
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_removeConstraint(self, login, tableName, constraint):
-    self._oprot.writeMessageBegin('removeConstraint', TMessageType.CALL, self._seqid)
-    args = removeConstraint_args()
-    args.login = login
-    args.tableName = tableName
-    args.constraint = constraint
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeConstraint(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeConstraint_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
 
-  def removeIterator(self, login, tableName, iterName, scopes):
+class checkNamespaceIteratorConflicts_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - tableName
-     - iterName
+     - namespaceName
+     - setting
      - scopes
     """
-    self.send_removeIterator(login, tableName, iterName, scopes)
-    self.recv_removeIterator()
-
-  def send_removeIterator(self, login, tableName, iterName, scopes):
-    self._oprot.writeMessageBegin('removeIterator', TMessageType.CALL, self._seqid)
-    args = removeIterator_args()
-    args.login = login
-    args.tableName = tableName
-    args.iterName = iterName
-    args.scopes = scopes
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeIterator(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeIterator_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def removeTableProperty(self, login, tableName, property):
-    """
-    Parameters:
-     - login
-     - tableName
-     - property
-    """
-    self.send_removeTableProperty(login, tableName, property)
-    self.recv_removeTableProperty()
-
-  def send_removeTableProperty(self, login, tableName, property):
-    self._oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
-    args = removeTableProperty_args()
-    args.login = login
-    args.tableName = tableName
-    args.property = property
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeTableProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeTableProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def renameTable(self, login, oldTableName, newTableName):
-    """
-    Parameters:
-     - login
-     - oldTableName
-     - newTableName
-    """
-    self.send_renameTable(login, oldTableName, newTableName)
-    self.recv_renameTable()
-
-  def send_renameTable(self, login, oldTableName, newTableName):
-    self._oprot.writeMessageBegin('renameTable', TMessageType.CALL, self._seqid)
-    args = renameTable_args()
-    args.login = login
-    args.oldTableName = oldTableName
-    args.newTableName = newTableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_renameTable(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = renameTable_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    if result.ouch4 is not None:
-      raise result.ouch4
-    return
-
-  def setLocalityGroups(self, login, tableName, groups):
-    """
-    Parameters:
-     - login
-     - tableName
-     - groups
-    """
-    self.send_setLocalityGroups(login, tableName, groups)
-    self.recv_setLocalityGroups()
-
-  def send_setLocalityGroups(self, login, tableName, groups):
-    self._oprot.writeMessageBegin('setLocalityGroups', TMessageType.CALL, self._seqid)
-    args = setLocalityGroups_args()
-    args.login = login
-    args.tableName = tableName
-    args.groups = groups
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_setLocalityGroups(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = setLocalityGroups_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    return
-
-  def setTableProperty(self, login, tableName, property, value):
-    """
-    Parameters:
-     - login
-     - tableName
-     - property
-     - value
-    """
-    self.send_setTableProperty(login, tableName, property, value)
-    self.recv_setTableProperty()
-
-  def send_setTableProperty(self, login, tableName, property, value):
-    self._oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
-    args = setTableProperty_args()
-    args.login = login
-    args.tableName = tableName
-    args.property = property
-    args.value = value
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_setTableProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = setTableProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def splitRangeByTablets(self, login, tableName, range, maxSplits):
-    """
-    Parameters:
-     - login
-     - tableName
-     - range
-     - maxSplits
-    """
-    self.send_splitRangeByTablets(login, tableName, range, maxSplits)
-    return self.recv_splitRangeByTablets()
-
-  def send_splitRangeByTablets(self, login, tableName, range, maxSplits):
-    self._oprot.writeMessageBegin('splitRangeByTablets', TMessageType.CALL, self._seqid)
-    args = splitRangeByTablets_args()
-    args.login = login
-    args.tableName = tableName
-    args.range = range
-    args.maxSplits = maxSplits
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_splitRangeByTablets(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = splitRangeByTablets_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "splitRangeByTablets failed: unknown result");
-
-  def tableExists(self, login, tableName):
-    """
-    Parameters:
-     - login
-     - tableName
-    """
-    self.send_tableExists(login, tableName)
-    return self.recv_tableExists()
-
-  def send_tableExists(self, login, tableName):
-    self._oprot.writeMessageBegin('tableExists', TMessageType.CALL, self._seqid)
-    args = tableExists_args()
-    args.login = login
-    args.tableName = tableName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_tableExists(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = tableExists_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "tableExists failed: unknown result");
-
-  def tableIdMap(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_tableIdMap(login)
-    return self.recv_tableIdMap()
-
-  def send_tableIdMap(self, login):
-    self._oprot.writeMessageBegin('tableIdMap', TMessageType.CALL, self._seqid)
-    args = tableIdMap_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_tableIdMap(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = tableIdMap_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIdMap failed: unknown result");
-
-  def pingTabletServer(self, login, tserver):
-    """
-    Parameters:
-     - login
-     - tserver
-    """
-    self.send_pingTabletServer(login, tserver)
-    self.recv_pingTabletServer()
-
-  def send_pingTabletServer(self, login, tserver):
-    self._oprot.writeMessageBegin('pingTabletServer', TMessageType.CALL, self._seqid)
-    args = pingTabletServer_args()
-    args.login = login
-    args.tserver = tserver
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_pingTabletServer(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = pingTabletServer_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def getActiveScans(self, login, tserver):
-    """
-    Parameters:
-     - login
-     - tserver
-    """
-    self.send_getActiveScans(login, tserver)
-    return self.recv_getActiveScans()
-
-  def send_getActiveScans(self, login, tserver):
-    self._oprot.writeMessageBegin('getActiveScans', TMessageType.CALL, self._seqid)
-    args = getActiveScans_args()
-    args.login = login
-    args.tserver = tserver
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getActiveScans(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getActiveScans_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveScans failed: unknown result");
 
-  def getActiveCompactions(self, login, tserver):
-    """
-    Parameters:
-     - login
-     - tserver
-    """
-    self.send_getActiveCompactions(login, tserver)
-    return self.recv_getActiveCompactions()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ),  # 3
+        (4, TType.SET, 'scopes', (TType.I32, None, False), None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, setting=None, scopes=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.setting = setting
+        self.scopes = scopes
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.setting = IteratorSetting()
+                    self.setting.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.scopes = set()
+                    (_etype498, _size495) = iprot.readSetBegin()
+                    for _i499 in range(_size495):
+                        _elem500 = iprot.readI32()
+                        self.scopes.add(_elem500)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkNamespaceIteratorConflicts_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.setting is not None:
+            oprot.writeFieldBegin('setting', TType.STRUCT, 3)
+            self.setting.write(oprot)
+            oprot.writeFieldEnd()
+        if self.scopes is not None:
+            oprot.writeFieldBegin('scopes', TType.SET, 4)
+            oprot.writeSetBegin(TType.I32, len(self.scopes))
+            for iter501 in self.scopes:
+                oprot.writeI32(iter501)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class checkNamespaceIteratorConflicts_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('checkNamespaceIteratorConflicts_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_getActiveCompactions(self, login, tserver):
-    self._oprot.writeMessageBegin('getActiveCompactions', TMessageType.CALL, self._seqid)
-    args = getActiveCompactions_args()
-    args.login = login
-    args.tserver = tserver
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getActiveCompactions(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getActiveCompactions_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getActiveCompactions failed: unknown result");
-
-  def getSiteConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_getSiteConfiguration(login)
-    return self.recv_getSiteConfiguration()
-
-  def send_getSiteConfiguration(self, login):
-    self._oprot.writeMessageBegin('getSiteConfiguration', TMessageType.CALL, self._seqid)
-    args = getSiteConfiguration_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getSiteConfiguration(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getSiteConfiguration_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSiteConfiguration failed: unknown result");
-
-  def getSystemConfiguration(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_getSystemConfiguration(login)
-    return self.recv_getSystemConfiguration()
-
-  def send_getSystemConfiguration(self, login):
-    self._oprot.writeMessageBegin('getSystemConfiguration', TMessageType.CALL, self._seqid)
-    args = getSystemConfiguration_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getSystemConfiguration(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getSystemConfiguration_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSystemConfiguration failed: unknown result");
-
-  def getTabletServers(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_getTabletServers(login)
-    return self.recv_getTabletServers()
-
-  def send_getTabletServers(self, login):
-    self._oprot.writeMessageBegin('getTabletServers', TMessageType.CALL, self._seqid)
-    args = getTabletServers_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getTabletServers(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getTabletServers_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTabletServers failed: unknown result");
 
-  def removeProperty(self, login, property):
+class addNamespaceConstraint_args(object):
     """
-    Parameters:
+    Attributes:
      - login
-     - property
+     - namespaceName
+     - constraintClassName
     """
-    self.send_removeProperty(login, property)
-    self.recv_removeProperty()
 
-  def send_removeProperty(self, login, property):
-    self._oprot.writeMessageBegin('removeProperty', TMessageType.CALL, self._seqid)
-    args = removeProperty_args()
-    args.login = login
-    args.property = property
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_removeProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = removeProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def setProperty(self, login, property, value):
-    """
-    Parameters:
-     - login
-     - property
-     - value
-    """
-    self.send_setProperty(login, property, value)
-    self.recv_setProperty()
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'constraintClassName', 'UTF8', None, ),  # 3
+    )
+
+    def __init__(self, login=None, namespaceName=None, constraintClassName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.constraintClassName = constraintClassName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.constraintClassName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addNamespaceConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.constraintClassName is not None:
+            oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
+            oprot.writeString(self.constraintClassName.encode('utf-8') if sys.version_info[0] == 2 else self.constraintClassName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class addNamespaceConstraint_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.I32, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('addNamespaceConstraint_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceConstraint_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+     - id
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.I32, 'id', None, None, ),  # 3
+    )
+
+    def __init__(self, login=None, namespaceName=None, id=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.id = id
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.id = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceConstraint_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.id is not None:
+            oprot.writeFieldBegin('id', TType.I32, 3)
+            oprot.writeI32(self.id)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class removeNamespaceConstraint_result(object):
+    """
+    Attributes:
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('removeNamespaceConstraint_result')
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceConstraints_args(object):
+    """
+    Attributes:
+     - login
+     - namespaceName
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+    )
+
+    def __init__(self, login=None, namespaceName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceConstraints_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class listNamespaceConstraints_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.MAP:
+                    self.success = {}
+                    (_ktype503, _vtype504, _size502) = iprot.readMapBegin()
+                    for _i506 in range(_size502):
+                        _key507 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val508 = iprot.readI32()
+                        self.success[_key507] = _val508
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('listNamespaceConstraints_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
+            for kiter509, viter510 in list(self.success.items()):
+                oprot.writeString(kiter509.encode('utf-8') if sys.version_info[0] == 2 else kiter509)
+                oprot.writeI32(viter510)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def send_setProperty(self, login, property, value):
-    self._oprot.writeMessageBegin('setProperty', TMessageType.CALL, self._seqid)
-    args = setProperty_args()
-    args.login = login
-    args.property = property
-    args.value = value
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_setProperty(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = setProperty_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
 
-  def testClassLoad(self, login, className, asTypeName):
+class testNamespaceClassLoad_args(object):
     """
-    Parameters:
+    Attributes:
      - login
+     - namespaceName
      - className
      - asTypeName
     """
-    self.send_testClassLoad(login, className, asTypeName)
-    return self.recv_testClassLoad()
-
-  def send_testClassLoad(self, login, className, asTypeName):
-    self._oprot.writeMessageBegin('testClassLoad', TMessageType.CALL, self._seqid)
-    args = testClassLoad_args()
-    args.login = login
-    args.className = className
-    args.asTypeName = asTypeName
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_testClassLoad(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = testClassLoad_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "testClassLoad failed: unknown result");
-
-  def authenticateUser(self, login, user, properties):
-    """
-    Parameters:
-     - login
-     - user
-     - properties
-    """
-    self.send_authenticateUser(login, user, properties)
-    return self.recv_authenticateUser()
-
-  def send_authenticateUser(self, login, user, properties):
-    self._oprot.writeMessageBegin('authenticateUser', TMessageType.CALL, self._seqid)
-    args = authenticateUser_args()
-    args.login = login
-    args.user = user
-    args.properties = properties
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_authenticateUser(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = authenticateUser_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticateUser failed: unknown result");
-
-  def changeUserAuthorizations(self, login, user, authorizations):
-    """
-    Parameters:
-     - login
-     - user
-     - authorizations
-    """
-    self.send_changeUserAuthorizations(login, user, authorizations)
-    self.recv_changeUserAuthorizations()
-
-  def send_changeUserAuthorizations(self, login, user, authorizations):
-    self._oprot.writeMessageBegin('changeUserAuthorizations', TMessageType.CALL, self._seqid)
-    args = changeUserAuthorizations_args()
-    args.login = login
-    args.user = user
-    args.authorizations = authorizations
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_changeUserAuthorizations(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = changeUserAuthorizations_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def changeLocalUserPassword(self, login, user, password):
-    """
-    Parameters:
-     - login
-     - user
-     - password
-    """
-    self.send_changeLocalUserPassword(login, user, password)
-    self.recv_changeLocalUserPassword()
-
-  def send_changeLocalUserPassword(self, login, user, password):
-    self._oprot.writeMessageBegin('changeLocalUserPassword', TMessageType.CALL, self._seqid)
-    args = changeLocalUserPassword_args()
-    args.login = login
-    args.user = user
-    args.password = password
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_changeLocalUserPassword(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = changeLocalUserPassword_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def createLocalUser(self, login, user, password):
-    """
-    Parameters:
-     - login
-     - user
-     - password
-    """
-    self.send_createLocalUser(login, user, password)
-    self.recv_createLocalUser()
 
-  def send_createLocalUser(self, login, user, password):
-    self._oprot.writeMessageBegin('createLocalUser', TMessageType.CALL, self._seqid)
-    args = createLocalUser_args()
-    args.login = login
-    args.user = user
-    args.password = password
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createLocalUser(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createLocalUser_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def dropLocalUser(self, login, user):
-    """
-    Parameters:
-     - login
-     - user
-    """
-    self.send_dropLocalUser(login, user)
-    self.recv_dropLocalUser()
-
-  def send_dropLocalUser(self, login, user):
-    self._oprot.writeMessageBegin('dropLocalUser', TMessageType.CALL, self._seqid)
-    args = dropLocalUser_args()
-    args.login = login
-    args.user = user
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_dropLocalUser(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = dropLocalUser_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def getUserAuthorizations(self, login, user):
-    """
-    Parameters:
-     - login
-     - user
-    """
-    self.send_getUserAuthorizations(login, user)
-    return self.recv_getUserAuthorizations()
-
-  def send_getUserAuthorizations(self, login, user):
-    self._oprot.writeMessageBegin('getUserAuthorizations', TMessageType.CALL, self._seqid)
-    args = getUserAuthorizations_args()
-    args.login = login
-    args.user = user
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getUserAuthorizations(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getUserAuthorizations_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getUserAuthorizations failed: unknown result");
-
-  def grantSystemPermission(self, login, user, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - perm
-    """
-    self.send_grantSystemPermission(login, user, perm)
-    self.recv_grantSystemPermission()
-
-  def send_grantSystemPermission(self, login, user, perm):
-    self._oprot.writeMessageBegin('grantSystemPermission', TMessageType.CALL, self._seqid)
-    args = grantSystemPermission_args()
-    args.login = login
-    args.user = user
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_grantSystemPermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = grantSystemPermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def grantTablePermission(self, login, user, table, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - table
-     - perm
-    """
-    self.send_grantTablePermission(login, user, table, perm)
-    self.recv_grantTablePermission()
-
-  def send_grantTablePermission(self, login, user, table, perm):
-    self._oprot.writeMessageBegin('grantTablePermission', TMessageType.CALL, self._seqid)
-    args = grantTablePermission_args()
-    args.login = login
-    args.user = user
-    args.table = table
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_grantTablePermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = grantTablePermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def hasSystemPermission(self, login, user, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - perm
-    """
-    self.send_hasSystemPermission(login, user, perm)
-    return self.recv_hasSystemPermission()
-
-  def send_hasSystemPermission(self, login, user, perm):
-    self._oprot.writeMessageBegin('hasSystemPermission', TMessageType.CALL, self._seqid)
-    args = hasSystemPermission_args()
-    args.login = login
-    args.user = user
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_hasSystemPermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = hasSystemPermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "hasSystemPermission failed: unknown result");
-
-  def hasTablePermission(self, login, user, table, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - table
-     - perm
-    """
-    self.send_hasTablePermission(login, user, table, perm)
-    return self.recv_hasTablePermission()
-
-  def send_hasTablePermission(self, login, user, table, perm):
-    self._oprot.writeMessageBegin('hasTablePermission', TMessageType.CALL, self._seqid)
-    args = hasTablePermission_args()
-    args.login = login
-    args.user = user
-    args.table = table
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_hasTablePermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = hasTablePermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "hasTablePermission failed: unknown result");
-
-  def listLocalUsers(self, login):
-    """
-    Parameters:
-     - login
-    """
-    self.send_listLocalUsers(login)
-    return self.recv_listLocalUsers()
-
-  def send_listLocalUsers(self, login):
-    self._oprot.writeMessageBegin('listLocalUsers', TMessageType.CALL, self._seqid)
-    args = listLocalUsers_args()
-    args.login = login
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_listLocalUsers(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = listLocalUsers_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "listLocalUsers failed: unknown result");
-
-  def revokeSystemPermission(self, login, user, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - perm
-    """
-    self.send_revokeSystemPermission(login, user, perm)
-    self.recv_revokeSystemPermission()
-
-  def send_revokeSystemPermission(self, login, user, perm):
-    self._oprot.writeMessageBegin('revokeSystemPermission', TMessageType.CALL, self._seqid)
-    args = revokeSystemPermission_args()
-    args.login = login
-    args.user = user
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_revokeSystemPermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = revokeSystemPermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def revokeTablePermission(self, login, user, table, perm):
-    """
-    Parameters:
-     - login
-     - user
-     - table
-     - perm
-    """
-    self.send_revokeTablePermission(login, user, table, perm)
-    self.recv_revokeTablePermission()
-
-  def send_revokeTablePermission(self, login, user, table, perm):
-    self._oprot.writeMessageBegin('revokeTablePermission', TMessageType.CALL, self._seqid)
-    args = revokeTablePermission_args()
-    args.login = login
-    args.user = user
-    args.table = table
-    args.perm = perm
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_revokeTablePermission(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = revokeTablePermission_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def createBatchScanner(self, login, tableName, options):
-    """
-    Parameters:
-     - login
-     - tableName
-     - options
-    """
-    self.send_createBatchScanner(login, tableName, options)
-    return self.recv_createBatchScanner()
-
-  def send_createBatchScanner(self, login, tableName, options):
-    self._oprot.writeMessageBegin('createBatchScanner', TMessageType.CALL, self._seqid)
-    args = createBatchScanner_args()
-    args.login = login
-    args.tableName = tableName
-    args.options = options
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createBatchScanner(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createBatchScanner_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "createBatchScanner failed: unknown result");
-
-  def createScanner(self, login, tableName, options):
-    """
-    Parameters:
-     - login
-     - tableName
-     - options
-    """
-    self.send_createScanner(login, tableName, options)
-    return self.recv_createScanner()
-
-  def send_createScanner(self, login, tableName, options):
-    self._oprot.writeMessageBegin('createScanner', TMessageType.CALL, self._seqid)
-    args = createScanner_args()
-    args.login = login
-    args.tableName = tableName
-    args.options = options
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createScanner(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createScanner_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "createScanner failed: unknown result");
-
-  def hasNext(self, scanner):
-    """
-    Parameters:
-     - scanner
-    """
-    self.send_hasNext(scanner)
-    return self.recv_hasNext()
-
-  def send_hasNext(self, scanner):
-    self._oprot.writeMessageBegin('hasNext', TMessageType.CALL, self._seqid)
-    args = hasNext_args()
-    args.scanner = scanner
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_hasNext(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = hasNext_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "hasNext failed: unknown result");
-
-  def nextEntry(self, scanner):
-    """
-    Parameters:
-     - scanner
-    """
-    self.send_nextEntry(scanner)
-    return self.recv_nextEntry()
-
-  def send_nextEntry(self, scanner):
-    self._oprot.writeMessageBegin('nextEntry', TMessageType.CALL, self._seqid)
-    args = nextEntry_args()
-    args.scanner = scanner
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_nextEntry(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = nextEntry_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "nextEntry failed: unknown result");
-
-  def nextK(self, scanner, k):
-    """
-    Parameters:
-     - scanner
-     - k
-    """
-    self.send_nextK(scanner, k)
-    return self.recv_nextK()
-
-  def send_nextK(self, scanner, k):
-    self._oprot.writeMessageBegin('nextK', TMessageType.CALL, self._seqid)
-    args = nextK_args()
-    args.scanner = scanner
-    args.k = k
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_nextK(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = nextK_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    if result.ouch3 is not None:
-      raise result.ouch3
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "nextK failed: unknown result");
-
-  def closeScanner(self, scanner):
-    """
-    Parameters:
-     - scanner
-    """
-    self.send_closeScanner(scanner)
-    self.recv_closeScanner()
-
-  def send_closeScanner(self, scanner):
-    self._oprot.writeMessageBegin('closeScanner', TMessageType.CALL, self._seqid)
-    args = closeScanner_args()
-    args.scanner = scanner
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_closeScanner(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = closeScanner_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    return
-
-  def updateAndFlush(self, login, tableName, cells):
-    """
-    Parameters:
-     - login
-     - tableName
-     - cells
-    """
-    self.send_updateAndFlush(login, tableName, cells)
-    self.recv_updateAndFlush()
-
-  def send_updateAndFlush(self, login, tableName, cells):
-    self._oprot.writeMessageBegin('updateAndFlush', TMessageType.CALL, self._seqid)
-    args = updateAndFlush_args()
-    args.login = login
-    args.tableName = tableName
-    args.cells = cells
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_updateAndFlush(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = updateAndFlush_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.outch1 is not None:
-      raise result.outch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def createWriter(self, login, tableName, opts):
-    """
-    Parameters:
-     - login
-     - tableName
-     - opts
-    """
-    self.send_createWriter(login, tableName, opts)
-    return self.recv_createWriter()
-
-  def send_createWriter(self, login, tableName, opts):
-    self._oprot.writeMessageBegin('createWriter', TMessageType.CALL, self._seqid)
-    args = createWriter_args()
-    args.login = login
-    args.tableName = tableName
-    args.opts = opts
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_createWriter(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = createWriter_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    if result.outch1 is not None:
-      raise result.outch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "createWriter failed: unknown result");
-
-  def update(self, writer, cells):
-    """
-    Parameters:
-     - writer
-     - cells
-    """
-    self.send_update(writer, cells)
-
-  def send_update(self, writer, cells):
-    self._oprot.writeMessageBegin('update', TMessageType.CALL, self._seqid)
-    args = update_args()
-    args.writer = writer
-    args.cells = cells
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-  def flush(self, writer):
-    """
-    Parameters:
-     - writer
-    """
-    self.send_flush(writer)
-    self.recv_flush()
-
-  def send_flush(self, writer):
-    self._oprot.writeMessageBegin('flush', TMessageType.CALL, self._seqid)
-    args = flush_args()
-    args.writer = writer
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_flush(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = flush_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def closeWriter(self, writer):
-    """
-    Parameters:
-     - writer
-    """
-    self.send_closeWriter(writer)
-    self.recv_closeWriter()
-
-  def send_closeWriter(self, writer):
-    self._oprot.writeMessageBegin('closeWriter', TMessageType.CALL, self._seqid)
-    args = closeWriter_args()
-    args.writer = writer
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_closeWriter(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = closeWriter_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.ouch1 is not None:
-      raise result.ouch1
-    if result.ouch2 is not None:
-      raise result.ouch2
-    return
-
-  def getRowRange(self, row):
-    """
-    Parameters:
-     - row
-    """
-    self.send_getRowRange(row)
-    return self.recv_getRowRange()
-
-  def send_getRowRange(self, row):
-    self._oprot.writeMessageBegin('getRowRange', TMessageType.CALL, self._seqid)
-    args = getRowRange_args()
-    args.row = row
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getRowRange(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getRowRange_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRowRange failed: unknown result");
-
-  def getFollowing(self, key, part):
-    """
-    Parameters:
-     - key
-     - part
-    """
-    self.send_getFollowing(key, part)
-    return self.recv_getFollowing()
-
-  def send_getFollowing(self, key, part):
-    self._oprot.writeMessageBegin('getFollowing', TMessageType.CALL, self._seqid)
-    args = getFollowing_args()
-    args.key = key
-    args.part = part
-    args.write(self._oprot)
-    self._oprot.writeMessageEnd()
-    self._oprot.trans.flush()
-
-  def recv_getFollowing(self, ):
-    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
-    if mtype == TMessageType.EXCEPTION:
-      x = TApplicationException()
-      x.read(self._iprot)
-      self._iprot.readMessageEnd()
-      raise x
-    result = getFollowing_result()
-    result.read(self._iprot)
-    self._iprot.readMessageEnd()
-    if result.success is not None:
-      return result.success
-    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFollowing failed: unknown result");
-
-
-class Processor(Iface, TProcessor):
-  def __init__(self, handler):
-    self._handler = handler
-    self._processMap = {}
-    self._processMap["login"] = Processor.process_login
-    self._processMap["addConstraint"] = Processor.process_addConstraint
-    self._processMap["addSplits"] = Processor.process_addSplits
-    self._processMap["attachIterator"] = Processor.process_attachIterator
-    self._processMap["checkIteratorConflicts"] = Processor.process_checkIteratorConflicts
-    self._processMap["clearLocatorCache"] = Processor.process_clearLocatorCache
-    self._processMap["cloneTable"] = Processor.process_cloneTable
-    self._processMap["compactTable"] = Processor.process_compactTable
-    self._processMap["cancelCompaction"] = Processor.process_cancelCompaction
-    self._processMap["createTable"] = Processor.process_createTable
-    self._processMap["deleteTable"] = Processor.process_deleteTable
-    self._processMap["deleteRows"] = Processor.process_deleteRows
-    self._processMap["exportTable"] = Processor.process_exportTable
-    self._processMap["flushTable"] = Processor.process_flushTable
-    self._processMap["getLocalityGroups"] = Processor.process_getLocalityGroups
-    self._processMap["getIteratorSetting"] = Processor.process_getIteratorSetting
-    self._processMap["getMaxRow"] = Processor.process_getMaxRow
-    self._processMap["getTableProperties"] = Processor.process_getTableProperties
-    self._processMap["getSplits"] = Processor.process_getSplits
-    self._processMap["importDirectory"] = Processor.process_importDirectory
-    self._processMap["importTable"] = Processor.process_importTable
-    self._processMap["listTables"] = Processor.process_listTables
-    self._processMap["listIterators"] = Processor.process_listIterators
-    self._processMap["listConstraints"] = Processor.process_listConstraints
-    self._processMap["mergeTablets"] = Processor.process_mergeTablets
-    self._processMap["offlineTable"] = Processor.process_offlineTable
-    self._processMap["onlineTable"] = Processor.process_onlineTable
-    self._processMap["removeConstraint"] = Processor.process_removeConstraint
-    self._processMap["removeIterator"] = Processor.process_removeIterator
-    self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
-    self._processMap["renameTable"] = Processor.process_renameTable
-    self._processMap["setLocalityGroups"] = Processor.process_setLocalityGroups
-    self._processMap["setTableProperty"] = Processor.process_setTableProperty
-    self._processMap["splitRangeByTablets"] = Processor.process_splitRangeByTablets
-    self._processMap["tableExists"] = Processor.process_tableExists
-    self._processMap["tableIdMap"] = Processor.process_tableIdMap
-    self._processMap["pingTabletServer"] = Processor.process_pingTabletServer
-    self._processMap["getActiveScans"] = Processor.process_getActiveScans
-    self._processMap["getActiveCompactions"] = Processor.process_getActiveCompactions
-    self._processMap["getSiteConfiguration"] = Processor.process_getSiteConfiguration
-    self._processMap["getSystemConfiguration"] = Processor.process_getSystemConfiguration
-    self._processMap["getTabletServers"] = Processor.process_getTabletServers
-    self._processMap["removeProperty"] = Processor.process_removeProperty
-    self._processMap["setProperty"] = Processor.process_setProperty
-    self._processMap["testClassLoad"] = Processor.process_testClassLoad
-    self._processMap["authenticateUser"] = Processor.process_authenticateUser
-    self._processMap["changeUserAuthorizations"] = Processor.process_changeUserAuthorizations
-    self._processMap["changeLocalUserPassword"] = Processor.process_changeLocalUserPassword
-    self._processMap["createLocalUser"] = Processor.process_createLocalUser
-    self._processMap["dropLocalUser"] = Processor.process_dropLocalUser
-    self._processMap["getUserAuthorizations"] = Processor.process_getUserAuthorizations
-    self._processMap["grantSystemPermission"] = Processor.process_grantSystemPermission
-    self._processMap["grantTablePermission"] = Processor.process_grantTablePermission
-    self._processMap["hasSystemPermission"] = Processor.process_hasSystemPermission
-    self._processMap["hasTablePermission"] = Processor.process_hasTablePermission
-    self._processMap["listLocalUsers"] = Processor.process_listLocalUsers
-    self._processMap["revokeSystemPermission"] = Processor.process_revokeSystemPermission
-    self._processMap["revokeTablePermission"] = Processor.process_revokeTablePermission
-    self._processMap["createBatchScanner"] = Processor.process_createBatchScanner
-    self._processMap["createScanner"] = Processor.process_createScanner
-    self._processMap["hasNext"] = Processor.process_hasNext
-    self._processMap["nextEntry"] = Processor.process_nextEntry
-    self._processMap["nextK"] = Processor.process_nextK
-    self._processMap["closeScanner"] = Processor.process_closeScanner
-    self._processMap["updateAndFlush"] = Processor.process_updateAndFlush
-    self._processMap["createWriter"] = Processor.process_createWriter
-    self._processMap["update"] = Processor.process_update
-    self._processMap["flush"] = Processor.process_flush
-    self._processMap["closeWriter"] = Processor.process_closeWriter
-    self._processMap["getRowRange"] = Processor.process_getRowRange
-    self._processMap["getFollowing"] = Processor.process_getFollowing
-
-  def process(self, iprot, oprot):
-    (name, type, seqid) = iprot.readMessageBegin()
-    if name not in self._processMap:
-      iprot.skip(TType.STRUCT)
-      iprot.readMessageEnd()
-      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
-      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
-      x.write(oprot)
-      oprot.writeMessageEnd()
-      oprot.trans.flush()
-      return
-    else:
-      self._processMap[name](self, seqid, iprot, oprot)
-    return True
-
-  def process_login(self, seqid, iprot, oprot):
-    args = login_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = login_result()
-    try:
-      result.success = self._handler.login(args.principal, args.loginProperties)
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("login", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_addConstraint(self, seqid, iprot, oprot):
-    args = addConstraint_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = addConstraint_result()
-    try:
-      result.success = self._handler.addConstraint(args.login, args.tableName, args.constraintClassName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("addConstraint", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_addSplits(self, seqid, iprot, oprot):
-    args = addSplits_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = addSplits_result()
-    try:
-      self._handler.addSplits(args.login, args.tableName, args.splits)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("addSplits", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_attachIterator(self, seqid, iprot, oprot):
-    args = attachIterator_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = attachIterator_result()
-    try:
-      self._handler.attachIterator(args.login, args.tableName, args.setting, args.scopes)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("attachIterator", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_checkIteratorConflicts(self, seqid, iprot, oprot):
-    args = checkIteratorConflicts_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = checkIteratorConflicts_result()
-    try:
-      self._handler.checkIteratorConflicts(args.login, args.tableName, args.setting, args.scopes)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("checkIteratorConflicts", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_clearLocatorCache(self, seqid, iprot, oprot):
-    args = clearLocatorCache_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = clearLocatorCache_result()
-    try:
-      self._handler.clearLocatorCache(args.login, args.tableName)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("clearLocatorCache", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_cloneTable(self, seqid, iprot, oprot):
-    args = cloneTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = cloneTable_result()
-    try:
-      self._handler.cloneTable(args.login, args.tableName, args.newTableName, args.flush, args.propertiesToSet, args.propertiesToExclude)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    except TableExistsException as ouch4:
-      result.ouch4 = ouch4
-    oprot.writeMessageBegin("cloneTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_compactTable(self, seqid, iprot, oprot):
-    args = compactTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = compactTable_result()
-    try:
-      self._handler.compactTable(args.login, args.tableName, args.startRow, args.endRow, args.iterators, args.flush, args.wait)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("compactTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_cancelCompaction(self, seqid, iprot, oprot):
-    args = cancelCompaction_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = cancelCompaction_result()
-    try:
-      self._handler.cancelCompaction(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("cancelCompaction", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createTable(self, seqid, iprot, oprot):
-    args = createTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createTable_result()
-    try:
-      self._handler.createTable(args.login, args.tableName, args.versioningIter, args.type)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableExistsException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("createTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_deleteTable(self, seqid, iprot, oprot):
-    args = deleteTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = deleteTable_result()
-    try:
-      self._handler.deleteTable(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("deleteTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_deleteRows(self, seqid, iprot, oprot):
-    args = deleteRows_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = deleteRows_result()
-    try:
-      self._handler.deleteRows(args.login, args.tableName, args.startRow, args.endRow)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("deleteRows", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_exportTable(self, seqid, iprot, oprot):
-    args = exportTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = exportTable_result()
-    try:
-      self._handler.exportTable(args.login, args.tableName, args.exportDir)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("exportTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_flushTable(self, seqid, iprot, oprot):
-    args = flushTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = flushTable_result()
-    try:
-      self._handler.flushTable(args.login, args.tableName, args.startRow, args.endRow, args.wait)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("flushTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getLocalityGroups(self, seqid, iprot, oprot):
-    args = getLocalityGroups_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getLocalityGroups_result()
-    try:
-      result.success = self._handler.getLocalityGroups(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getLocalityGroups", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getIteratorSetting(self, seqid, iprot, oprot):
-    args = getIteratorSetting_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getIteratorSetting_result()
-    try:
-      result.success = self._handler.getIteratorSetting(args.login, args.tableName, args.iteratorName, args.scope)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("getIteratorSetting", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getMaxRow(self, seqid, iprot, oprot):
-    args = getMaxRow_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getMaxRow_result()
-    try:
-      result.success = self._handler.getMaxRow(args.login, args.tableName, args.auths, args.startRow, args.startInclusive, args.endRow, args.endInclusive)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("getMaxRow", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getTableProperties(self, seqid, iprot, oprot):
-    args = getTableProperties_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getTableProperties_result()
-    try:
-      result.success = self._handler.getTableProperties(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getTableProperties", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getSplits(self, seqid, iprot, oprot):
-    args = getSplits_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getSplits_result()
-    try:
-      result.success = self._handler.getSplits(args.login, args.tableName, args.maxSplits)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("getSplits", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_importDirectory(self, seqid, iprot, oprot):
-    args = importDirectory_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = importDirectory_result()
-    try:
-      self._handler.importDirectory(args.login, args.tableName, args.importDir, args.failureDir, args.setTime)
-    except TableNotFoundException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    except AccumuloSecurityException as ouch4:
-      result.ouch4 = ouch4
-    oprot.writeMessageBegin("importDirectory", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_importTable(self, seqid, iprot, oprot):
-    args = importTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = importTable_result()
-    try:
-      self._handler.importTable(args.login, args.tableName, args.importDir)
-    except TableExistsException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("importTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listTables(self, seqid, iprot, oprot):
-    args = listTables_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listTables_result()
-    result.success = self._handler.listTables(args.login)
-    oprot.writeMessageBegin("listTables", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listIterators(self, seqid, iprot, oprot):
-    args = listIterators_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listIterators_result()
-    try:
-      result.success = self._handler.listIterators(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("listIterators", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listConstraints(self, seqid, iprot, oprot):
-    args = listConstraints_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listConstraints_result()
-    try:
-      result.success = self._handler.listConstraints(args.login, args.tableName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("listConstraints", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_mergeTablets(self, seqid, iprot, oprot):
-    args = mergeTablets_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = mergeTablets_result()
-    try:
-      self._handler.mergeTablets(args.login, args.tableName, args.startRow, args.endRow)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("mergeTablets", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_offlineTable(self, seqid, iprot, oprot):
-    args = offlineTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = offlineTable_result()
-    try:
-      self._handler.offlineTable(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("offlineTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_onlineTable(self, seqid, iprot, oprot):
-    args = onlineTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = onlineTable_result()
-    try:
-      self._handler.onlineTable(args.login, args.tableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("onlineTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeConstraint(self, seqid, iprot, oprot):
-    args = removeConstraint_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeConstraint_result()
-    try:
-      self._handler.removeConstraint(args.login, args.tableName, args.constraint)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("removeConstraint", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeIterator(self, seqid, iprot, oprot):
-    args = removeIterator_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeIterator_result()
-    try:
-      self._handler.removeIterator(args.login, args.tableName, args.iterName, args.scopes)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("removeIterator", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeTableProperty(self, seqid, iprot, oprot):
-    args = removeTableProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeTableProperty_result()
-    try:
-      self._handler.removeTableProperty(args.login, args.tableName, args.property)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("removeTableProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_renameTable(self, seqid, iprot, oprot):
-    args = renameTable_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = renameTable_result()
-    try:
-      self._handler.renameTable(args.login, args.oldTableName, args.newTableName)
-    except AccumuloSecurityException as ouch1:
-      result.ouch1 = ouch1
-    except TableNotFoundException as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloException as ouch3:
-      result.ouch3 = ouch3
-    except TableExistsException as ouch4:
-      result.ouch4 = ouch4
-    oprot.writeMessageBegin("renameTable", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_setLocalityGroups(self, seqid, iprot, oprot):
-    args = setLocalityGroups_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = setLocalityGroups_result()
-    try:
-      self._handler.setLocalityGroups(args.login, args.tableName, args.groups)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("setLocalityGroups", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_setTableProperty(self, seqid, iprot, oprot):
-    args = setTableProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = setTableProperty_result()
-    try:
-      self._handler.setTableProperty(args.login, args.tableName, args.property, args.value)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("setTableProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_splitRangeByTablets(self, seqid, iprot, oprot):
-    args = splitRangeByTablets_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = splitRangeByTablets_result()
-    try:
-      result.success = self._handler.splitRangeByTablets(args.login, args.tableName, args.range, args.maxSplits)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    except TableNotFoundException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("splitRangeByTablets", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_tableExists(self, seqid, iprot, oprot):
-    args = tableExists_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = tableExists_result()
-    result.success = self._handler.tableExists(args.login, args.tableName)
-    oprot.writeMessageBegin("tableExists", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_tableIdMap(self, seqid, iprot, oprot):
-    args = tableIdMap_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = tableIdMap_result()
-    result.success = self._handler.tableIdMap(args.login)
-    oprot.writeMessageBegin("tableIdMap", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_pingTabletServer(self, seqid, iprot, oprot):
-    args = pingTabletServer_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = pingTabletServer_result()
-    try:
-      self._handler.pingTabletServer(args.login, args.tserver)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("pingTabletServer", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getActiveScans(self, seqid, iprot, oprot):
-    args = getActiveScans_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getActiveScans_result()
-    try:
-      result.success = self._handler.getActiveScans(args.login, args.tserver)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getActiveScans", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getActiveCompactions(self, seqid, iprot, oprot):
-    args = getActiveCompactions_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getActiveCompactions_result()
-    try:
-      result.success = self._handler.getActiveCompactions(args.login, args.tserver)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getActiveCompactions", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getSiteConfiguration(self, seqid, iprot, oprot):
-    args = getSiteConfiguration_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getSiteConfiguration_result()
-    try:
-      result.success = self._handler.getSiteConfiguration(args.login)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getSiteConfiguration", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getSystemConfiguration(self, seqid, iprot, oprot):
-    args = getSystemConfiguration_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getSystemConfiguration_result()
-    try:
-      result.success = self._handler.getSystemConfiguration(args.login)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getSystemConfiguration", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getTabletServers(self, seqid, iprot, oprot):
-    args = getTabletServers_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getTabletServers_result()
-    result.success = self._handler.getTabletServers(args.login)
-    oprot.writeMessageBegin("getTabletServers", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_removeProperty(self, seqid, iprot, oprot):
-    args = removeProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = removeProperty_result()
-    try:
-      self._handler.removeProperty(args.login, args.property)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("removeProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_setProperty(self, seqid, iprot, oprot):
-    args = setProperty_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = setProperty_result()
-    try:
-      self._handler.setProperty(args.login, args.property, args.value)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("setProperty", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_testClassLoad(self, seqid, iprot, oprot):
-    args = testClassLoad_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = testClassLoad_result()
-    try:
-      result.success = self._handler.testClassLoad(args.login, args.className, args.asTypeName)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("testClassLoad", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_authenticateUser(self, seqid, iprot, oprot):
-    args = authenticateUser_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = authenticateUser_result()
-    try:
-      result.success = self._handler.authenticateUser(args.login, args.user, args.properties)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("authenticateUser", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_changeUserAuthorizations(self, seqid, iprot, oprot):
-    args = changeUserAuthorizations_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = changeUserAuthorizations_result()
-    try:
-      self._handler.changeUserAuthorizations(args.login, args.user, args.authorizations)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("changeUserAuthorizations", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_changeLocalUserPassword(self, seqid, iprot, oprot):
-    args = changeLocalUserPassword_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = changeLocalUserPassword_result()
-    try:
-      self._handler.changeLocalUserPassword(args.login, args.user, args.password)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("changeLocalUserPassword", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createLocalUser(self, seqid, iprot, oprot):
-    args = createLocalUser_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createLocalUser_result()
-    try:
-      self._handler.createLocalUser(args.login, args.user, args.password)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createLocalUser", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_dropLocalUser(self, seqid, iprot, oprot):
-    args = dropLocalUser_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = dropLocalUser_result()
-    try:
-      self._handler.dropLocalUser(args.login, args.user)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("dropLocalUser", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getUserAuthorizations(self, seqid, iprot, oprot):
-    args = getUserAuthorizations_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getUserAuthorizations_result()
-    try:
-      result.success = self._handler.getUserAuthorizations(args.login, args.user)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("getUserAuthorizations", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_grantSystemPermission(self, seqid, iprot, oprot):
-    args = grantSystemPermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = grantSystemPermission_result()
-    try:
-      self._handler.grantSystemPermission(args.login, args.user, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("grantSystemPermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_grantTablePermission(self, seqid, iprot, oprot):
-    args = grantTablePermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = grantTablePermission_result()
-    try:
-      self._handler.grantTablePermission(args.login, args.user, args.table, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("grantTablePermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_hasSystemPermission(self, seqid, iprot, oprot):
-    args = hasSystemPermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = hasSystemPermission_result()
-    try:
-      result.success = self._handler.hasSystemPermission(args.login, args.user, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("hasSystemPermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_hasTablePermission(self, seqid, iprot, oprot):
-    args = hasTablePermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = hasTablePermission_result()
-    try:
-      result.success = self._handler.hasTablePermission(args.login, args.user, args.table, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("hasTablePermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_listLocalUsers(self, seqid, iprot, oprot):
-    args = listLocalUsers_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = listLocalUsers_result()
-    try:
-      result.success = self._handler.listLocalUsers(args.login)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("listLocalUsers", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_revokeSystemPermission(self, seqid, iprot, oprot):
-    args = revokeSystemPermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = revokeSystemPermission_result()
-    try:
-      self._handler.revokeSystemPermission(args.login, args.user, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("revokeSystemPermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_revokeTablePermission(self, seqid, iprot, oprot):
-    args = revokeTablePermission_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = revokeTablePermission_result()
-    try:
-      self._handler.revokeTablePermission(args.login, args.user, args.table, args.perm)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("revokeTablePermission", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createBatchScanner(self, seqid, iprot, oprot):
-    args = createBatchScanner_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createBatchScanner_result()
-    try:
-      result.success = self._handler.createBatchScanner(args.login, args.tableName, args.options)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createBatchScanner", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createScanner(self, seqid, iprot, oprot):
-    args = createScanner_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createScanner_result()
-    try:
-      result.success = self._handler.createScanner(args.login, args.tableName, args.options)
-    except AccumuloException as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createScanner", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_hasNext(self, seqid, iprot, oprot):
-    args = hasNext_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = hasNext_result()
-    try:
-      result.success = self._handler.hasNext(args.scanner)
-    except UnknownScanner as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("hasNext", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_nextEntry(self, seqid, iprot, oprot):
-    args = nextEntry_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = nextEntry_result()
-    try:
-      result.success = self._handler.nextEntry(args.scanner)
-    except NoMoreEntriesException as ouch1:
-      result.ouch1 = ouch1
-    except UnknownScanner as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("nextEntry", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_nextK(self, seqid, iprot, oprot):
-    args = nextK_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = nextK_result()
-    try:
-      result.success = self._handler.nextK(args.scanner, args.k)
-    except NoMoreEntriesException as ouch1:
-      result.ouch1 = ouch1
-    except UnknownScanner as ouch2:
-      result.ouch2 = ouch2
-    except AccumuloSecurityException as ouch3:
-      result.ouch3 = ouch3
-    oprot.writeMessageBegin("nextK", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_closeScanner(self, seqid, iprot, oprot):
-    args = closeScanner_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = closeScanner_result()
-    try:
-      self._handler.closeScanner(args.scanner)
-    except UnknownScanner as ouch1:
-      result.ouch1 = ouch1
-    oprot.writeMessageBegin("closeScanner", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_updateAndFlush(self, seqid, iprot, oprot):
-    args = updateAndFlush_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = updateAndFlush_result()
-    try:
-      self._handler.updateAndFlush(args.login, args.tableName, args.cells)
-    except AccumuloException as outch1:
-      result.outch1 = outch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("updateAndFlush", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_createWriter(self, seqid, iprot, oprot):
-    args = createWriter_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = createWriter_result()
-    try:
-      result.success = self._handler.createWriter(args.login, args.tableName, args.opts)
-    except AccumuloException as outch1:
-      result.outch1 = outch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("createWriter", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_update(self, seqid, iprot, oprot):
-    args = update_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    self._handler.update(args.writer, args.cells)
-    return
-
-  def process_flush(self, seqid, iprot, oprot):
-    args = flush_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = flush_result()
-    try:
-      self._handler.flush(args.writer)
-    except UnknownWriter as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("flush", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_closeWriter(self, seqid, iprot, oprot):
-    args = closeWriter_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = closeWriter_result()
-    try:
-      self._handler.closeWriter(args.writer)
-    except UnknownWriter as ouch1:
-      result.ouch1 = ouch1
-    except AccumuloSecurityException as ouch2:
-      result.ouch2 = ouch2
-    oprot.writeMessageBegin("closeWriter", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getRowRange(self, seqid, iprot, oprot):
-    args = getRowRange_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getRowRange_result()
-    result.success = self._handler.getRowRange(args.row)
-    oprot.writeMessageBegin("getRowRange", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-  def process_getFollowing(self, seqid, iprot, oprot):
-    args = getFollowing_args()
-    args.read(iprot)
-    iprot.readMessageEnd()
-    result = getFollowing_result()
-    result.success = self._handler.getFollowing(args.key, args.part)
-    oprot.writeMessageBegin("getFollowing", TMessageType.REPLY, seqid)
-    result.write(oprot)
-    oprot.writeMessageEnd()
-    oprot.trans.flush()
-
-
-# HELPER FUNCTIONS AND STRUCTURES
-
-class login_args:
-  """
-  Attributes:
-   - principal
-   - loginProperties
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'principal', None, None, ), # 1
-    (2, TType.MAP, 'loginProperties', (TType.STRING,None,TType.STRING,None), None, ), # 2
-  )
-
-  def __init__(self, principal=None, loginProperties=None,):
-    self.principal = principal
-    self.loginProperties = loginProperties
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.principal = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.MAP:
-          self.loginProperties = {}
-          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin() 
-          for _i104 in xrange(_size100):
-            _key105 = iprot.readString();
-            _val106 = iprot.readString();
-            self.loginProperties[_key105] = _val106
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('login_args')
-    if self.principal is not None:
-      oprot.writeFieldBegin('principal', TType.STRING, 1)
-      oprot.writeString(self.principal)
-      oprot.writeFieldEnd()
-    if self.loginProperties is not None:
-      oprot.writeFieldBegin('loginProperties', TType.MAP, 2)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.loginProperties))
-      for kiter107,viter108 in self.loginProperties.items():
-        oprot.writeString(kiter107)
-        oprot.writeString(viter108)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class login_result:
-  """
-  Attributes:
-   - success
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, success=None, ouch2=None,):
-    self.success = success
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('login_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 1)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addConstraint_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - constraintClassName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'constraintClassName', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, constraintClassName=None,):
-    self.login = login
-    self.tableName = tableName
-    self.constraintClassName = constraintClassName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.constraintClassName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addConstraint_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.constraintClassName is not None:
-      oprot.writeFieldBegin('constraintClassName', TType.STRING, 3)
-      oprot.writeString(self.constraintClassName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addConstraint_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.I32, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.I32:
-          self.success = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addConstraint_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.I32, 0)
-      oprot.writeI32(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addSplits_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - splits
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.SET, 'splits', (TType.STRING,None), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, splits=None,):
-    self.login = login
-    self.tableName = tableName
-    self.splits = splits
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.SET:
-          self.splits = set()
-          (_etype112, _size109) = iprot.readSetBegin()
-          for _i113 in xrange(_size109):
-            _elem114 = iprot.readString();
-            self.splits.add(_elem114)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addSplits_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.splits is not None:
-      oprot.writeFieldBegin('splits', TType.SET, 3)
-      oprot.writeSetBegin(TType.STRING, len(self.splits))
-      for iter115 in self.splits:
-        oprot.writeString(iter115)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class addSplits_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('addSplits_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class attachIterator_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - setting
-   - scopes
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 3
-    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
-    self.login = login
-    self.tableName = tableName
-    self.setting = setting
-    self.scopes = scopes
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.setting = IteratorSetting()
-          self.setting.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.SET:
-          self.scopes = set()
-          (_etype119, _size116) = iprot.readSetBegin()
-          for _i120 in xrange(_size116):
-            _elem121 = iprot.readI32();
-            self.scopes.add(_elem121)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('attachIterator_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.setting is not None:
-      oprot.writeFieldBegin('setting', TType.STRUCT, 3)
-      self.setting.write(oprot)
-      oprot.writeFieldEnd()
-    if self.scopes is not None:
-      oprot.writeFieldBegin('scopes', TType.SET, 4)
-      oprot.writeSetBegin(TType.I32, len(self.scopes))
-      for iter122 in self.scopes:
-        oprot.writeI32(iter122)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class attachIterator_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('attachIterator_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class checkIteratorConflicts_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - setting
-   - scopes
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'setting', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 3
-    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, setting=None, scopes=None,):
-    self.login = login
-    self.tableName = tableName
-    self.setting = setting
-    self.scopes = scopes
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.setting = IteratorSetting()
-          self.setting.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.SET:
-          self.scopes = set()
-          (_etype126, _size123) = iprot.readSetBegin()
-          for _i127 in xrange(_size123):
-            _elem128 = iprot.readI32();
-            self.scopes.add(_elem128)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('checkIteratorConflicts_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.setting is not None:
-      oprot.writeFieldBegin('setting', TType.STRUCT, 3)
-      self.setting.write(oprot)
-      oprot.writeFieldEnd()
-    if self.scopes is not None:
-      oprot.writeFieldBegin('scopes', TType.SET, 4)
-      oprot.writeSetBegin(TType.I32, len(self.scopes))
-      for iter129 in self.scopes:
-        oprot.writeI32(iter129)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class checkIteratorConflicts_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('checkIteratorConflicts_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class clearLocatorCache_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('clearLocatorCache_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class clearLocatorCache_result:
-  """
-  Attributes:
-   - ouch1
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, ouch1=None,):
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('clearLocatorCache_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cloneTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - newTableName
-   - flush
-   - propertiesToSet
-   - propertiesToExclude
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'newTableName', None, None, ), # 3
-    (4, TType.BOOL, 'flush', None, None, ), # 4
-    (5, TType.MAP, 'propertiesToSet', (TType.STRING,None,TType.STRING,None), None, ), # 5
-    (6, TType.SET, 'propertiesToExclude', (TType.STRING,None), None, ), # 6
-  )
-
-  def __init__(self, login=None, tableName=None, newTableName=None, flush=None, propertiesToSet=None, propertiesToExclude=None,):
-    self.login = login
-    self.tableName = tableName
-    self.newTableName = newTableName
-    self.flush = flush
-    self.propertiesToSet = propertiesToSet
-    self.propertiesToExclude = propertiesToExclude
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.newTableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.BOOL:
-          self.flush = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.MAP:
-          self.propertiesToSet = {}
-          (_ktype131, _vtype132, _size130 ) = iprot.readMapBegin() 
-          for _i134 in xrange(_size130):
-            _key135 = iprot.readString();
-            _val136 = iprot.readString();
-            self.propertiesToSet[_key135] = _val136
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.SET:
-          self.propertiesToExclude = set()
-          (_etype140, _size137) = iprot.readSetBegin()
-          for _i141 in xrange(_size137):
-            _elem142 = iprot.readString();
-            self.propertiesToExclude.add(_elem142)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cloneTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.newTableName is not None:
-      oprot.writeFieldBegin('newTableName', TType.STRING, 3)
-      oprot.writeString(self.newTableName)
-      oprot.writeFieldEnd()
-    if self.flush is not None:
-      oprot.writeFieldBegin('flush', TType.BOOL, 4)
-      oprot.writeBool(self.flush)
-      oprot.writeFieldEnd()
-    if self.propertiesToSet is not None:
-      oprot.writeFieldBegin('propertiesToSet', TType.MAP, 5)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.propertiesToSet))
-      for kiter143,viter144 in self.propertiesToSet.items():
-        oprot.writeString(kiter143)
-        oprot.writeString(viter144)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.propertiesToExclude is not None:
-      oprot.writeFieldBegin('propertiesToExclude', TType.SET, 6)
-      oprot.writeSetBegin(TType.STRING, len(self.propertiesToExclude))
-      for iter145 in self.propertiesToExclude:
-        oprot.writeString(iter145)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cloneTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-   - ouch4
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-    (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ), # 4
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-    self.ouch4 = ouch4
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRUCT:
-          self.ouch4 = TableExistsException()
-          self.ouch4.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cloneTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch4 is not None:
-      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
-      self.ouch4.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class compactTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-   - iterators
-   - flush
-   - wait
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-    (5, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 5
-    (6, TType.BOOL, 'flush', None, None, ), # 6
-    (7, TType.BOOL, 'wait', None, None, ), # 7
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None, iterators=None, flush=None, wait=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-    self.iterators = iterators
-    self.flush = flush
-    self.wait = wait
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype149, _size146) = iprot.readListBegin()
-          for _i150 in xrange(_size146):
-            _elem151 = IteratorSetting()
-            _elem151.read(iprot)
-            self.iterators.append(_elem151)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.BOOL:
-          self.flush = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.BOOL:
-          self.wait = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('compactTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 5)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter152 in self.iterators:
-        iter152.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.flush is not None:
-      oprot.writeFieldBegin('flush', TType.BOOL, 6)
-      oprot.writeBool(self.flush)
-      oprot.writeFieldEnd()
-    if self.wait is not None:
-      oprot.writeFieldBegin('wait', TType.BOOL, 7)
-      oprot.writeBool(self.wait)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class compactTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('compactTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cancelCompaction_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cancelCompaction_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class cancelCompaction_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('cancelCompaction_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - versioningIter
-   - type
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.BOOL, 'versioningIter', None, None, ), # 3
-    (4, TType.I32, 'type', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, versioningIter=None, type=None,):
-    self.login = login
-    self.tableName = tableName
-    self.versioningIter = versioningIter
-    self.type = type
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.BOOL:
-          self.versioningIter = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.type = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.versioningIter is not None:
-      oprot.writeFieldBegin('versioningIter', TType.BOOL, 3)
-      oprot.writeBool(self.versioningIter)
-      oprot.writeFieldEnd()
-    if self.type is not None:
-      oprot.writeFieldBegin('type', TType.I32, 4)
-      oprot.writeI32(self.type)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableExistsException, TableExistsException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableExistsException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteRows_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteRows_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class deleteRows_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('deleteRows_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class exportTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - exportDir
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'exportDir', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, exportDir=None,):
-    self.login = login
-    self.tableName = tableName
-    self.exportDir = exportDir
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.exportDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('exportTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.exportDir is not None:
-      oprot.writeFieldBegin('exportDir', TType.STRING, 3)
-      oprot.writeString(self.exportDir)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class exportTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('exportTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flushTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-   - wait
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-    (5, TType.BOOL, 'wait', None, None, ), # 5
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None, wait=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-    self.wait = wait
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.BOOL:
-          self.wait = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flushTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.wait is not None:
-      oprot.writeFieldBegin('wait', TType.BOOL, 5)
-      oprot.writeBool(self.wait)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flushTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flushTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getLocalityGroups_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getLocalityGroups_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getLocalityGroups_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.STRING,None)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype154, _vtype155, _size153 ) = iprot.readMapBegin() 
-          for _i157 in xrange(_size153):
-            _key158 = iprot.readString();
-            _val159 = set()
-            (_etype163, _size160) = iprot.readSetBegin()
-            for _i164 in xrange(_size160):
-              _elem165 = iprot.readString();
-              _val159.add(_elem165)
-            iprot.readSetEnd()
-            self.success[_key158] = _val159
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getLocalityGroups_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
-      for kiter166,viter167 in self.success.items():
-        oprot.writeString(kiter166)
-        oprot.writeSetBegin(TType.STRING, len(viter167))
-        for iter168 in viter167:
-          oprot.writeString(iter168)
-        oprot.writeSetEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getIteratorSetting_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - iteratorName
-   - scope
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'iteratorName', None, None, ), # 3
-    (4, TType.I32, 'scope', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, iteratorName=None, scope=None,):
-    self.login = login
-    self.tableName = tableName
-    self.iteratorName = iteratorName
-    self.scope = scope
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.iteratorName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.scope = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getIteratorSetting_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.iteratorName is not None:
-      oprot.writeFieldBegin('iteratorName', TType.STRING, 3)
-      oprot.writeString(self.iteratorName)
-      oprot.writeFieldEnd()
-    if self.scope is not None:
-      oprot.writeFieldBegin('scope', TType.I32, 4)
-      oprot.writeI32(self.scope)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getIteratorSetting_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (IteratorSetting, IteratorSetting.thrift_spec), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = IteratorSetting()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getIteratorSetting_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getMaxRow_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - auths
-   - startRow
-   - startInclusive
-   - endRow
-   - endInclusive
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.SET, 'auths', (TType.STRING,None), None, ), # 3
-    (4, TType.STRING, 'startRow', None, None, ), # 4
-    (5, TType.BOOL, 'startInclusive', None, None, ), # 5
-    (6, TType.STRING, 'endRow', None, None, ), # 6
-    (7, TType.BOOL, 'endInclusive', None, None, ), # 7
-  )
-
-  def __init__(self, login=None, tableName=None, auths=None, startRow=None, startInclusive=None, endRow=None, endInclusive=None,):
-    self.login = login
-    self.tableName = tableName
-    self.auths = auths
-    self.startRow = startRow
-    self.startInclusive = startInclusive
-    self.endRow = endRow
-    self.endInclusive = endInclusive
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.SET:
-          self.auths = set()
-          (_etype172, _size169) = iprot.readSetBegin()
-          for _i173 in xrange(_size169):
-            _elem174 = iprot.readString();
-            self.auths.add(_elem174)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.BOOL:
-          self.startInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.BOOL:
-          self.endInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getMaxRow_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.auths is not None:
-      oprot.writeFieldBegin('auths', TType.SET, 3)
-      oprot.writeSetBegin(TType.STRING, len(self.auths))
-      for iter175 in self.auths:
-        oprot.writeString(iter175)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 4)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.startInclusive is not None:
-      oprot.writeFieldBegin('startInclusive', TType.BOOL, 5)
-      oprot.writeBool(self.startInclusive)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 6)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.endInclusive is not None:
-      oprot.writeFieldBegin('endInclusive', TType.BOOL, 7)
-      oprot.writeBool(self.endInclusive)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getMaxRow_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getMaxRow_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTableProperties_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTableProperties_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTableProperties_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype177, _vtype178, _size176 ) = iprot.readMapBegin() 
-          for _i180 in xrange(_size176):
-            _key181 = iprot.readString();
-            _val182 = iprot.readString();
-            self.success[_key181] = _val182
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTableProperties_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter183,viter184 in self.success.items():
-        oprot.writeString(kiter183)
-        oprot.writeString(viter184)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSplits_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - maxSplits
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.I32, 'maxSplits', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, maxSplits=None,):
-    self.login = login
-    self.tableName = tableName
-    self.maxSplits = maxSplits
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.maxSplits = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSplits_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.maxSplits is not None:
-      oprot.writeFieldBegin('maxSplits', TType.I32, 3)
-      oprot.writeI32(self.maxSplits)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSplits_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, success=None, ouch1=None,):
-    self.success = success
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype188, _size185) = iprot.readListBegin()
-          for _i189 in xrange(_size185):
-            _elem190 = iprot.readString();
-            self.success.append(_elem190)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSplits_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRING, len(self.success))
-      for iter191 in self.success:
-        oprot.writeString(iter191)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importDirectory_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - importDir
-   - failureDir
-   - setTime
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'importDir', None, None, ), # 3
-    (4, TType.STRING, 'failureDir', None, None, ), # 4
-    (5, TType.BOOL, 'setTime', None, None, ), # 5
-  )
-
-  def __init__(self, login=None, tableName=None, importDir=None, failureDir=None, setTime=None,):
-    self.login = login
-    self.tableName = tableName
-    self.importDir = importDir
-    self.failureDir = failureDir
-    self.setTime = setTime
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.importDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.failureDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.BOOL:
-          self.setTime = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importDirectory_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.importDir is not None:
-      oprot.writeFieldBegin('importDir', TType.STRING, 3)
-      oprot.writeString(self.importDir)
-      oprot.writeFieldEnd()
-    if self.failureDir is not None:
-      oprot.writeFieldBegin('failureDir', TType.STRING, 4)
-      oprot.writeString(self.failureDir)
-      oprot.writeFieldEnd()
-    if self.setTime is not None:
-      oprot.writeFieldBegin('setTime', TType.BOOL, 5)
-      oprot.writeBool(self.setTime)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importDirectory_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch3
-   - ouch4
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch4', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch3=None, ouch4=None,):
-    self.ouch1 = ouch1
-    self.ouch3 = ouch3
-    self.ouch4 = ouch4
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableNotFoundException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch4 = AccumuloSecurityException()
-          self.ouch4.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importDirectory_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 2)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch4 is not None:
-      oprot.writeFieldBegin('ouch4', TType.STRUCT, 3)
-      self.ouch4.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - importDir
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'importDir', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, importDir=None,):
-    self.login = login
-    self.tableName = tableName
-    self.importDir = importDir
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.importDir = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.importDir is not None:
-      oprot.writeFieldBegin('importDir', TType.STRING, 3)
-      oprot.writeString(self.importDir)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class importTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (TableExistsException, TableExistsException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = TableExistsException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('importTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listTables_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listTables_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listTables_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.SET:
-          self.success = set()
-          (_etype195, _size192) = iprot.readSetBegin()
-          for _i196 in xrange(_size192):
-            _elem197 = iprot.readString();
-            self.success.add(_elem197)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listTables_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.SET, 0)
-      oprot.writeSetBegin(TType.STRING, len(self.success))
-      for iter198 in self.success:
-        oprot.writeString(iter198)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listIterators_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listIterators_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listIterators_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.SET,(TType.I32,None)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype200, _vtype201, _size199 ) = iprot.readMapBegin() 
-          for _i203 in xrange(_size199):
-            _key204 = iprot.readString();
-            _val205 = set()
-            (_etype209, _size206) = iprot.readSetBegin()
-            for _i210 in xrange(_size206):
-              _elem211 = iprot.readI32();
-              _val205.add(_elem211)
-            iprot.readSetEnd()
-            self.success[_key204] = _val205
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listIterators_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.success))
-      for kiter212,viter213 in self.success.items():
-        oprot.writeString(kiter212)
-        oprot.writeSetBegin(TType.I32, len(viter213))
-        for iter214 in viter213:
-          oprot.writeI32(iter214)
-        oprot.writeSetEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listConstraints_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listConstraints_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listConstraints_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.I32,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype216, _vtype217, _size215 ) = iprot.readMapBegin() 
-          for _i219 in xrange(_size215):
-            _key220 = iprot.readString();
-            _val221 = iprot.readI32();
-            self.success[_key220] = _val221
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listConstraints_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
-      for kiter222,viter223 in self.success.items():
-        oprot.writeString(kiter222)
-        oprot.writeI32(viter223)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class mergeTablets_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - startRow
-   - endRow
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'startRow', None, None, ), # 3
-    (4, TType.STRING, 'endRow', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, startRow=None, endRow=None,):
-    self.login = login
-    self.tableName = tableName
-    self.startRow = startRow
-    self.endRow = endRow
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.startRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('mergeTablets_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.startRow is not None:
-      oprot.writeFieldBegin('startRow', TType.STRING, 3)
-      oprot.writeString(self.startRow)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 4)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class mergeTablets_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('mergeTablets_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class offlineTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('offlineTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class offlineTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('offlineTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class onlineTable_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('onlineTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class onlineTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('onlineTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeConstraint_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - constraint
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.I32, 'constraint', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, constraint=None,):
-    self.login = login
-    self.tableName = tableName
-    self.constraint = constraint
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.constraint = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeConstraint_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.constraint is not None:
-      oprot.writeFieldBegin('constraint', TType.I32, 3)
-      oprot.writeI32(self.constraint)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeConstraint_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeConstraint_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeIterator_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - iterName
-   - scopes
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'iterName', None, None, ), # 3
-    (4, TType.SET, 'scopes', (TType.I32,None), None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, iterName=None, scopes=None,):
-    self.login = login
-    self.tableName = tableName
-    self.iterName = iterName
-    self.scopes = scopes
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.iterName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.SET:
-          self.scopes = set()
-          (_etype227, _size224) = iprot.readSetBegin()
-          for _i228 in xrange(_size224):
-            _elem229 = iprot.readI32();
-            self.scopes.add(_elem229)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeIterator_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.iterName is not None:
-      oprot.writeFieldBegin('iterName', TType.STRING, 3)
-      oprot.writeString(self.iterName)
-      oprot.writeFieldEnd()
-    if self.scopes is not None:
-      oprot.writeFieldBegin('scopes', TType.SET, 4)
-      oprot.writeSetBegin(TType.I32, len(self.scopes))
-      for iter230 in self.scopes:
-        oprot.writeI32(iter230)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeIterator_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloException, AccumuloException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeIterator_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeTableProperty_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - property
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'property', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, property=None,):
-    self.login = login
-    self.tableName = tableName
-    self.property = property
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeTableProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 3)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeTableProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeTableProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class renameTable_args:
-  """
-  Attributes:
-   - login
-   - oldTableName
-   - newTableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'oldTableName', None, None, ), # 2
-    (3, TType.STRING, 'newTableName', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, oldTableName=None, newTableName=None,):
-    self.login = login
-    self.oldTableName = oldTableName
-    self.newTableName = newTableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.oldTableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.newTableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('renameTable_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.oldTableName is not None:
-      oprot.writeFieldBegin('oldTableName', TType.STRING, 2)
-      oprot.writeString(self.oldTableName)
-      oprot.writeFieldEnd()
-    if self.newTableName is not None:
-      oprot.writeFieldBegin('newTableName', TType.STRING, 3)
-      oprot.writeString(self.newTableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class renameTable_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-   - ouch4
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloException, AccumuloException.thrift_spec), None, ), # 3
-    (4, TType.STRUCT, 'ouch4', (TableExistsException, TableExistsException.thrift_spec), None, ), # 4
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None, ouch4=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-    self.ouch4 = ouch4
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloSecurityException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = TableNotFoundException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRUCT:
-          self.ouch4 = TableExistsException()
-          self.ouch4.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('renameTable_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch4 is not None:
-      oprot.writeFieldBegin('ouch4', TType.STRUCT, 4)
-      self.ouch4.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setLocalityGroups_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - groups
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.MAP, 'groups', (TType.STRING,None,TType.SET,(TType.STRING,None)), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, groups=None,):
-    self.login = login
-    self.tableName = tableName
-    self.groups = groups
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.MAP:
-          self.groups = {}
-          (_ktype232, _vtype233, _size231 ) = iprot.readMapBegin() 
-          for _i235 in xrange(_size231):
-            _key236 = iprot.readString();
-            _val237 = set()
-            (_etype241, _size238) = iprot.readSetBegin()
-            for _i242 in xrange(_size238):
-              _elem243 = iprot.readString();
-              _val237.add(_elem243)
-            iprot.readSetEnd()
-            self.groups[_key236] = _val237
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setLocalityGroups_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.groups is not None:
-      oprot.writeFieldBegin('groups', TType.MAP, 3)
-      oprot.writeMapBegin(TType.STRING, TType.SET, len(self.groups))
-      for kiter244,viter245 in self.groups.items():
-        oprot.writeString(kiter244)
-        oprot.writeSetBegin(TType.STRING, len(viter245))
-        for iter246 in viter245:
-          oprot.writeString(iter246)
-        oprot.writeSetEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setLocalityGroups_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, ouch1=None, ouch2=None, ouch3=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setLocalityGroups_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setTableProperty_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - property
-   - value
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRING, 'property', None, None, ), # 3
-    (4, TType.STRING, 'value', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, property=None, value=None,):
-    self.login = login
-    self.tableName = tableName
-    self.property = property
-    self.value = value
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setTableProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 3)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 4)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setTableProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setTableProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class splitRangeByTablets_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - range
-   - maxSplits
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 3
-    (4, TType.I32, 'maxSplits', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, tableName=None, range=None, maxSplits=None,):
-    self.login = login
-    self.tableName = tableName
-    self.range = range
-    self.maxSplits = maxSplits
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.range = Range()
-          self.range.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.maxSplits = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('splitRangeByTablets_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.range is not None:
-      oprot.writeFieldBegin('range', TType.STRUCT, 3)
-      self.range.write(oprot)
-      oprot.writeFieldEnd()
-    if self.maxSplits is not None:
-      oprot.writeFieldBegin('maxSplits', TType.I32, 4)
-      oprot.writeI32(self.maxSplits)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class splitRangeByTablets_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.SET, 'success', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (TableNotFoundException, TableNotFoundException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.SET:
-          self.success = set()
-          (_etype250, _size247) = iprot.readSetBegin()
-          for _i251 in xrange(_size247):
-            _elem252 = Range()
-            _elem252.read(iprot)
-            self.success.add(_elem252)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = TableNotFoundException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('splitRangeByTablets_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.SET, 0)
-      oprot.writeSetBegin(TType.STRUCT, len(self.success))
-      for iter253 in self.success:
-        iter253.write(oprot)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableExists_args:
-  """
-  Attributes:
-   - login
-   - tableName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tableName=None,):
-    self.login = login
-    self.tableName = tableName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableExists_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableExists_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableExists_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableIdMap_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableIdMap_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class tableIdMap_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype255, _vtype256, _size254 ) = iprot.readMapBegin() 
-          for _i258 in xrange(_size254):
-            _key259 = iprot.readString();
-            _val260 = iprot.readString();
-            self.success[_key259] = _val260
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('tableIdMap_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter261,viter262 in self.success.items():
-        oprot.writeString(kiter261)
-        oprot.writeString(viter262)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class pingTabletServer_args:
-  """
-  Attributes:
-   - login
-   - tserver
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tserver', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tserver=None,):
-    self.login = login
-    self.tserver = tserver
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tserver = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('pingTabletServer_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tserver is not None:
-      oprot.writeFieldBegin('tserver', TType.STRING, 2)
-      oprot.writeString(self.tserver)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class pingTabletServer_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('pingTabletServer_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveScans_args:
-  """
-  Attributes:
-   - login
-   - tserver
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tserver', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tserver=None,):
-    self.login = login
-    self.tserver = tserver
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tserver = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveScans_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tserver is not None:
-      oprot.writeFieldBegin('tserver', TType.STRING, 2)
-      oprot.writeString(self.tserver)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveScans_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRUCT,(ActiveScan, ActiveScan.thrift_spec)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype266, _size263) = iprot.readListBegin()
-          for _i267 in xrange(_size263):
-            _elem268 = ActiveScan()
-            _elem268.read(iprot)
-            self.success.append(_elem268)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveScans_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRUCT, len(self.success))
-      for iter269 in self.success:
-        iter269.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveCompactions_args:
-  """
-  Attributes:
-   - login
-   - tserver
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tserver', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, tserver=None,):
-    self.login = login
-    self.tserver = tserver
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tserver = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveCompactions_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tserver is not None:
-      oprot.writeFieldBegin('tserver', TType.STRING, 2)
-      oprot.writeString(self.tserver)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getActiveCompactions_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRUCT,(ActiveCompaction, ActiveCompaction.thrift_spec)), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype273, _size270) = iprot.readListBegin()
-          for _i274 in xrange(_size270):
-            _elem275 = ActiveCompaction()
-            _elem275.read(iprot)
-            self.success.append(_elem275)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getActiveCompactions_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRUCT, len(self.success))
-      for iter276 in self.success:
-        iter276.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSiteConfiguration_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSiteConfiguration_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSiteConfiguration_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype278, _vtype279, _size277 ) = iprot.readMapBegin() 
-          for _i281 in xrange(_size277):
-            _key282 = iprot.readString();
-            _val283 = iprot.readString();
-            self.success[_key282] = _val283
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSiteConfiguration_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter284,viter285 in self.success.items():
-        oprot.writeString(kiter284)
-        oprot.writeString(viter285)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSystemConfiguration_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSystemConfiguration_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getSystemConfiguration_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.MAP:
-          self.success = {}
-          (_ktype287, _vtype288, _size286 ) = iprot.readMapBegin() 
-          for _i290 in xrange(_size286):
-            _key291 = iprot.readString();
-            _val292 = iprot.readString();
-            self.success[_key291] = _val292
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getSystemConfiguration_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.MAP, 0)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
-      for kiter293,viter294 in self.success.items():
-        oprot.writeString(kiter293)
-        oprot.writeString(viter294)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTabletServers_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTabletServers_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getTabletServers_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype298, _size295) = iprot.readListBegin()
-          for _i299 in xrange(_size295):
-            _elem300 = iprot.readString();
-            self.success.append(_elem300)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getTabletServers_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRING, len(self.success))
-      for iter301 in self.success:
-        oprot.writeString(iter301)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeProperty_args:
-  """
-  Attributes:
-   - login
-   - property
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'property', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, property=None,):
-    self.login = login
-    self.property = property
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 2)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class removeProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('removeProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setProperty_args:
-  """
-  Attributes:
-   - login
-   - property
-   - value
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'property', None, None, ), # 2
-    (3, TType.STRING, 'value', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, property=None, value=None,):
-    self.login = login
-    self.property = property
-    self.value = value
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.property = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setProperty_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.property is not None:
-      oprot.writeFieldBegin('property', TType.STRING, 2)
-      oprot.writeString(self.property)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 3)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class setProperty_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('setProperty_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class testClassLoad_args:
-  """
-  Attributes:
-   - login
-   - className
-   - asTypeName
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'className', None, None, ), # 2
-    (3, TType.STRING, 'asTypeName', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, className=None, asTypeName=None,):
-    self.login = login
-    self.className = className
-    self.asTypeName = asTypeName
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.className = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.asTypeName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('testClassLoad_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.className is not None:
-      oprot.writeFieldBegin('className', TType.STRING, 2)
-      oprot.writeString(self.className)
-      oprot.writeFieldEnd()
-    if self.asTypeName is not None:
-      oprot.writeFieldBegin('asTypeName', TType.STRING, 3)
-      oprot.writeString(self.asTypeName)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class testClassLoad_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('testClassLoad_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class authenticateUser_args:
-  """
-  Attributes:
-   - login
-   - user
-   - properties
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, properties=None,):
-    self.login = login
-    self.user = user
-    self.properties = properties
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.MAP:
-          self.properties = {}
-          (_ktype303, _vtype304, _size302 ) = iprot.readMapBegin() 
-          for _i306 in xrange(_size302):
-            _key307 = iprot.readString();
-            _val308 = iprot.readString();
-            self.properties[_key307] = _val308
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('authenticateUser_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.properties is not None:
-      oprot.writeFieldBegin('properties', TType.MAP, 3)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
-      for kiter309,viter310 in self.properties.items():
-        oprot.writeString(kiter309)
-        oprot.writeString(viter310)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class authenticateUser_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('authenticateUser_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeUserAuthorizations_args:
-  """
-  Attributes:
-   - login
-   - user
-   - authorizations
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, authorizations=None,):
-    self.login = login
-    self.user = user
-    self.authorizations = authorizations
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.SET:
-          self.authorizations = set()
-          (_etype314, _size311) = iprot.readSetBegin()
-          for _i315 in xrange(_size311):
-            _elem316 = iprot.readString();
-            self.authorizations.add(_elem316)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeUserAuthorizations_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.SET, 3)
-      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
-      for iter317 in self.authorizations:
-        oprot.writeString(iter317)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeUserAuthorizations_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeUserAuthorizations_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeLocalUserPassword_args:
-  """
-  Attributes:
-   - login
-   - user
-   - password
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'password', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, password=None,):
-    self.login = login
-    self.user = user
-    self.password = password
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.password = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeLocalUserPassword_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.password is not None:
-      oprot.writeFieldBegin('password', TType.STRING, 3)
-      oprot.writeString(self.password)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class changeLocalUserPassword_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('changeLocalUserPassword_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createLocalUser_args:
-  """
-  Attributes:
-   - login
-   - user
-   - password
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'password', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, password=None,):
-    self.login = login
-    self.user = user
-    self.password = password
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.password = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createLocalUser_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.password is not None:
-      oprot.writeFieldBegin('password', TType.STRING, 3)
-      oprot.writeString(self.password)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createLocalUser_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createLocalUser_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class dropLocalUser_args:
-  """
-  Attributes:
-   - login
-   - user
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, user=None,):
-    self.login = login
-    self.user = user
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('dropLocalUser_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class dropLocalUser_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('dropLocalUser_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getUserAuthorizations_args:
-  """
-  Attributes:
-   - login
-   - user
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-  )
-
-  def __init__(self, login=None, user=None,):
-    self.login = login
-    self.user = user
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getUserAuthorizations_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getUserAuthorizations_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.LIST:
-          self.success = []
-          (_etype321, _size318) = iprot.readListBegin()
-          for _i322 in xrange(_size318):
-            _elem323 = iprot.readString();
-            self.success.append(_elem323)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getUserAuthorizations_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.LIST, 0)
-      oprot.writeListBegin(TType.STRING, len(self.success))
-      for iter324 in self.success:
-        oprot.writeString(iter324)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantSystemPermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.I32, 'perm', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantSystemPermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 3)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantSystemPermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantSystemPermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantTablePermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - table
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I32, 'perm', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, user=None, table=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.table = table
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantTablePermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 4)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class grantTablePermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('grantTablePermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasSystemPermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.I32, 'perm', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasSystemPermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 3)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasSystemPermission_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasSystemPermission_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasTablePermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - table
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I32, 'perm', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, user=None, table=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.table = table
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasTablePermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 4)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasTablePermission_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasTablePermission_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listLocalUsers_args:
-  """
-  Attributes:
-   - login
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-  )
-
-  def __init__(self, login=None,):
-    self.login = login
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listLocalUsers_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class listLocalUsers_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.SET:
-          self.success = set()
-          (_etype328, _size325) = iprot.readSetBegin()
-          for _i329 in xrange(_size325):
-            _elem330 = iprot.readString();
-            self.success.add(_elem330)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('listLocalUsers_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.SET, 0)
-      oprot.writeSetBegin(TType.STRING, len(self.success))
-      for iter331 in self.success:
-        oprot.writeString(iter331)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeSystemPermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.I32, 'perm', None, None, ), # 3
-  )
-
-  def __init__(self, login=None, user=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeSystemPermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 3)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeSystemPermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeSystemPermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeTablePermission_args:
-  """
-  Attributes:
-   - login
-   - user
-   - table
-   - perm
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I32, 'perm', None, None, ), # 4
-  )
-
-  def __init__(self, login=None, user=None, table=None, perm=None,):
-    self.login = login
-    self.user = user
-    self.table = table
-    self.perm = perm
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.perm = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeTablePermission_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.perm is not None:
-      oprot.writeFieldBegin('perm', TType.I32, 4)
-      oprot.writeI32(self.perm)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class revokeTablePermission_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('revokeTablePermission_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createBatchScanner_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - options
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'options', (BatchScanOptions, BatchScanOptions.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, options=None,):
-    self.login = login
-    self.tableName = tableName
-    self.options = options
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.options = BatchScanOptions()
-          self.options.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createBatchScanner_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.options is not None:
-      oprot.writeFieldBegin('options', TType.STRUCT, 3)
-      self.options.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createBatchScanner_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createBatchScanner_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createScanner_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - options
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'options', (ScanOptions, ScanOptions.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, options=None,):
-    self.login = login
-    self.tableName = tableName
-    self.options = options
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.options = ScanOptions()
-          self.options.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createScanner_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.options is not None:
-      oprot.writeFieldBegin('options', TType.STRUCT, 3)
-      self.options.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createScanner_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = AccumuloException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createScanner_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasNext_args:
-  """
-  Attributes:
-   - scanner
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-  )
-
-  def __init__(self, scanner=None,):
-    self.scanner = scanner
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasNext_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class hasNext_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-  """
-
-  thrift_spec = (
-    (0, TType.BOOL, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, success=None, ouch1=None,):
-    self.success = success
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.BOOL:
-          self.success = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownScanner()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('hasNext_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.BOOL, 0)
-      oprot.writeBool(self.success)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextEntry_args:
-  """
-  Attributes:
-   - scanner
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-  )
-
-  def __init__(self, scanner=None,):
-    self.scanner = scanner
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextEntry_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextEntry_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (KeyValueAndPeek, KeyValueAndPeek.thrift_spec), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = KeyValueAndPeek()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = NoMoreEntriesException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = UnknownScanner()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextEntry_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextK_args:
-  """
-  Attributes:
-   - scanner
-   - k
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-    (2, TType.I32, 'k', None, None, ), # 2
-  )
-
-  def __init__(self, scanner=None, k=None,):
-    self.scanner = scanner
-    self.k = k
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I32:
-          self.k = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextK_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    if self.k is not None:
-      oprot.writeFieldBegin('k', TType.I32, 2)
-      oprot.writeI32(self.k)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class nextK_result:
-  """
-  Attributes:
-   - success
-   - ouch1
-   - ouch2
-   - ouch3
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ), # 0
-    (1, TType.STRUCT, 'ouch1', (NoMoreEntriesException, NoMoreEntriesException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 2
-    (3, TType.STRUCT, 'ouch3', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
-    self.success = success
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-    self.ouch3 = ouch3
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = ScanResult()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = NoMoreEntriesException()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = UnknownScanner()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.ouch3 = AccumuloSecurityException()
-          self.ouch3.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('nextK_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch3 is not None:
-      oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
-      self.ouch3.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeScanner_args:
-  """
-  Attributes:
-   - scanner
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'scanner', None, None, ), # 1
-  )
-
-  def __init__(self, scanner=None,):
-    self.scanner = scanner
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.scanner = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeScanner_args')
-    if self.scanner is not None:
-      oprot.writeFieldBegin('scanner', TType.STRING, 1)
-      oprot.writeString(self.scanner)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeScanner_result:
-  """
-  Attributes:
-   - ouch1
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownScanner, UnknownScanner.thrift_spec), None, ), # 1
-  )
-
-  def __init__(self, ouch1=None,):
-    self.ouch1 = ouch1
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownScanner()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeScanner_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class updateAndFlush_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - cells
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.MAP, 'cells', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnUpdate, ColumnUpdate.thrift_spec))), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, cells=None,):
-    self.login = login
-    self.tableName = tableName
-    self.cells = cells
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.MAP:
-          self.cells = {}
-          (_ktype333, _vtype334, _size332 ) = iprot.readMapBegin() 
-          for _i336 in xrange(_size332):
-            _key337 = iprot.readString();
-            _val338 = []
-            (_etype342, _size339) = iprot.readListBegin()
-            for _i343 in xrange(_size339):
-              _elem344 = ColumnUpdate()
-              _elem344.read(iprot)
-              _val338.append(_elem344)
-            iprot.readListEnd()
-            self.cells[_key337] = _val338
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('updateAndFlush_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.cells is not None:
-      oprot.writeFieldBegin('cells', TType.MAP, 3)
-      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
-      for kiter345,viter346 in self.cells.items():
-        oprot.writeString(kiter345)
-        oprot.writeListBegin(TType.STRUCT, len(viter346))
-        for iter347 in viter346:
-          iter347.write(oprot)
-        oprot.writeListEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class updateAndFlush_result:
-  """
-  Attributes:
-   - outch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, outch1=None, ouch2=None,):
-    self.outch1 = outch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.outch1 = AccumuloException()
-          self.outch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('updateAndFlush_result')
-    if self.outch1 is not None:
-      oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
-      self.outch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createWriter_args:
-  """
-  Attributes:
-   - login
-   - tableName
-   - opts
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'login', None, None, ), # 1
-    (2, TType.STRING, 'tableName', None, None, ), # 2
-    (3, TType.STRUCT, 'opts', (WriterOptions, WriterOptions.thrift_spec), None, ), # 3
-  )
-
-  def __init__(self, login=None, tableName=None, opts=None,):
-    self.login = login
-    self.tableName = tableName
-    self.opts = opts
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.login = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.tableName = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.opts = WriterOptions()
-          self.opts.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createWriter_args')
-    if self.login is not None:
-      oprot.writeFieldBegin('login', TType.STRING, 1)
-      oprot.writeString(self.login)
-      oprot.writeFieldEnd()
-    if self.tableName is not None:
-      oprot.writeFieldBegin('tableName', TType.STRING, 2)
-      oprot.writeString(self.tableName)
-      oprot.writeFieldEnd()
-    if self.opts is not None:
-      oprot.writeFieldBegin('opts', TType.STRUCT, 3)
-      self.opts.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class createWriter_result:
-  """
-  Attributes:
-   - success
-   - outch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    (0, TType.STRING, 'success', None, None, ), # 0
-    (1, TType.STRUCT, 'outch1', (AccumuloException, AccumuloException.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, success=None, outch1=None, ouch2=None,):
-    self.success = success
-    self.outch1 = outch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRING:
-          self.success = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 1:
-        if ftype == TType.STRUCT:
-          self.outch1 = AccumuloException()
-          self.outch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('createWriter_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRING, 0)
-      oprot.writeString(self.success)
-      oprot.writeFieldEnd()
-    if self.outch1 is not None:
-      oprot.writeFieldBegin('outch1', TType.STRUCT, 1)
-      self.outch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class update_args:
-  """
-  Attributes:
-   - writer
-   - cells
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'writer', None, None, ), # 1
-    (2, TType.MAP, 'cells', (TType.STRING,None,TType.LIST,(TType.STRUCT,(ColumnUpdate, ColumnUpdate.thrift_spec))), None, ), # 2
-  )
-
-  def __init__(self, writer=None, cells=None,):
-    self.writer = writer
-    self.cells = cells
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.writer = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.MAP:
-          self.cells = {}
-          (_ktype349, _vtype350, _size348 ) = iprot.readMapBegin() 
-          for _i352 in xrange(_size348):
-            _key353 = iprot.readString();
-            _val354 = []
-            (_etype358, _size355) = iprot.readListBegin()
-            for _i359 in xrange(_size355):
-              _elem360 = ColumnUpdate()
-              _elem360.read(iprot)
-              _val354.append(_elem360)
-            iprot.readListEnd()
-            self.cells[_key353] = _val354
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('update_args')
-    if self.writer is not None:
-      oprot.writeFieldBegin('writer', TType.STRING, 1)
-      oprot.writeString(self.writer)
-      oprot.writeFieldEnd()
-    if self.cells is not None:
-      oprot.writeFieldBegin('cells', TType.MAP, 2)
-      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.cells))
-      for kiter361,viter362 in self.cells.items():
-        oprot.writeString(kiter361)
-        oprot.writeListBegin(TType.STRUCT, len(viter362))
-        for iter363 in viter362:
-          iter363.write(oprot)
-        oprot.writeListEnd()
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flush_args:
-  """
-  Attributes:
-   - writer
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'writer', None, None, ), # 1
-  )
-
-  def __init__(self, writer=None,):
-    self.writer = writer
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.writer = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flush_args')
-    if self.writer is not None:
-      oprot.writeFieldBegin('writer', TType.STRING, 1)
-      oprot.writeString(self.writer)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class flush_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownWriter()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('flush_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeWriter_args:
-  """
-  Attributes:
-   - writer
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'writer', None, None, ), # 1
-  )
-
-  def __init__(self, writer=None,):
-    self.writer = writer
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.writer = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeWriter_args')
-    if self.writer is not None:
-      oprot.writeFieldBegin('writer', TType.STRING, 1)
-      oprot.writeString(self.writer)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class closeWriter_result:
-  """
-  Attributes:
-   - ouch1
-   - ouch2
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'ouch1', (UnknownWriter, UnknownWriter.thrift_spec), None, ), # 1
-    (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ), # 2
-  )
-
-  def __init__(self, ouch1=None, ouch2=None,):
-    self.ouch1 = ouch1
-    self.ouch2 = ouch2
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.ouch1 = UnknownWriter()
-          self.ouch1.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.ouch2 = AccumuloSecurityException()
-          self.ouch2.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('closeWriter_result')
-    if self.ouch1 is not None:
-      oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
-      self.ouch1.write(oprot)
-      oprot.writeFieldEnd()
-    if self.ouch2 is not None:
-      oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
-      self.ouch2.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getRowRange_args:
-  """
-  Attributes:
-   - row
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'row', None, None, ), # 1
-  )
-
-  def __init__(self, row=None,):
-    self.row = row
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.row = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getRowRange_args')
-    if self.row is not None:
-      oprot.writeFieldBegin('row', TType.STRING, 1)
-      oprot.writeString(self.row)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getRowRange_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (Range, Range.thrift_spec), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = Range()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getRowRange_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getFollowing_args:
-  """
-  Attributes:
-   - key
-   - part
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ), # 1
-    (2, TType.I32, 'part', None, None, ), # 2
-  )
-
-  def __init__(self, key=None, part=None,):
-    self.key = key
-    self.part = part
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.key = Key()
-          self.key.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I32:
-          self.part = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getFollowing_args')
-    if self.key is not None:
-      oprot.writeFieldBegin('key', TType.STRUCT, 1)
-      self.key.write(oprot)
-      oprot.writeFieldEnd()
-    if self.part is not None:
-      oprot.writeFieldBegin('part', TType.I32, 2)
-      oprot.writeI32(self.part)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class getFollowing_result:
-  """
-  Attributes:
-   - success
-  """
-
-  thrift_spec = (
-    (0, TType.STRUCT, 'success', (Key, Key.thrift_spec), None, ), # 0
-  )
-
-  def __init__(self, success=None,):
-    self.success = success
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 0:
-        if ftype == TType.STRUCT:
-          self.success = Key()
-          self.success.read(iprot)
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('getFollowing_result')
-    if self.success is not None:
-      oprot.writeFieldBegin('success', TType.STRUCT, 0)
-      self.success.write(oprot)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'login', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'namespaceName', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'className', 'UTF8', None, ),  # 3
+        (4, TType.STRING, 'asTypeName', 'UTF8', None, ),  # 4
+    )
+
+    def __init__(self, login=None, namespaceName=None, className=None, asTypeName=None,):
+        self.login = login
+        self.namespaceName = namespaceName
+        self.className = className
+        self.asTypeName = asTypeName
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.login = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.namespaceName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.asTypeName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testNamespaceClassLoad_args')
+        if self.login is not None:
+            oprot.writeFieldBegin('login', TType.STRING, 1)
+            oprot.writeBinary(self.login)
+            oprot.writeFieldEnd()
+        if self.namespaceName is not None:
+            oprot.writeFieldBegin('namespaceName', TType.STRING, 2)
+            oprot.writeString(self.namespaceName.encode('utf-8') if sys.version_info[0] == 2 else self.namespaceName)
+            oprot.writeFieldEnd()
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 3)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.asTypeName is not None:
+            oprot.writeFieldBegin('asTypeName', TType.STRING, 4)
+            oprot.writeString(self.asTypeName.encode('utf-8') if sys.version_info[0] == 2 else self.asTypeName)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class testNamespaceClassLoad_result(object):
+    """
+    Attributes:
+     - success
+     - ouch1
+     - ouch2
+     - ouch3
+    """
+
+    thrift_spec = (
+        (0, TType.BOOL, 'success', None, None, ),  # 0
+        (1, TType.STRUCT, 'ouch1', (AccumuloException, AccumuloException.thrift_spec), None, ),  # 1
+        (2, TType.STRUCT, 'ouch2', (AccumuloSecurityException, AccumuloSecurityException.thrift_spec), None, ),  # 2
+        (3, TType.STRUCT, 'ouch3', (NamespaceNotFoundException, NamespaceNotFoundException.thrift_spec), None, ),  # 3
+    )
+
+    def __init__(self, success=None, ouch1=None, ouch2=None, ouch3=None,):
+        self.success = success
+        self.ouch1 = ouch1
+        self.ouch2 = ouch2
+        self.ouch3 = ouch3
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.ouch1 = AccumuloException()
+                    self.ouch1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ouch2 = AccumuloSecurityException()
+                    self.ouch2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ouch3 = NamespaceNotFoundException()
+                    self.ouch3.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('testNamespaceClassLoad_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        if self.ouch1 is not None:
+            oprot.writeFieldBegin('ouch1', TType.STRUCT, 1)
+            self.ouch1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch2 is not None:
+            oprot.writeFieldBegin('ouch2', TType.STRUCT, 2)
+            self.ouch2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ouch3 is not None:
+            oprot.writeFieldBegin('ouch3', TType.STRUCT, 3)
+            self.ouch3.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __ne__(self, other):
-    return not (self == other)
+    def __ne__(self, other):
+        return not (self == other)
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/AccumuloProxy-remote pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy-remote
--- pyaccumulo/pyaccumulo/proxy/AccumuloProxy-remote	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/AccumuloProxy-remote	2017-03-15 22:24:26.486584651 +0000
@@ -1,6 +1,20 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 #!/usr/bin/env python
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
@@ -9,570 +23,802 @@
 
 import sys
 import pprint
-from urlparse import urlparse
-from thrift.transport import TTransport
-from thrift.transport import TSocket
-from thrift.transport import THttpClient
-from thrift.protocol import TBinaryProtocol
+if sys.version_info[0] > 2:
+    from urllib.parse import urlparse
+else:
+    from urlparse import urlparse
+from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
+from thrift.protocol.TBinaryProtocol import TBinaryProtocol
 
-import AccumuloProxy
-from ttypes import *
+from accumulo import AccumuloProxy
+from accumulo.ttypes import *
 
 if len(sys.argv) <= 1 or sys.argv[1] == '--help':
-  print ''
-  print 'Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] function [arg1 [arg2...]]'
-  print ''
-  print 'Functions:'
-  print '  string login(string principal,  loginProperties)'
-  print '  i32 addConstraint(string login, string tableName, string constraintClassName)'
-  print '  void addSplits(string login, string tableName,  splits)'
-  print '  void attachIterator(string login, string tableName, IteratorSetting setting,  scopes)'
-  print '  void checkIteratorConflicts(string login, string tableName, IteratorSetting setting,  scopes)'
-  print '  void clearLocatorCache(string login, string tableName)'
-  print '  void cloneTable(string login, string tableName, string newTableName, bool flush,  propertiesToSet,  propertiesToExclude)'
-  print '  void compactTable(string login, string tableName, string startRow, string endRow,  iterators, bool flush, bool wait)'
-  print '  void cancelCompaction(string login, string tableName)'
-  print '  void createTable(string login, string tableName, bool versioningIter, TimeType type)'
-  print '  void deleteTable(string login, string tableName)'
-  print '  void deleteRows(string login, string tableName, string startRow, string endRow)'
-  print '  void exportTable(string login, string tableName, string exportDir)'
-  print '  void flushTable(string login, string tableName, string startRow, string endRow, bool wait)'
-  print '   getLocalityGroups(string login, string tableName)'
-  print '  IteratorSetting getIteratorSetting(string login, string tableName, string iteratorName, IteratorScope scope)'
-  print '  string getMaxRow(string login, string tableName,  auths, string startRow, bool startInclusive, string endRow, bool endInclusive)'
-  print '   getTableProperties(string login, string tableName)'
-  print '   getSplits(string login, string tableName, i32 maxSplits)'
-  print '  void importDirectory(string login, string tableName, string importDir, string failureDir, bool setTime)'
-  print '  void importTable(string login, string tableName, string importDir)'
-  print '   listTables(string login)'
-  print '   listIterators(string login, string tableName)'
-  print '   listConstraints(string login, string tableName)'
-  print '  void mergeTablets(string login, string tableName, string startRow, string endRow)'
-  print '  void offlineTable(string login, string tableName)'
-  print '  void onlineTable(string login, string tableName)'
-  print '  void removeConstraint(string login, string tableName, i32 constraint)'
-  print '  void removeIterator(string login, string tableName, string iterName,  scopes)'
-  print '  void removeTableProperty(string login, string tableName, string property)'
-  print '  void renameTable(string login, string oldTableName, string newTableName)'
-  print '  void setLocalityGroups(string login, string tableName,  groups)'
-  print '  void setTableProperty(string login, string tableName, string property, string value)'
-  print '   splitRangeByTablets(string login, string tableName, Range range, i32 maxSplits)'
-  print '  bool tableExists(string login, string tableName)'
-  print '   tableIdMap(string login)'
-  print '  void pingTabletServer(string login, string tserver)'
-  print '   getActiveScans(string login, string tserver)'
-  print '   getActiveCompactions(string login, string tserver)'
-  print '   getSiteConfiguration(string login)'
-  print '   getSystemConfiguration(string login)'
-  print '   getTabletServers(string login)'
-  print '  void removeProperty(string login, string property)'
-  print '  void setProperty(string login, string property, string value)'
-  print '  bool testClassLoad(string login, string className, string asTypeName)'
-  print '  bool authenticateUser(string login, string user,  properties)'
-  print '  void changeUserAuthorizations(string login, string user,  authorizations)'
-  print '  void changeLocalUserPassword(string login, string user, string password)'
-  print '  void createLocalUser(string login, string user, string password)'
-  print '  void dropLocalUser(string login, string user)'
-  print '   getUserAuthorizations(string login, string user)'
-  print '  void grantSystemPermission(string login, string user, SystemPermission perm)'
-  print '  void grantTablePermission(string login, string user, string table, TablePermission perm)'
-  print '  bool hasSystemPermission(string login, string user, SystemPermission perm)'
-  print '  bool hasTablePermission(string login, string user, string table, TablePermission perm)'
-  print '   listLocalUsers(string login)'
-  print '  void revokeSystemPermission(string login, string user, SystemPermission perm)'
-  print '  void revokeTablePermission(string login, string user, string table, TablePermission perm)'
-  print '  string createBatchScanner(string login, string tableName, BatchScanOptions options)'
-  print '  string createScanner(string login, string tableName, ScanOptions options)'
-  print '  bool hasNext(string scanner)'
-  print '  KeyValueAndPeek nextEntry(string scanner)'
-  print '  ScanResult nextK(string scanner, i32 k)'
-  print '  void closeScanner(string scanner)'
-  print '  void updateAndFlush(string login, string tableName,  cells)'
-  print '  string createWriter(string login, string tableName, WriterOptions opts)'
-  print '  void update(string writer,  cells)'
-  print '  void flush(string writer)'
-  print '  void closeWriter(string writer)'
-  print '  Range getRowRange(string row)'
-  print '  Key getFollowing(Key key, PartialKey part)'
-  print ''
-  sys.exit(0)
+    print('')
+    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
+    print('')
+    print('Functions:')
+    print('  string login(string principal,  loginProperties)')
+    print('  i32 addConstraint(string login, string tableName, string constraintClassName)')
+    print('  void addSplits(string login, string tableName,  splits)')
+    print('  void attachIterator(string login, string tableName, IteratorSetting setting,  scopes)')
+    print('  void checkIteratorConflicts(string login, string tableName, IteratorSetting setting,  scopes)')
+    print('  void clearLocatorCache(string login, string tableName)')
+    print('  void cloneTable(string login, string tableName, string newTableName, bool flush,  propertiesToSet,  propertiesToExclude)')
+    print('  void compactTable(string login, string tableName, string startRow, string endRow,  iterators, bool flush, bool wait, CompactionStrategyConfig compactionStrategy)')
+    print('  void cancelCompaction(string login, string tableName)')
+    print('  void createTable(string login, string tableName, bool versioningIter, TimeType type)')
+    print('  void deleteTable(string login, string tableName)')
+    print('  void deleteRows(string login, string tableName, string startRow, string endRow)')
+    print('  void exportTable(string login, string tableName, string exportDir)')
+    print('  void flushTable(string login, string tableName, string startRow, string endRow, bool wait)')
+    print('   getDiskUsage(string login,  tables)')
+    print('   getLocalityGroups(string login, string tableName)')
+    print('  IteratorSetting getIteratorSetting(string login, string tableName, string iteratorName, IteratorScope scope)')
+    print('  string getMaxRow(string login, string tableName,  auths, string startRow, bool startInclusive, string endRow, bool endInclusive)')
+    print('   getTableProperties(string login, string tableName)')
+    print('  void importDirectory(string login, string tableName, string importDir, string failureDir, bool setTime)')
+    print('  void importTable(string login, string tableName, string importDir)')
+    print('   listSplits(string login, string tableName, i32 maxSplits)')
+    print('   listTables(string login)')
+    print('   listIterators(string login, string tableName)')
+    print('   listConstraints(string login, string tableName)')
+    print('  void mergeTablets(string login, string tableName, string startRow, string endRow)')
+    print('  void offlineTable(string login, string tableName, bool wait)')
+    print('  void onlineTable(string login, string tableName, bool wait)')
+    print('  void removeConstraint(string login, string tableName, i32 constraint)')
+    print('  void removeIterator(string login, string tableName, string iterName,  scopes)')
+    print('  void removeTableProperty(string login, string tableName, string property)')
+    print('  void renameTable(string login, string oldTableName, string newTableName)')
+    print('  void setLocalityGroups(string login, string tableName,  groups)')
+    print('  void setTableProperty(string login, string tableName, string property, string value)')
+    print('   splitRangeByTablets(string login, string tableName, Range range, i32 maxSplits)')
+    print('  bool tableExists(string login, string tableName)')
+    print('   tableIdMap(string login)')
+    print('  bool testTableClassLoad(string login, string tableName, string className, string asTypeName)')
+    print('  void pingTabletServer(string login, string tserver)')
+    print('   getActiveScans(string login, string tserver)')
+    print('   getActiveCompactions(string login, string tserver)')
+    print('   getSiteConfiguration(string login)')
+    print('   getSystemConfiguration(string login)')
+    print('   getTabletServers(string login)')
+    print('  void removeProperty(string login, string property)')
+    print('  void setProperty(string login, string property, string value)')
+    print('  bool testClassLoad(string login, string className, string asTypeName)')
+    print('  bool authenticateUser(string login, string user,  properties)')
+    print('  void changeUserAuthorizations(string login, string user,  authorizations)')
+    print('  void changeLocalUserPassword(string login, string user, string password)')
+    print('  void createLocalUser(string login, string user, string password)')
+    print('  void dropLocalUser(string login, string user)')
+    print('   getUserAuthorizations(string login, string user)')
+    print('  void grantSystemPermission(string login, string user, SystemPermission perm)')
+    print('  void grantTablePermission(string login, string user, string table, TablePermission perm)')
+    print('  bool hasSystemPermission(string login, string user, SystemPermission perm)')
+    print('  bool hasTablePermission(string login, string user, string table, TablePermission perm)')
+    print('   listLocalUsers(string login)')
+    print('  void revokeSystemPermission(string login, string user, SystemPermission perm)')
+    print('  void revokeTablePermission(string login, string user, string table, TablePermission perm)')
+    print('  void grantNamespacePermission(string login, string user, string namespaceName, NamespacePermission perm)')
+    print('  bool hasNamespacePermission(string login, string user, string namespaceName, NamespacePermission perm)')
+    print('  void revokeNamespacePermission(string login, string user, string namespaceName, NamespacePermission perm)')
+    print('  string createBatchScanner(string login, string tableName, BatchScanOptions options)')
+    print('  string createScanner(string login, string tableName, ScanOptions options)')
+    print('  bool hasNext(string scanner)')
+    print('  KeyValueAndPeek nextEntry(string scanner)')
+    print('  ScanResult nextK(string scanner, i32 k)')
+    print('  void closeScanner(string scanner)')
+    print('  void updateAndFlush(string login, string tableName,  cells)')
+    print('  string createWriter(string login, string tableName, WriterOptions opts)')
+    print('  void update(string writer,  cells)')
+    print('  void flush(string writer)')
+    print('  void closeWriter(string writer)')
+    print('  ConditionalStatus updateRowConditionally(string login, string tableName, string row, ConditionalUpdates updates)')
+    print('  string createConditionalWriter(string login, string tableName, ConditionalWriterOptions options)')
+    print('   updateRowsConditionally(string conditionalWriter,  updates)')
+    print('  void closeConditionalWriter(string conditionalWriter)')
+    print('  Range getRowRange(string row)')
+    print('  Key getFollowing(Key key, PartialKey part)')
+    print('  string systemNamespace()')
+    print('  string defaultNamespace()')
+    print('   listNamespaces(string login)')
+    print('  bool namespaceExists(string login, string namespaceName)')
+    print('  void createNamespace(string login, string namespaceName)')
+    print('  void deleteNamespace(string login, string namespaceName)')
+    print('  void renameNamespace(string login, string oldNamespaceName, string newNamespaceName)')
+    print('  void setNamespaceProperty(string login, string namespaceName, string property, string value)')
+    print('  void removeNamespaceProperty(string login, string namespaceName, string property)')
+    print('   getNamespaceProperties(string login, string namespaceName)')
+    print('   namespaceIdMap(string login)')
+    print('  void attachNamespaceIterator(string login, string namespaceName, IteratorSetting setting,  scopes)')
+    print('  void removeNamespaceIterator(string login, string namespaceName, string name,  scopes)')
+    print('  IteratorSetting getNamespaceIteratorSetting(string login, string namespaceName, string name, IteratorScope scope)')
+    print('   listNamespaceIterators(string login, string namespaceName)')
+    print('  void checkNamespaceIteratorConflicts(string login, string namespaceName, IteratorSetting setting,  scopes)')
+    print('  i32 addNamespaceConstraint(string login, string namespaceName, string constraintClassName)')
+    print('  void removeNamespaceConstraint(string login, string namespaceName, i32 id)')
+    print('   listNamespaceConstraints(string login, string namespaceName)')
+    print('  bool testNamespaceClassLoad(string login, string namespaceName, string className, string asTypeName)')
+    print('')
+    sys.exit(0)
 
-pp = pprint.PrettyPrinter(indent = 2)
+pp = pprint.PrettyPrinter(indent=2)
 host = 'localhost'
 port = 9090
 uri = ''
 framed = False
+ssl = False
+validate = True
+ca_certs = None
+keyfile = None
+certfile = None
 http = False
 argi = 1
 
 if sys.argv[argi] == '-h':
-  parts = sys.argv[argi+1].split(':')
-  host = parts[0]
-  if len(parts) > 1:
-    port = int(parts[1])
-  argi += 2
+    parts = sys.argv[argi + 1].split(':')
+    host = parts[0]
+    if len(parts) > 1:
+        port = int(parts[1])
+    argi += 2
 
 if sys.argv[argi] == '-u':
-  url = urlparse(sys.argv[argi+1])
-  parts = url[1].split(':')
-  host = parts[0]
-  if len(parts) > 1:
-    port = int(parts[1])
-  else:
-    port = 80
-  uri = url[2]
-  if url[4]:
-    uri += '?%s' % url[4]
-  http = True
-  argi += 2
+    url = urlparse(sys.argv[argi + 1])
+    parts = url[1].split(':')
+    host = parts[0]
+    if len(parts) > 1:
+        port = int(parts[1])
+    else:
+        port = 80
+    uri = url[2]
+    if url[4]:
+        uri += '?%s' % url[4]
+    http = True
+    argi += 2
 
 if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
-  framed = True
-  argi += 1
+    framed = True
+    argi += 1
+
+if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
+    ssl = True
+    argi += 1
+
+if sys.argv[argi] == '-novalidate':
+    validate = False
+    argi += 1
+
+if sys.argv[argi] == '-ca_certs':
+    ca_certs = sys.argv[argi+1]
+    argi += 2
+
+if sys.argv[argi] == '-keyfile':
+    keyfile = sys.argv[argi+1]
+    argi += 2
+
+if sys.argv[argi] == '-certfile':
+    certfile = sys.argv[argi+1]
+    argi += 2
 
 cmd = sys.argv[argi]
-args = sys.argv[argi+1:]
+args = sys.argv[argi + 1:]
 
 if http:
-  transport = THttpClient.THttpClient(host, port, uri)
+    transport = THttpClient.THttpClient(host, port, uri)
 else:
-  socket = TSocket.TSocket(host, port)
-  if framed:
-    transport = TTransport.TFramedTransport(socket)
-  else:
-    transport = TTransport.TBufferedTransport(socket)
-protocol = TBinaryProtocol.TBinaryProtocol(transport)
+    if ssl:
+        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
+    else:
+        socket = TSocket.TSocket(host, port)
+    if framed:
+        transport = TTransport.TFramedTransport(socket)
+    else:
+        transport = TTransport.TBufferedTransport(socket)
+protocol = TBinaryProtocol(transport)
 client = AccumuloProxy.Client(protocol)
 transport.open()
 
 if cmd == 'login':
-  if len(args) != 2:
-    print 'login requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.login(args[0],eval(args[1]),))
+    if len(args) != 2:
+        print('login requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.login(args[0], eval(args[1]),))
 
 elif cmd == 'addConstraint':
-  if len(args) != 3:
-    print 'addConstraint requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.addConstraint(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('addConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.addConstraint(args[0], args[1], args[2],))
 
 elif cmd == 'addSplits':
-  if len(args) != 3:
-    print 'addSplits requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.addSplits(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('addSplits requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.addSplits(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'attachIterator':
-  if len(args) != 4:
-    print 'attachIterator requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.attachIterator(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('attachIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.attachIterator(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'checkIteratorConflicts':
-  if len(args) != 4:
-    print 'checkIteratorConflicts requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.checkIteratorConflicts(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('checkIteratorConflicts requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.checkIteratorConflicts(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'clearLocatorCache':
-  if len(args) != 2:
-    print 'clearLocatorCache requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.clearLocatorCache(args[0],args[1],))
+    if len(args) != 2:
+        print('clearLocatorCache requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.clearLocatorCache(args[0], args[1],))
 
 elif cmd == 'cloneTable':
-  if len(args) != 6:
-    print 'cloneTable requires 6 args'
-    sys.exit(1)
-  pp.pprint(client.cloneTable(args[0],args[1],args[2],eval(args[3]),eval(args[4]),eval(args[5]),))
+    if len(args) != 6:
+        print('cloneTable requires 6 args')
+        sys.exit(1)
+    pp.pprint(client.cloneTable(args[0], args[1], args[2], eval(args[3]), eval(args[4]), eval(args[5]),))
 
 elif cmd == 'compactTable':
-  if len(args) != 7:
-    print 'compactTable requires 7 args'
-    sys.exit(1)
-  pp.pprint(client.compactTable(args[0],args[1],args[2],args[3],eval(args[4]),eval(args[5]),eval(args[6]),))
+    if len(args) != 8:
+        print('compactTable requires 8 args')
+        sys.exit(1)
+    pp.pprint(client.compactTable(args[0], args[1], args[2], args[3], eval(args[4]), eval(args[5]), eval(args[6]), eval(args[7]),))
 
 elif cmd == 'cancelCompaction':
-  if len(args) != 2:
-    print 'cancelCompaction requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.cancelCompaction(args[0],args[1],))
+    if len(args) != 2:
+        print('cancelCompaction requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.cancelCompaction(args[0], args[1],))
 
 elif cmd == 'createTable':
-  if len(args) != 4:
-    print 'createTable requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.createTable(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('createTable requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.createTable(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'deleteTable':
-  if len(args) != 2:
-    print 'deleteTable requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.deleteTable(args[0],args[1],))
+    if len(args) != 2:
+        print('deleteTable requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.deleteTable(args[0], args[1],))
 
 elif cmd == 'deleteRows':
-  if len(args) != 4:
-    print 'deleteRows requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.deleteRows(args[0],args[1],args[2],args[3],))
+    if len(args) != 4:
+        print('deleteRows requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.deleteRows(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'exportTable':
-  if len(args) != 3:
-    print 'exportTable requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.exportTable(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('exportTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.exportTable(args[0], args[1], args[2],))
 
 elif cmd == 'flushTable':
-  if len(args) != 5:
-    print 'flushTable requires 5 args'
-    sys.exit(1)
-  pp.pprint(client.flushTable(args[0],args[1],args[2],args[3],eval(args[4]),))
+    if len(args) != 5:
+        print('flushTable requires 5 args')
+        sys.exit(1)
+    pp.pprint(client.flushTable(args[0], args[1], args[2], args[3], eval(args[4]),))
+
+elif cmd == 'getDiskUsage':
+    if len(args) != 2:
+        print('getDiskUsage requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getDiskUsage(args[0], eval(args[1]),))
 
 elif cmd == 'getLocalityGroups':
-  if len(args) != 2:
-    print 'getLocalityGroups requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getLocalityGroups(args[0],args[1],))
+    if len(args) != 2:
+        print('getLocalityGroups requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getLocalityGroups(args[0], args[1],))
 
 elif cmd == 'getIteratorSetting':
-  if len(args) != 4:
-    print 'getIteratorSetting requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.getIteratorSetting(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('getIteratorSetting requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.getIteratorSetting(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'getMaxRow':
-  if len(args) != 7:
-    print 'getMaxRow requires 7 args'
-    sys.exit(1)
-  pp.pprint(client.getMaxRow(args[0],args[1],eval(args[2]),args[3],eval(args[4]),args[5],eval(args[6]),))
+    if len(args) != 7:
+        print('getMaxRow requires 7 args')
+        sys.exit(1)
+    pp.pprint(client.getMaxRow(args[0], args[1], eval(args[2]), args[3], eval(args[4]), args[5], eval(args[6]),))
 
 elif cmd == 'getTableProperties':
-  if len(args) != 2:
-    print 'getTableProperties requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getTableProperties(args[0],args[1],))
-
-elif cmd == 'getSplits':
-  if len(args) != 3:
-    print 'getSplits requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.getSplits(args[0],args[1],eval(args[2]),))
+    if len(args) != 2:
+        print('getTableProperties requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getTableProperties(args[0], args[1],))
 
 elif cmd == 'importDirectory':
-  if len(args) != 5:
-    print 'importDirectory requires 5 args'
-    sys.exit(1)
-  pp.pprint(client.importDirectory(args[0],args[1],args[2],args[3],eval(args[4]),))
+    if len(args) != 5:
+        print('importDirectory requires 5 args')
+        sys.exit(1)
+    pp.pprint(client.importDirectory(args[0], args[1], args[2], args[3], eval(args[4]),))
 
 elif cmd == 'importTable':
-  if len(args) != 3:
-    print 'importTable requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.importTable(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('importTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.importTable(args[0], args[1], args[2],))
+
+elif cmd == 'listSplits':
+    if len(args) != 3:
+        print('listSplits requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.listSplits(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'listTables':
-  if len(args) != 1:
-    print 'listTables requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.listTables(args[0],))
+    if len(args) != 1:
+        print('listTables requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.listTables(args[0],))
 
 elif cmd == 'listIterators':
-  if len(args) != 2:
-    print 'listIterators requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.listIterators(args[0],args[1],))
+    if len(args) != 2:
+        print('listIterators requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listIterators(args[0], args[1],))
 
 elif cmd == 'listConstraints':
-  if len(args) != 2:
-    print 'listConstraints requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.listConstraints(args[0],args[1],))
+    if len(args) != 2:
+        print('listConstraints requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listConstraints(args[0], args[1],))
 
 elif cmd == 'mergeTablets':
-  if len(args) != 4:
-    print 'mergeTablets requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.mergeTablets(args[0],args[1],args[2],args[3],))
+    if len(args) != 4:
+        print('mergeTablets requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.mergeTablets(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'offlineTable':
-  if len(args) != 2:
-    print 'offlineTable requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.offlineTable(args[0],args[1],))
+    if len(args) != 3:
+        print('offlineTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.offlineTable(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'onlineTable':
-  if len(args) != 2:
-    print 'onlineTable requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.onlineTable(args[0],args[1],))
+    if len(args) != 3:
+        print('onlineTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.onlineTable(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'removeConstraint':
-  if len(args) != 3:
-    print 'removeConstraint requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.removeConstraint(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('removeConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeConstraint(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'removeIterator':
-  if len(args) != 4:
-    print 'removeIterator requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.removeIterator(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('removeIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.removeIterator(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'removeTableProperty':
-  if len(args) != 3:
-    print 'removeTableProperty requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.removeTableProperty(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('removeTableProperty requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeTableProperty(args[0], args[1], args[2],))
 
 elif cmd == 'renameTable':
-  if len(args) != 3:
-    print 'renameTable requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.renameTable(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('renameTable requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.renameTable(args[0], args[1], args[2],))
 
 elif cmd == 'setLocalityGroups':
-  if len(args) != 3:
-    print 'setLocalityGroups requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.setLocalityGroups(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('setLocalityGroups requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.setLocalityGroups(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'setTableProperty':
-  if len(args) != 4:
-    print 'setTableProperty requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.setTableProperty(args[0],args[1],args[2],args[3],))
+    if len(args) != 4:
+        print('setTableProperty requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.setTableProperty(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'splitRangeByTablets':
-  if len(args) != 4:
-    print 'splitRangeByTablets requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.splitRangeByTablets(args[0],args[1],eval(args[2]),eval(args[3]),))
+    if len(args) != 4:
+        print('splitRangeByTablets requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.splitRangeByTablets(args[0], args[1], eval(args[2]), eval(args[3]),))
 
 elif cmd == 'tableExists':
-  if len(args) != 2:
-    print 'tableExists requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.tableExists(args[0],args[1],))
+    if len(args) != 2:
+        print('tableExists requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.tableExists(args[0], args[1],))
 
 elif cmd == 'tableIdMap':
-  if len(args) != 1:
-    print 'tableIdMap requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.tableIdMap(args[0],))
+    if len(args) != 1:
+        print('tableIdMap requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.tableIdMap(args[0],))
+
+elif cmd == 'testTableClassLoad':
+    if len(args) != 4:
+        print('testTableClassLoad requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.testTableClassLoad(args[0], args[1], args[2], args[3],))
 
 elif cmd == 'pingTabletServer':
-  if len(args) != 2:
-    print 'pingTabletServer requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.pingTabletServer(args[0],args[1],))
+    if len(args) != 2:
+        print('pingTabletServer requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.pingTabletServer(args[0], args[1],))
 
 elif cmd == 'getActiveScans':
-  if len(args) != 2:
-    print 'getActiveScans requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getActiveScans(args[0],args[1],))
+    if len(args) != 2:
+        print('getActiveScans requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getActiveScans(args[0], args[1],))
 
 elif cmd == 'getActiveCompactions':
-  if len(args) != 2:
-    print 'getActiveCompactions requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getActiveCompactions(args[0],args[1],))
+    if len(args) != 2:
+        print('getActiveCompactions requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getActiveCompactions(args[0], args[1],))
 
 elif cmd == 'getSiteConfiguration':
-  if len(args) != 1:
-    print 'getSiteConfiguration requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getSiteConfiguration(args[0],))
+    if len(args) != 1:
+        print('getSiteConfiguration requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getSiteConfiguration(args[0],))
 
 elif cmd == 'getSystemConfiguration':
-  if len(args) != 1:
-    print 'getSystemConfiguration requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getSystemConfiguration(args[0],))
+    if len(args) != 1:
+        print('getSystemConfiguration requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getSystemConfiguration(args[0],))
 
 elif cmd == 'getTabletServers':
-  if len(args) != 1:
-    print 'getTabletServers requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getTabletServers(args[0],))
+    if len(args) != 1:
+        print('getTabletServers requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getTabletServers(args[0],))
 
 elif cmd == 'removeProperty':
-  if len(args) != 2:
-    print 'removeProperty requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.removeProperty(args[0],args[1],))
+    if len(args) != 2:
+        print('removeProperty requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.removeProperty(args[0], args[1],))
 
 elif cmd == 'setProperty':
-  if len(args) != 3:
-    print 'setProperty requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.setProperty(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('setProperty requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.setProperty(args[0], args[1], args[2],))
 
 elif cmd == 'testClassLoad':
-  if len(args) != 3:
-    print 'testClassLoad requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.testClassLoad(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('testClassLoad requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.testClassLoad(args[0], args[1], args[2],))
 
 elif cmd == 'authenticateUser':
-  if len(args) != 3:
-    print 'authenticateUser requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.authenticateUser(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('authenticateUser requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.authenticateUser(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'changeUserAuthorizations':
-  if len(args) != 3:
-    print 'changeUserAuthorizations requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.changeUserAuthorizations(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('changeUserAuthorizations requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.changeUserAuthorizations(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'changeLocalUserPassword':
-  if len(args) != 3:
-    print 'changeLocalUserPassword requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.changeLocalUserPassword(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('changeLocalUserPassword requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.changeLocalUserPassword(args[0], args[1], args[2],))
 
 elif cmd == 'createLocalUser':
-  if len(args) != 3:
-    print 'createLocalUser requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createLocalUser(args[0],args[1],args[2],))
+    if len(args) != 3:
+        print('createLocalUser requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createLocalUser(args[0], args[1], args[2],))
 
 elif cmd == 'dropLocalUser':
-  if len(args) != 2:
-    print 'dropLocalUser requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.dropLocalUser(args[0],args[1],))
+    if len(args) != 2:
+        print('dropLocalUser requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.dropLocalUser(args[0], args[1],))
 
 elif cmd == 'getUserAuthorizations':
-  if len(args) != 2:
-    print 'getUserAuthorizations requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getUserAuthorizations(args[0],args[1],))
+    if len(args) != 2:
+        print('getUserAuthorizations requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getUserAuthorizations(args[0], args[1],))
 
 elif cmd == 'grantSystemPermission':
-  if len(args) != 3:
-    print 'grantSystemPermission requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.grantSystemPermission(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('grantSystemPermission requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.grantSystemPermission(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'grantTablePermission':
-  if len(args) != 4:
-    print 'grantTablePermission requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.grantTablePermission(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('grantTablePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.grantTablePermission(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'hasSystemPermission':
-  if len(args) != 3:
-    print 'hasSystemPermission requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.hasSystemPermission(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('hasSystemPermission requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.hasSystemPermission(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'hasTablePermission':
-  if len(args) != 4:
-    print 'hasTablePermission requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.hasTablePermission(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('hasTablePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.hasTablePermission(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'listLocalUsers':
-  if len(args) != 1:
-    print 'listLocalUsers requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.listLocalUsers(args[0],))
+    if len(args) != 1:
+        print('listLocalUsers requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.listLocalUsers(args[0],))
 
 elif cmd == 'revokeSystemPermission':
-  if len(args) != 3:
-    print 'revokeSystemPermission requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.revokeSystemPermission(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('revokeSystemPermission requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.revokeSystemPermission(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'revokeTablePermission':
-  if len(args) != 4:
-    print 'revokeTablePermission requires 4 args'
-    sys.exit(1)
-  pp.pprint(client.revokeTablePermission(args[0],args[1],args[2],eval(args[3]),))
+    if len(args) != 4:
+        print('revokeTablePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.revokeTablePermission(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'grantNamespacePermission':
+    if len(args) != 4:
+        print('grantNamespacePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.grantNamespacePermission(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'hasNamespacePermission':
+    if len(args) != 4:
+        print('hasNamespacePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.hasNamespacePermission(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'revokeNamespacePermission':
+    if len(args) != 4:
+        print('revokeNamespacePermission requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.revokeNamespacePermission(args[0], args[1], args[2], eval(args[3]),))
 
 elif cmd == 'createBatchScanner':
-  if len(args) != 3:
-    print 'createBatchScanner requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createBatchScanner(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('createBatchScanner requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createBatchScanner(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'createScanner':
-  if len(args) != 3:
-    print 'createScanner requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createScanner(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('createScanner requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createScanner(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'hasNext':
-  if len(args) != 1:
-    print 'hasNext requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.hasNext(args[0],))
+    if len(args) != 1:
+        print('hasNext requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.hasNext(args[0],))
 
 elif cmd == 'nextEntry':
-  if len(args) != 1:
-    print 'nextEntry requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.nextEntry(args[0],))
+    if len(args) != 1:
+        print('nextEntry requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.nextEntry(args[0],))
 
 elif cmd == 'nextK':
-  if len(args) != 2:
-    print 'nextK requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.nextK(args[0],eval(args[1]),))
+    if len(args) != 2:
+        print('nextK requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.nextK(args[0], eval(args[1]),))
 
 elif cmd == 'closeScanner':
-  if len(args) != 1:
-    print 'closeScanner requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.closeScanner(args[0],))
+    if len(args) != 1:
+        print('closeScanner requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.closeScanner(args[0],))
 
 elif cmd == 'updateAndFlush':
-  if len(args) != 3:
-    print 'updateAndFlush requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.updateAndFlush(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('updateAndFlush requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.updateAndFlush(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'createWriter':
-  if len(args) != 3:
-    print 'createWriter requires 3 args'
-    sys.exit(1)
-  pp.pprint(client.createWriter(args[0],args[1],eval(args[2]),))
+    if len(args) != 3:
+        print('createWriter requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createWriter(args[0], args[1], eval(args[2]),))
 
 elif cmd == 'update':
-  if len(args) != 2:
-    print 'update requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.update(args[0],eval(args[1]),))
+    if len(args) != 2:
+        print('update requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.update(args[0], eval(args[1]),))
 
 elif cmd == 'flush':
-  if len(args) != 1:
-    print 'flush requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.flush(args[0],))
+    if len(args) != 1:
+        print('flush requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.flush(args[0],))
 
 elif cmd == 'closeWriter':
-  if len(args) != 1:
-    print 'closeWriter requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.closeWriter(args[0],))
+    if len(args) != 1:
+        print('closeWriter requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.closeWriter(args[0],))
+
+elif cmd == 'updateRowConditionally':
+    if len(args) != 4:
+        print('updateRowConditionally requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.updateRowConditionally(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'createConditionalWriter':
+    if len(args) != 3:
+        print('createConditionalWriter requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.createConditionalWriter(args[0], args[1], eval(args[2]),))
+
+elif cmd == 'updateRowsConditionally':
+    if len(args) != 2:
+        print('updateRowsConditionally requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.updateRowsConditionally(args[0], eval(args[1]),))
+
+elif cmd == 'closeConditionalWriter':
+    if len(args) != 1:
+        print('closeConditionalWriter requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.closeConditionalWriter(args[0],))
 
 elif cmd == 'getRowRange':
-  if len(args) != 1:
-    print 'getRowRange requires 1 args'
-    sys.exit(1)
-  pp.pprint(client.getRowRange(args[0],))
+    if len(args) != 1:
+        print('getRowRange requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.getRowRange(args[0],))
 
 elif cmd == 'getFollowing':
-  if len(args) != 2:
-    print 'getFollowing requires 2 args'
-    sys.exit(1)
-  pp.pprint(client.getFollowing(eval(args[0]),eval(args[1]),))
+    if len(args) != 2:
+        print('getFollowing requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getFollowing(eval(args[0]), eval(args[1]),))
+
+elif cmd == 'systemNamespace':
+    if len(args) != 0:
+        print('systemNamespace requires 0 args')
+        sys.exit(1)
+    pp.pprint(client.systemNamespace())
+
+elif cmd == 'defaultNamespace':
+    if len(args) != 0:
+        print('defaultNamespace requires 0 args')
+        sys.exit(1)
+    pp.pprint(client.defaultNamespace())
+
+elif cmd == 'listNamespaces':
+    if len(args) != 1:
+        print('listNamespaces requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.listNamespaces(args[0],))
+
+elif cmd == 'namespaceExists':
+    if len(args) != 2:
+        print('namespaceExists requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.namespaceExists(args[0], args[1],))
+
+elif cmd == 'createNamespace':
+    if len(args) != 2:
+        print('createNamespace requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.createNamespace(args[0], args[1],))
+
+elif cmd == 'deleteNamespace':
+    if len(args) != 2:
+        print('deleteNamespace requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.deleteNamespace(args[0], args[1],))
+
+elif cmd == 'renameNamespace':
+    if len(args) != 3:
+        print('renameNamespace requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.renameNamespace(args[0], args[1], args[2],))
+
+elif cmd == 'setNamespaceProperty':
+    if len(args) != 4:
+        print('setNamespaceProperty requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.setNamespaceProperty(args[0], args[1], args[2], args[3],))
+
+elif cmd == 'removeNamespaceProperty':
+    if len(args) != 3:
+        print('removeNamespaceProperty requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeNamespaceProperty(args[0], args[1], args[2],))
+
+elif cmd == 'getNamespaceProperties':
+    if len(args) != 2:
+        print('getNamespaceProperties requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.getNamespaceProperties(args[0], args[1],))
+
+elif cmd == 'namespaceIdMap':
+    if len(args) != 1:
+        print('namespaceIdMap requires 1 args')
+        sys.exit(1)
+    pp.pprint(client.namespaceIdMap(args[0],))
+
+elif cmd == 'attachNamespaceIterator':
+    if len(args) != 4:
+        print('attachNamespaceIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.attachNamespaceIterator(args[0], args[1], eval(args[2]), eval(args[3]),))
+
+elif cmd == 'removeNamespaceIterator':
+    if len(args) != 4:
+        print('removeNamespaceIterator requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.removeNamespaceIterator(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'getNamespaceIteratorSetting':
+    if len(args) != 4:
+        print('getNamespaceIteratorSetting requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.getNamespaceIteratorSetting(args[0], args[1], args[2], eval(args[3]),))
+
+elif cmd == 'listNamespaceIterators':
+    if len(args) != 2:
+        print('listNamespaceIterators requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listNamespaceIterators(args[0], args[1],))
+
+elif cmd == 'checkNamespaceIteratorConflicts':
+    if len(args) != 4:
+        print('checkNamespaceIteratorConflicts requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.checkNamespaceIteratorConflicts(args[0], args[1], eval(args[2]), eval(args[3]),))
+
+elif cmd == 'addNamespaceConstraint':
+    if len(args) != 3:
+        print('addNamespaceConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.addNamespaceConstraint(args[0], args[1], args[2],))
+
+elif cmd == 'removeNamespaceConstraint':
+    if len(args) != 3:
+        print('removeNamespaceConstraint requires 3 args')
+        sys.exit(1)
+    pp.pprint(client.removeNamespaceConstraint(args[0], args[1], eval(args[2]),))
+
+elif cmd == 'listNamespaceConstraints':
+    if len(args) != 2:
+        print('listNamespaceConstraints requires 2 args')
+        sys.exit(1)
+    pp.pprint(client.listNamespaceConstraints(args[0], args[1],))
+
+elif cmd == 'testNamespaceClassLoad':
+    if len(args) != 4:
+        print('testNamespaceClassLoad requires 4 args')
+        sys.exit(1)
+    pp.pprint(client.testNamespaceClassLoad(args[0], args[1], args[2], args[3],))
 
 else:
-  print 'Unrecognized method %s' % cmd
-  sys.exit(1)
+    print('Unrecognized method %s' % cmd)
+    sys.exit(1)
 
 transport.close()
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/constants.py pyaccumulo-new/pyaccumulo/proxy/constants.py
--- pyaccumulo/pyaccumulo/proxy/constants.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/constants.py	2017-03-15 22:24:26.486584651 +0000
@@ -1,11 +1,26 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TException, TApplicationException
-from ttypes import *
-
+from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+from thrift.protocol.TProtocol import TProtocolException
+import sys
+from .ttypes import *
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/__init__.py pyaccumulo-new/pyaccumulo/proxy/__init__.py
--- pyaccumulo/pyaccumulo/proxy/__init__.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/__init__.py	2017-03-15 22:24:26.486584651 +0000
@@ -1 +1,15 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
 __all__ = ['ttypes', 'constants', 'AccumuloProxy']
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/pyaccumulo/proxy/ttypes.py pyaccumulo-new/pyaccumulo/proxy/ttypes.py
--- pyaccumulo/pyaccumulo/proxy/ttypes.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/pyaccumulo/proxy/ttypes.py	2017-03-15 22:31:55.002584651 +0000
@@ -1,2314 +1,3167 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
 #
-# Autogenerated by Thrift Compiler (0.9.0)
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Autogenerated by Thrift Compiler (0.10.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+from thrift.protocol.TProtocol import TProtocolException
+import sys
 
 from thrift.transport import TTransport
-from thrift.protocol import TBinaryProtocol, TProtocol
-try:
-  from thrift.protocol import fastbinary
-except:
-  fastbinary = None
-
-
-class PartialKey:
-  ROW = 0
-  ROW_COLFAM = 1
-  ROW_COLFAM_COLQUAL = 2
-  ROW_COLFAM_COLQUAL_COLVIS = 3
-  ROW_COLFAM_COLQUAL_COLVIS_TIME = 4
-  ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL = 5
-
-  _VALUES_TO_NAMES = {
-    0: "ROW",
-    1: "ROW_COLFAM",
-    2: "ROW_COLFAM_COLQUAL",
-    3: "ROW_COLFAM_COLQUAL_COLVIS",
-    4: "ROW_COLFAM_COLQUAL_COLVIS_TIME",
-    5: "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL",
-  }
-
-  _NAMES_TO_VALUES = {
-    "ROW": 0,
-    "ROW_COLFAM": 1,
-    "ROW_COLFAM_COLQUAL": 2,
-    "ROW_COLFAM_COLQUAL_COLVIS": 3,
-    "ROW_COLFAM_COLQUAL_COLVIS_TIME": 4,
-    "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL": 5,
-  }
-
-class TablePermission:
-  READ = 2
-  WRITE = 3
-  BULK_IMPORT = 4
-  ALTER_TABLE = 5
-  GRANT = 6
-  DROP_TABLE = 7
-
-  _VALUES_TO_NAMES = {
-    2: "READ",
-    3: "WRITE",
-    4: "BULK_IMPORT",
-    5: "ALTER_TABLE",
-    6: "GRANT",
-    7: "DROP_TABLE",
-  }
-
-  _NAMES_TO_VALUES = {
-    "READ": 2,
-    "WRITE": 3,
-    "BULK_IMPORT": 4,
-    "ALTER_TABLE": 5,
-    "GRANT": 6,
-    "DROP_TABLE": 7,
-  }
-
-class SystemPermission:
-  GRANT = 0
-  CREATE_TABLE = 1
-  DROP_TABLE = 2
-  ALTER_TABLE = 3
-  CREATE_USER = 4
-  DROP_USER = 5
-  ALTER_USER = 6
-  SYSTEM = 7
-
-  _VALUES_TO_NAMES = {
-    0: "GRANT",
-    1: "CREATE_TABLE",
-    2: "DROP_TABLE",
-    3: "ALTER_TABLE",
-    4: "CREATE_USER",
-    5: "DROP_USER",
-    6: "ALTER_USER",
-    7: "SYSTEM",
-  }
-
-  _NAMES_TO_VALUES = {
-    "GRANT": 0,
-    "CREATE_TABLE": 1,
-    "DROP_TABLE": 2,
-    "ALTER_TABLE": 3,
-    "CREATE_USER": 4,
-    "DROP_USER": 5,
-    "ALTER_USER": 6,
-    "SYSTEM": 7,
-  }
-
-class ScanType:
-  SINGLE = 0
-  BATCH = 1
-
-  _VALUES_TO_NAMES = {
-    0: "SINGLE",
-    1: "BATCH",
-  }
-
-  _NAMES_TO_VALUES = {
-    "SINGLE": 0,
-    "BATCH": 1,
-  }
-
-class ScanState:
-  IDLE = 0
-  RUNNING = 1
-  QUEUED = 2
-
-  _VALUES_TO_NAMES = {
-    0: "IDLE",
-    1: "RUNNING",
-    2: "QUEUED",
-  }
-
-  _NAMES_TO_VALUES = {
-    "IDLE": 0,
-    "RUNNING": 1,
-    "QUEUED": 2,
-  }
-
-class CompactionType:
-  MINOR = 0
-  MERGE = 1
-  MAJOR = 2
-  FULL = 3
-
-  _VALUES_TO_NAMES = {
-    0: "MINOR",
-    1: "MERGE",
-    2: "MAJOR",
-    3: "FULL",
-  }
-
-  _NAMES_TO_VALUES = {
-    "MINOR": 0,
-    "MERGE": 1,
-    "MAJOR": 2,
-    "FULL": 3,
-  }
-
-class CompactionReason:
-  USER = 0
-  SYSTEM = 1
-  CHOP = 2
-  IDLE = 3
-  CLOSE = 4
-
-  _VALUES_TO_NAMES = {
-    0: "USER",
-    1: "SYSTEM",
-    2: "CHOP",
-    3: "IDLE",
-    4: "CLOSE",
-  }
-
-  _NAMES_TO_VALUES = {
-    "USER": 0,
-    "SYSTEM": 1,
-    "CHOP": 2,
-    "IDLE": 3,
-    "CLOSE": 4,
-  }
-
-class IteratorScope:
-  MINC = 0
-  MAJC = 1
-  SCAN = 2
-
-  _VALUES_TO_NAMES = {
-    0: "MINC",
-    1: "MAJC",
-    2: "SCAN",
-  }
-
-  _NAMES_TO_VALUES = {
-    "MINC": 0,
-    "MAJC": 1,
-    "SCAN": 2,
-  }
-
-class TimeType:
-  LOGICAL = 0
-  MILLIS = 1
-
-  _VALUES_TO_NAMES = {
-    0: "LOGICAL",
-    1: "MILLIS",
-  }
-
-  _NAMES_TO_VALUES = {
-    "LOGICAL": 0,
-    "MILLIS": 1,
-  }
-
-
-class Key:
-  """
-  Attributes:
-   - row
-   - colFamily
-   - colQualifier
-   - colVisibility
-   - timestamp
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'row', None, None, ), # 1
-    (2, TType.STRING, 'colFamily', None, None, ), # 2
-    (3, TType.STRING, 'colQualifier', None, None, ), # 3
-    (4, TType.STRING, 'colVisibility', None, None, ), # 4
-    (5, TType.I64, 'timestamp', None, None, ), # 5
-  )
-
-  def __init__(self, row=None, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None,):
-    self.row = row
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-    self.colVisibility = colVisibility
-    self.timestamp = timestamp
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.row = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.colVisibility = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I64:
-          self.timestamp = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('Key')
-    if self.row is not None:
-      oprot.writeFieldBegin('row', TType.STRING, 1)
-      oprot.writeString(self.row)
-      oprot.writeFieldEnd()
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 2)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 3)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    if self.colVisibility is not None:
-      oprot.writeFieldBegin('colVisibility', TType.STRING, 4)
-      oprot.writeString(self.colVisibility)
-      oprot.writeFieldEnd()
-    if self.timestamp is not None:
-      oprot.writeFieldBegin('timestamp', TType.I64, 5)
-      oprot.writeI64(self.timestamp)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ColumnUpdate:
-  """
-  Attributes:
-   - colFamily
-   - colQualifier
-   - colVisibility
-   - timestamp
-   - value
-   - deleteCell
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'colFamily', None, None, ), # 1
-    (2, TType.STRING, 'colQualifier', None, None, ), # 2
-    (3, TType.STRING, 'colVisibility', None, None, ), # 3
-    (4, TType.I64, 'timestamp', None, None, ), # 4
-    (5, TType.STRING, 'value', None, None, ), # 5
-    (6, TType.BOOL, 'deleteCell', None, None, ), # 6
-  )
-
-  def __init__(self, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None, value=None, deleteCell=None,):
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-    self.colVisibility = colVisibility
-    self.timestamp = timestamp
-    self.value = value
-    self.deleteCell = deleteCell
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.colVisibility = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I64:
-          self.timestamp = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.BOOL:
-          self.deleteCell = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ColumnUpdate')
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    if self.colVisibility is not None:
-      oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
-      oprot.writeString(self.colVisibility)
-      oprot.writeFieldEnd()
-    if self.timestamp is not None:
-      oprot.writeFieldBegin('timestamp', TType.I64, 4)
-      oprot.writeI64(self.timestamp)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 5)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    if self.deleteCell is not None:
-      oprot.writeFieldBegin('deleteCell', TType.BOOL, 6)
-      oprot.writeBool(self.deleteCell)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class KeyValue:
-  """
-  Attributes:
-   - key
-   - value
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ), # 1
-    (2, TType.STRING, 'value', None, None, ), # 2
-  )
-
-  def __init__(self, key=None, value=None,):
-    self.key = key
-    self.value = value
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.key = Key()
-          self.key.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.value = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('KeyValue')
-    if self.key is not None:
-      oprot.writeFieldBegin('key', TType.STRUCT, 1)
-      self.key.write(oprot)
-      oprot.writeFieldEnd()
-    if self.value is not None:
-      oprot.writeFieldBegin('value', TType.STRING, 2)
-      oprot.writeString(self.value)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ScanResult:
-  """
-  Attributes:
-   - results
-   - more
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.LIST, 'results', (TType.STRUCT,(KeyValue, KeyValue.thrift_spec)), None, ), # 1
-    (2, TType.BOOL, 'more', None, None, ), # 2
-  )
-
-  def __init__(self, results=None, more=None,):
-    self.results = results
-    self.more = more
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.LIST:
-          self.results = []
-          (_etype3, _size0) = iprot.readListBegin()
-          for _i4 in xrange(_size0):
-            _elem5 = KeyValue()
-            _elem5.read(iprot)
-            self.results.append(_elem5)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.BOOL:
-          self.more = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ScanResult')
-    if self.results is not None:
-      oprot.writeFieldBegin('results', TType.LIST, 1)
-      oprot.writeListBegin(TType.STRUCT, len(self.results))
-      for iter6 in self.results:
-        iter6.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.more is not None:
-      oprot.writeFieldBegin('more', TType.BOOL, 2)
-      oprot.writeBool(self.more)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class Range:
-  """
-  Attributes:
-   - start
-   - startInclusive
-   - stop
-   - stopInclusive
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'start', (Key, Key.thrift_spec), None, ), # 1
-    (2, TType.BOOL, 'startInclusive', None, None, ), # 2
-    (3, TType.STRUCT, 'stop', (Key, Key.thrift_spec), None, ), # 3
-    (4, TType.BOOL, 'stopInclusive', None, None, ), # 4
-  )
-
-  def __init__(self, start=None, startInclusive=None, stop=None, stopInclusive=None,):
-    self.start = start
-    self.startInclusive = startInclusive
-    self.stop = stop
-    self.stopInclusive = stopInclusive
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.start = Key()
-          self.start.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.BOOL:
-          self.startInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRUCT:
-          self.stop = Key()
-          self.stop.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.BOOL:
-          self.stopInclusive = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('Range')
-    if self.start is not None:
-      oprot.writeFieldBegin('start', TType.STRUCT, 1)
-      self.start.write(oprot)
-      oprot.writeFieldEnd()
-    if self.startInclusive is not None:
-      oprot.writeFieldBegin('startInclusive', TType.BOOL, 2)
-      oprot.writeBool(self.startInclusive)
-      oprot.writeFieldEnd()
-    if self.stop is not None:
-      oprot.writeFieldBegin('stop', TType.STRUCT, 3)
-      self.stop.write(oprot)
-      oprot.writeFieldEnd()
-    if self.stopInclusive is not None:
-      oprot.writeFieldBegin('stopInclusive', TType.BOOL, 4)
-      oprot.writeBool(self.stopInclusive)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ScanColumn:
-  """
-  Attributes:
-   - colFamily
-   - colQualifier
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'colFamily', None, None, ), # 1
-    (2, TType.STRING, 'colQualifier', None, None, ), # 2
-  )
-
-  def __init__(self, colFamily=None, colQualifier=None,):
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ScanColumn')
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class IteratorSetting:
-  """
-  Attributes:
-   - priority
-   - name
-   - iteratorClass
-   - properties
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.I32, 'priority', None, None, ), # 1
-    (2, TType.STRING, 'name', None, None, ), # 2
-    (3, TType.STRING, 'iteratorClass', None, None, ), # 3
-    (4, TType.MAP, 'properties', (TType.STRING,None,TType.STRING,None), None, ), # 4
-  )
-
-  def __init__(self, priority=None, name=None, iteratorClass=None, properties=None,):
-    self.priority = priority
-    self.name = name
-    self.iteratorClass = iteratorClass
-    self.properties = properties
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.I32:
-          self.priority = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.name = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.iteratorClass = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.MAP:
-          self.properties = {}
-          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
-          for _i11 in xrange(_size7):
-            _key12 = iprot.readString();
-            _val13 = iprot.readString();
-            self.properties[_key12] = _val13
-          iprot.readMapEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('IteratorSetting')
-    if self.priority is not None:
-      oprot.writeFieldBegin('priority', TType.I32, 1)
-      oprot.writeI32(self.priority)
-      oprot.writeFieldEnd()
-    if self.name is not None:
-      oprot.writeFieldBegin('name', TType.STRING, 2)
-      oprot.writeString(self.name)
-      oprot.writeFieldEnd()
-    if self.iteratorClass is not None:
-      oprot.writeFieldBegin('iteratorClass', TType.STRING, 3)
-      oprot.writeString(self.iteratorClass)
-      oprot.writeFieldEnd()
-    if self.properties is not None:
-      oprot.writeFieldBegin('properties', TType.MAP, 4)
-      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
-      for kiter14,viter15 in self.properties.items():
-        oprot.writeString(kiter14)
-        oprot.writeString(viter15)
-      oprot.writeMapEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ScanOptions:
-  """
-  Attributes:
-   - authorizations
-   - range
-   - columns
-   - iterators
-   - bufferSize
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 1
-    (2, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 2
-    (3, TType.LIST, 'columns', (TType.STRUCT,(ScanColumn, ScanColumn.thrift_spec)), None, ), # 3
-    (4, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 4
-    (5, TType.I32, 'bufferSize', None, None, ), # 5
-  )
-
-  def __init__(self, authorizations=None, range=None, columns=None, iterators=None, bufferSize=None,):
-    self.authorizations = authorizations
-    self.range = range
-    self.columns = columns
-    self.iterators = iterators
-    self.bufferSize = bufferSize
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.SET:
-          self.authorizations = set()
-          (_etype19, _size16) = iprot.readSetBegin()
-          for _i20 in xrange(_size16):
-            _elem21 = iprot.readString();
-            self.authorizations.add(_elem21)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRUCT:
-          self.range = Range()
-          self.range.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.LIST:
-          self.columns = []
-          (_etype25, _size22) = iprot.readListBegin()
-          for _i26 in xrange(_size22):
-            _elem27 = ScanColumn()
-            _elem27.read(iprot)
-            self.columns.append(_elem27)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype31, _size28) = iprot.readListBegin()
-          for _i32 in xrange(_size28):
-            _elem33 = IteratorSetting()
-            _elem33.read(iprot)
-            self.iterators.append(_elem33)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I32:
-          self.bufferSize = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ScanOptions')
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.SET, 1)
-      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
-      for iter34 in self.authorizations:
-        oprot.writeString(iter34)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.range is not None:
-      oprot.writeFieldBegin('range', TType.STRUCT, 2)
-      self.range.write(oprot)
-      oprot.writeFieldEnd()
-    if self.columns is not None:
-      oprot.writeFieldBegin('columns', TType.LIST, 3)
-      oprot.writeListBegin(TType.STRUCT, len(self.columns))
-      for iter35 in self.columns:
-        iter35.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 4)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter36 in self.iterators:
-        iter36.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.bufferSize is not None:
-      oprot.writeFieldBegin('bufferSize', TType.I32, 5)
-      oprot.writeI32(self.bufferSize)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class BatchScanOptions:
-  """
-  Attributes:
-   - authorizations
-   - ranges
-   - columns
-   - iterators
-   - threads
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.SET, 'authorizations', (TType.STRING,None), None, ), # 1
-    (2, TType.LIST, 'ranges', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 2
-    (3, TType.LIST, 'columns', (TType.STRUCT,(ScanColumn, ScanColumn.thrift_spec)), None, ), # 3
-    (4, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 4
-    (5, TType.I32, 'threads', None, None, ), # 5
-  )
-
-  def __init__(self, authorizations=None, ranges=None, columns=None, iterators=None, threads=None,):
-    self.authorizations = authorizations
-    self.ranges = ranges
-    self.columns = columns
-    self.iterators = iterators
-    self.threads = threads
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.SET:
-          self.authorizations = set()
-          (_etype40, _size37) = iprot.readSetBegin()
-          for _i41 in xrange(_size37):
-            _elem42 = iprot.readString();
-            self.authorizations.add(_elem42)
-          iprot.readSetEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.LIST:
-          self.ranges = []
-          (_etype46, _size43) = iprot.readListBegin()
-          for _i47 in xrange(_size43):
-            _elem48 = Range()
-            _elem48.read(iprot)
-            self.ranges.append(_elem48)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.LIST:
-          self.columns = []
-          (_etype52, _size49) = iprot.readListBegin()
-          for _i53 in xrange(_size49):
-            _elem54 = ScanColumn()
-            _elem54.read(iprot)
-            self.columns.append(_elem54)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype58, _size55) = iprot.readListBegin()
-          for _i59 in xrange(_size55):
-            _elem60 = IteratorSetting()
-            _elem60.read(iprot)
-            self.iterators.append(_elem60)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I32:
-          self.threads = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('BatchScanOptions')
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.SET, 1)
-      oprot.writeSetBegin(TType.STRING, len(self.authorizations))
-      for iter61 in self.authorizations:
-        oprot.writeString(iter61)
-      oprot.writeSetEnd()
-      oprot.writeFieldEnd()
-    if self.ranges is not None:
-      oprot.writeFieldBegin('ranges', TType.LIST, 2)
-      oprot.writeListBegin(TType.STRUCT, len(self.ranges))
-      for iter62 in self.ranges:
-        iter62.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.columns is not None:
-      oprot.writeFieldBegin('columns', TType.LIST, 3)
-      oprot.writeListBegin(TType.STRUCT, len(self.columns))
-      for iter63 in self.columns:
-        iter63.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 4)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter64 in self.iterators:
-        iter64.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.threads is not None:
-      oprot.writeFieldBegin('threads', TType.I32, 5)
-      oprot.writeI32(self.threads)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class KeyValueAndPeek:
-  """
-  Attributes:
-   - keyValue
-   - hasNext
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'keyValue', (KeyValue, KeyValue.thrift_spec), None, ), # 1
-    (2, TType.BOOL, 'hasNext', None, None, ), # 2
-  )
-
-  def __init__(self, keyValue=None, hasNext=None,):
-    self.keyValue = keyValue
-    self.hasNext = hasNext
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.keyValue = KeyValue()
-          self.keyValue.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.BOOL:
-          self.hasNext = iprot.readBool();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('KeyValueAndPeek')
-    if self.keyValue is not None:
-      oprot.writeFieldBegin('keyValue', TType.STRUCT, 1)
-      self.keyValue.write(oprot)
-      oprot.writeFieldEnd()
-    if self.hasNext is not None:
-      oprot.writeFieldBegin('hasNext', TType.BOOL, 2)
-      oprot.writeBool(self.hasNext)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class KeyExtent:
-  """
-  Attributes:
-   - tableId
-   - endRow
-   - prevEndRow
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'tableId', None, None, ), # 1
-    (2, TType.STRING, 'endRow', None, None, ), # 2
-    (3, TType.STRING, 'prevEndRow', None, None, ), # 3
-  )
-
-  def __init__(self, tableId=None, endRow=None, prevEndRow=None,):
-    self.tableId = tableId
-    self.endRow = endRow
-    self.prevEndRow = prevEndRow
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.tableId = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.endRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.prevEndRow = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('KeyExtent')
-    if self.tableId is not None:
-      oprot.writeFieldBegin('tableId', TType.STRING, 1)
-      oprot.writeString(self.tableId)
-      oprot.writeFieldEnd()
-    if self.endRow is not None:
-      oprot.writeFieldBegin('endRow', TType.STRING, 2)
-      oprot.writeString(self.endRow)
-      oprot.writeFieldEnd()
-    if self.prevEndRow is not None:
-      oprot.writeFieldBegin('prevEndRow', TType.STRING, 3)
-      oprot.writeString(self.prevEndRow)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class Column:
-  """
-  Attributes:
-   - colFamily
-   - colQualifier
-   - colVisibility
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'colFamily', None, None, ), # 1
-    (2, TType.STRING, 'colQualifier', None, None, ), # 2
-    (3, TType.STRING, 'colVisibility', None, None, ), # 3
-  )
-
-  def __init__(self, colFamily=None, colQualifier=None, colVisibility=None,):
-    self.colFamily = colFamily
-    self.colQualifier = colQualifier
-    self.colVisibility = colVisibility
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.colFamily = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.colQualifier = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.colVisibility = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('Column')
-    if self.colFamily is not None:
-      oprot.writeFieldBegin('colFamily', TType.STRING, 1)
-      oprot.writeString(self.colFamily)
-      oprot.writeFieldEnd()
-    if self.colQualifier is not None:
-      oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
-      oprot.writeString(self.colQualifier)
-      oprot.writeFieldEnd()
-    if self.colVisibility is not None:
-      oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
-      oprot.writeString(self.colVisibility)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ActiveScan:
-  """
-  Attributes:
-   - client
-   - user
-   - table
-   - age
-   - idleTime
-   - type
-   - state
-   - extent
-   - columns
-   - iterators
-   - authorizations
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'client', None, None, ), # 1
-    (2, TType.STRING, 'user', None, None, ), # 2
-    (3, TType.STRING, 'table', None, None, ), # 3
-    (4, TType.I64, 'age', None, None, ), # 4
-    (5, TType.I64, 'idleTime', None, None, ), # 5
-    (6, TType.I32, 'type', None, None, ), # 6
-    (7, TType.I32, 'state', None, None, ), # 7
-    (8, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ), # 8
-    (9, TType.LIST, 'columns', (TType.STRUCT,(Column, Column.thrift_spec)), None, ), # 9
-    (10, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 10
-    (11, TType.LIST, 'authorizations', (TType.STRING,None), None, ), # 11
-  )
-
-  def __init__(self, client=None, user=None, table=None, age=None, idleTime=None, type=None, state=None, extent=None, columns=None, iterators=None, authorizations=None,):
-    self.client = client
-    self.user = user
-    self.table = table
-    self.age = age
-    self.idleTime = idleTime
-    self.type = type
-    self.state = state
-    self.extent = extent
-    self.columns = columns
-    self.iterators = iterators
-    self.authorizations = authorizations
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.client = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.STRING:
-          self.user = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.STRING:
-          self.table = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I64:
-          self.age = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I64:
-          self.idleTime = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.I32:
-          self.type = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.I32:
-          self.state = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 8:
-        if ftype == TType.STRUCT:
-          self.extent = KeyExtent()
-          self.extent.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 9:
-        if ftype == TType.LIST:
-          self.columns = []
-          (_etype68, _size65) = iprot.readListBegin()
-          for _i69 in xrange(_size65):
-            _elem70 = Column()
-            _elem70.read(iprot)
-            self.columns.append(_elem70)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 10:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype74, _size71) = iprot.readListBegin()
-          for _i75 in xrange(_size71):
-            _elem76 = IteratorSetting()
-            _elem76.read(iprot)
-            self.iterators.append(_elem76)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 11:
-        if ftype == TType.LIST:
-          self.authorizations = []
-          (_etype80, _size77) = iprot.readListBegin()
-          for _i81 in xrange(_size77):
-            _elem82 = iprot.readString();
-            self.authorizations.append(_elem82)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ActiveScan')
-    if self.client is not None:
-      oprot.writeFieldBegin('client', TType.STRING, 1)
-      oprot.writeString(self.client)
-      oprot.writeFieldEnd()
-    if self.user is not None:
-      oprot.writeFieldBegin('user', TType.STRING, 2)
-      oprot.writeString(self.user)
-      oprot.writeFieldEnd()
-    if self.table is not None:
-      oprot.writeFieldBegin('table', TType.STRING, 3)
-      oprot.writeString(self.table)
-      oprot.writeFieldEnd()
-    if self.age is not None:
-      oprot.writeFieldBegin('age', TType.I64, 4)
-      oprot.writeI64(self.age)
-      oprot.writeFieldEnd()
-    if self.idleTime is not None:
-      oprot.writeFieldBegin('idleTime', TType.I64, 5)
-      oprot.writeI64(self.idleTime)
-      oprot.writeFieldEnd()
-    if self.type is not None:
-      oprot.writeFieldBegin('type', TType.I32, 6)
-      oprot.writeI32(self.type)
-      oprot.writeFieldEnd()
-    if self.state is not None:
-      oprot.writeFieldBegin('state', TType.I32, 7)
-      oprot.writeI32(self.state)
-      oprot.writeFieldEnd()
-    if self.extent is not None:
-      oprot.writeFieldBegin('extent', TType.STRUCT, 8)
-      self.extent.write(oprot)
-      oprot.writeFieldEnd()
-    if self.columns is not None:
-      oprot.writeFieldBegin('columns', TType.LIST, 9)
-      oprot.writeListBegin(TType.STRUCT, len(self.columns))
-      for iter83 in self.columns:
-        iter83.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 10)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter84 in self.iterators:
-        iter84.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.authorizations is not None:
-      oprot.writeFieldBegin('authorizations', TType.LIST, 11)
-      oprot.writeListBegin(TType.STRING, len(self.authorizations))
-      for iter85 in self.authorizations:
-        oprot.writeString(iter85)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class ActiveCompaction:
-  """
-  Attributes:
-   - extent
-   - age
-   - inputFiles
-   - outputFile
-   - type
-   - reason
-   - localityGroup
-   - entriesRead
-   - entriesWritten
-   - iterators
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ), # 1
-    (2, TType.I64, 'age', None, None, ), # 2
-    (3, TType.LIST, 'inputFiles', (TType.STRING,None), None, ), # 3
-    (4, TType.STRING, 'outputFile', None, None, ), # 4
-    (5, TType.I32, 'type', None, None, ), # 5
-    (6, TType.I32, 'reason', None, None, ), # 6
-    (7, TType.STRING, 'localityGroup', None, None, ), # 7
-    (8, TType.I64, 'entriesRead', None, None, ), # 8
-    (9, TType.I64, 'entriesWritten', None, None, ), # 9
-    (10, TType.LIST, 'iterators', (TType.STRUCT,(IteratorSetting, IteratorSetting.thrift_spec)), None, ), # 10
-  )
-
-  def __init__(self, extent=None, age=None, inputFiles=None, outputFile=None, type=None, reason=None, localityGroup=None, entriesRead=None, entriesWritten=None, iterators=None,):
-    self.extent = extent
-    self.age = age
-    self.inputFiles = inputFiles
-    self.outputFile = outputFile
-    self.type = type
-    self.reason = reason
-    self.localityGroup = localityGroup
-    self.entriesRead = entriesRead
-    self.entriesWritten = entriesWritten
-    self.iterators = iterators
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRUCT:
-          self.extent = KeyExtent()
-          self.extent.read(iprot)
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I64:
-          self.age = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.LIST:
-          self.inputFiles = []
-          (_etype89, _size86) = iprot.readListBegin()
-          for _i90 in xrange(_size86):
-            _elem91 = iprot.readString();
-            self.inputFiles.append(_elem91)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.STRING:
-          self.outputFile = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 5:
-        if ftype == TType.I32:
-          self.type = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 6:
-        if ftype == TType.I32:
-          self.reason = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      elif fid == 7:
-        if ftype == TType.STRING:
-          self.localityGroup = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      elif fid == 8:
-        if ftype == TType.I64:
-          self.entriesRead = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 9:
-        if ftype == TType.I64:
-          self.entriesWritten = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 10:
-        if ftype == TType.LIST:
-          self.iterators = []
-          (_etype95, _size92) = iprot.readListBegin()
-          for _i96 in xrange(_size92):
-            _elem97 = IteratorSetting()
-            _elem97.read(iprot)
-            self.iterators.append(_elem97)
-          iprot.readListEnd()
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('ActiveCompaction')
-    if self.extent is not None:
-      oprot.writeFieldBegin('extent', TType.STRUCT, 1)
-      self.extent.write(oprot)
-      oprot.writeFieldEnd()
-    if self.age is not None:
-      oprot.writeFieldBegin('age', TType.I64, 2)
-      oprot.writeI64(self.age)
-      oprot.writeFieldEnd()
-    if self.inputFiles is not None:
-      oprot.writeFieldBegin('inputFiles', TType.LIST, 3)
-      oprot.writeListBegin(TType.STRING, len(self.inputFiles))
-      for iter98 in self.inputFiles:
-        oprot.writeString(iter98)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    if self.outputFile is not None:
-      oprot.writeFieldBegin('outputFile', TType.STRING, 4)
-      oprot.writeString(self.outputFile)
-      oprot.writeFieldEnd()
-    if self.type is not None:
-      oprot.writeFieldBegin('type', TType.I32, 5)
-      oprot.writeI32(self.type)
-      oprot.writeFieldEnd()
-    if self.reason is not None:
-      oprot.writeFieldBegin('reason', TType.I32, 6)
-      oprot.writeI32(self.reason)
-      oprot.writeFieldEnd()
-    if self.localityGroup is not None:
-      oprot.writeFieldBegin('localityGroup', TType.STRING, 7)
-      oprot.writeString(self.localityGroup)
-      oprot.writeFieldEnd()
-    if self.entriesRead is not None:
-      oprot.writeFieldBegin('entriesRead', TType.I64, 8)
-      oprot.writeI64(self.entriesRead)
-      oprot.writeFieldEnd()
-    if self.entriesWritten is not None:
-      oprot.writeFieldBegin('entriesWritten', TType.I64, 9)
-      oprot.writeI64(self.entriesWritten)
-      oprot.writeFieldEnd()
-    if self.iterators is not None:
-      oprot.writeFieldBegin('iterators', TType.LIST, 10)
-      oprot.writeListBegin(TType.STRUCT, len(self.iterators))
-      for iter99 in self.iterators:
-        iter99.write(oprot)
-      oprot.writeListEnd()
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
-
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
-
-  def __ne__(self, other):
-    return not (self == other)
-
-class WriterOptions:
-  """
-  Attributes:
-   - maxMemory
-   - latencyMs
-   - timeoutMs
-   - threads
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.I64, 'maxMemory', None, None, ), # 1
-    (2, TType.I64, 'latencyMs', None, None, ), # 2
-    (3, TType.I64, 'timeoutMs', None, None, ), # 3
-    (4, TType.I32, 'threads', None, None, ), # 4
-  )
-
-  def __init__(self, maxMemory=None, latencyMs=None, timeoutMs=None, threads=None,):
-    self.maxMemory = maxMemory
-    self.latencyMs = latencyMs
-    self.timeoutMs = timeoutMs
-    self.threads = threads
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.I64:
-          self.maxMemory = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 2:
-        if ftype == TType.I64:
-          self.latencyMs = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 3:
-        if ftype == TType.I64:
-          self.timeoutMs = iprot.readI64();
-        else:
-          iprot.skip(ftype)
-      elif fid == 4:
-        if ftype == TType.I32:
-          self.threads = iprot.readI32();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('WriterOptions')
-    if self.maxMemory is not None:
-      oprot.writeFieldBegin('maxMemory', TType.I64, 1)
-      oprot.writeI64(self.maxMemory)
-      oprot.writeFieldEnd()
-    if self.latencyMs is not None:
-      oprot.writeFieldBegin('latencyMs', TType.I64, 2)
-      oprot.writeI64(self.latencyMs)
-      oprot.writeFieldEnd()
-    if self.timeoutMs is not None:
-      oprot.writeFieldBegin('timeoutMs', TType.I64, 3)
-      oprot.writeI64(self.timeoutMs)
-      oprot.writeFieldEnd()
-    if self.threads is not None:
-      oprot.writeFieldBegin('threads', TType.I32, 4)
-      oprot.writeI32(self.threads)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __ne__(self, other):
-    return not (self == other)
+class PartialKey(object):
+    ROW = 0
+    ROW_COLFAM = 1
+    ROW_COLFAM_COLQUAL = 2
+    ROW_COLFAM_COLQUAL_COLVIS = 3
+    ROW_COLFAM_COLQUAL_COLVIS_TIME = 4
+    ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL = 5
+
+    _VALUES_TO_NAMES = {
+        0: "ROW",
+        1: "ROW_COLFAM",
+        2: "ROW_COLFAM_COLQUAL",
+        3: "ROW_COLFAM_COLQUAL_COLVIS",
+        4: "ROW_COLFAM_COLQUAL_COLVIS_TIME",
+        5: "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL",
+    }
+
+    _NAMES_TO_VALUES = {
+        "ROW": 0,
+        "ROW_COLFAM": 1,
+        "ROW_COLFAM_COLQUAL": 2,
+        "ROW_COLFAM_COLQUAL_COLVIS": 3,
+        "ROW_COLFAM_COLQUAL_COLVIS_TIME": 4,
+        "ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL": 5,
+    }
+
+
+class TablePermission(object):
+    READ = 2
+    WRITE = 3
+    BULK_IMPORT = 4
+    ALTER_TABLE = 5
+    GRANT = 6
+    DROP_TABLE = 7
+
+    _VALUES_TO_NAMES = {
+        2: "READ",
+        3: "WRITE",
+        4: "BULK_IMPORT",
+        5: "ALTER_TABLE",
+        6: "GRANT",
+        7: "DROP_TABLE",
+    }
+
+    _NAMES_TO_VALUES = {
+        "READ": 2,
+        "WRITE": 3,
+        "BULK_IMPORT": 4,
+        "ALTER_TABLE": 5,
+        "GRANT": 6,
+        "DROP_TABLE": 7,
+    }
+
+
+class SystemPermission(object):
+    GRANT = 0
+    CREATE_TABLE = 1
+    DROP_TABLE = 2
+    ALTER_TABLE = 3
+    CREATE_USER = 4
+    DROP_USER = 5
+    ALTER_USER = 6
+    SYSTEM = 7
+    CREATE_NAMESPACE = 8
+    DROP_NAMESPACE = 9
+    ALTER_NAMESPACE = 10
+    OBTAIN_DELEGATION_TOKEN = 11
+
+    _VALUES_TO_NAMES = {
+        0: "GRANT",
+        1: "CREATE_TABLE",
+        2: "DROP_TABLE",
+        3: "ALTER_TABLE",
+        4: "CREATE_USER",
+        5: "DROP_USER",
+        6: "ALTER_USER",
+        7: "SYSTEM",
+        8: "CREATE_NAMESPACE",
+        9: "DROP_NAMESPACE",
+        10: "ALTER_NAMESPACE",
+        11: "OBTAIN_DELEGATION_TOKEN",
+    }
+
+    _NAMES_TO_VALUES = {
+        "GRANT": 0,
+        "CREATE_TABLE": 1,
+        "DROP_TABLE": 2,
+        "ALTER_TABLE": 3,
+        "CREATE_USER": 4,
+        "DROP_USER": 5,
+        "ALTER_USER": 6,
+        "SYSTEM": 7,
+        "CREATE_NAMESPACE": 8,
+        "DROP_NAMESPACE": 9,
+        "ALTER_NAMESPACE": 10,
+        "OBTAIN_DELEGATION_TOKEN": 11,
+    }
+
+
+class NamespacePermission(object):
+    READ = 0
+    WRITE = 1
+    ALTER_NAMESPACE = 2
+    GRANT = 3
+    ALTER_TABLE = 4
+    CREATE_TABLE = 5
+    DROP_TABLE = 6
+    BULK_IMPORT = 7
+    DROP_NAMESPACE = 8
+
+    _VALUES_TO_NAMES = {
+        0: "READ",
+        1: "WRITE",
+        2: "ALTER_NAMESPACE",
+        3: "GRANT",
+        4: "ALTER_TABLE",
+        5: "CREATE_TABLE",
+        6: "DROP_TABLE",
+        7: "BULK_IMPORT",
+        8: "DROP_NAMESPACE",
+    }
+
+    _NAMES_TO_VALUES = {
+        "READ": 0,
+        "WRITE": 1,
+        "ALTER_NAMESPACE": 2,
+        "GRANT": 3,
+        "ALTER_TABLE": 4,
+        "CREATE_TABLE": 5,
+        "DROP_TABLE": 6,
+        "BULK_IMPORT": 7,
+        "DROP_NAMESPACE": 8,
+    }
+
+
+class ScanType(object):
+    SINGLE = 0
+    BATCH = 1
+
+    _VALUES_TO_NAMES = {
+        0: "SINGLE",
+        1: "BATCH",
+    }
+
+    _NAMES_TO_VALUES = {
+        "SINGLE": 0,
+        "BATCH": 1,
+    }
+
+
+class ScanState(object):
+    IDLE = 0
+    RUNNING = 1
+    QUEUED = 2
+
+    _VALUES_TO_NAMES = {
+        0: "IDLE",
+        1: "RUNNING",
+        2: "QUEUED",
+    }
+
+    _NAMES_TO_VALUES = {
+        "IDLE": 0,
+        "RUNNING": 1,
+        "QUEUED": 2,
+    }
+
+
+class ConditionalStatus(object):
+    ACCEPTED = 0
+    REJECTED = 1
+    VIOLATED = 2
+    UNKNOWN = 3
+    INVISIBLE_VISIBILITY = 4
+
+    _VALUES_TO_NAMES = {
+        0: "ACCEPTED",
+        1: "REJECTED",
+        2: "VIOLATED",
+        3: "UNKNOWN",
+        4: "INVISIBLE_VISIBILITY",
+    }
+
+    _NAMES_TO_VALUES = {
+        "ACCEPTED": 0,
+        "REJECTED": 1,
+        "VIOLATED": 2,
+        "UNKNOWN": 3,
+        "INVISIBLE_VISIBILITY": 4,
+    }
+
+
+class Durability(object):
+    DEFAULT = 0
+    NONE = 1
+    LOG = 2
+    FLUSH = 3
+    SYNC = 4
+
+    _VALUES_TO_NAMES = {
+        0: "DEFAULT",
+        1: "NONE",
+        2: "LOG",
+        3: "FLUSH",
+        4: "SYNC",
+    }
+
+    _NAMES_TO_VALUES = {
+        "DEFAULT": 0,
+        "NONE": 1,
+        "LOG": 2,
+        "FLUSH": 3,
+        "SYNC": 4,
+    }
+
+
+class CompactionType(object):
+    MINOR = 0
+    MERGE = 1
+    MAJOR = 2
+    FULL = 3
+
+    _VALUES_TO_NAMES = {
+        0: "MINOR",
+        1: "MERGE",
+        2: "MAJOR",
+        3: "FULL",
+    }
+
+    _NAMES_TO_VALUES = {
+        "MINOR": 0,
+        "MERGE": 1,
+        "MAJOR": 2,
+        "FULL": 3,
+    }
+
+
+class CompactionReason(object):
+    USER = 0
+    SYSTEM = 1
+    CHOP = 2
+    IDLE = 3
+    CLOSE = 4
+
+    _VALUES_TO_NAMES = {
+        0: "USER",
+        1: "SYSTEM",
+        2: "CHOP",
+        3: "IDLE",
+        4: "CLOSE",
+    }
+
+    _NAMES_TO_VALUES = {
+        "USER": 0,
+        "SYSTEM": 1,
+        "CHOP": 2,
+        "IDLE": 3,
+        "CLOSE": 4,
+    }
+
+
+class IteratorScope(object):
+    MINC = 0
+    MAJC = 1
+    SCAN = 2
+
+    _VALUES_TO_NAMES = {
+        0: "MINC",
+        1: "MAJC",
+        2: "SCAN",
+    }
+
+    _NAMES_TO_VALUES = {
+        "MINC": 0,
+        "MAJC": 1,
+        "SCAN": 2,
+    }
+
+
+class TimeType(object):
+    LOGICAL = 0
+    MILLIS = 1
+
+    _VALUES_TO_NAMES = {
+        0: "LOGICAL",
+        1: "MILLIS",
+    }
+
+    _NAMES_TO_VALUES = {
+        "LOGICAL": 0,
+        "MILLIS": 1,
+    }
+
+
+class Key(object):
+    """
+    Attributes:
+     - row
+     - colFamily
+     - colQualifier
+     - colVisibility
+     - timestamp
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colFamily', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 3
+        (4, TType.STRING, 'colVisibility', 'BINARY', None, ),  # 4
+        (5, TType.I64, 'timestamp', None, 9223372036854775807, ),  # 5
+    )
+
+    def __init__(self, row=None, colFamily=None, colQualifier=None, colVisibility=None, timestamp=thrift_spec[5][4],):
+        self.row = row
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+        self.colVisibility = colVisibility
+        self.timestamp = timestamp
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.row = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.colVisibility = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I64:
+                    self.timestamp = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Key')
+        if self.row is not None:
+            oprot.writeFieldBegin('row', TType.STRING, 1)
+            oprot.writeBinary(self.row)
+            oprot.writeFieldEnd()
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 2)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 3)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        if self.colVisibility is not None:
+            oprot.writeFieldBegin('colVisibility', TType.STRING, 4)
+            oprot.writeBinary(self.colVisibility)
+            oprot.writeFieldEnd()
+        if self.timestamp is not None:
+            oprot.writeFieldBegin('timestamp', TType.I64, 5)
+            oprot.writeI64(self.timestamp)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ColumnUpdate(object):
+    """
+    Attributes:
+     - colFamily
+     - colQualifier
+     - colVisibility
+     - timestamp
+     - value
+     - deleteCell
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'colFamily', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'colVisibility', 'BINARY', None, ),  # 3
+        (4, TType.I64, 'timestamp', None, None, ),  # 4
+        (5, TType.STRING, 'value', 'BINARY', None, ),  # 5
+        (6, TType.BOOL, 'deleteCell', None, None, ),  # 6
+    )
+
+    def __init__(self, colFamily=None, colQualifier=None, colVisibility=None, timestamp=None, value=None, deleteCell=None,):
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+        self.colVisibility = colVisibility
+        self.timestamp = timestamp
+        self.value = value
+        self.deleteCell = deleteCell
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.colVisibility = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I64:
+                    self.timestamp = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.STRING:
+                    self.value = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.BOOL:
+                    self.deleteCell = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ColumnUpdate')
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 1)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        if self.colVisibility is not None:
+            oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
+            oprot.writeBinary(self.colVisibility)
+            oprot.writeFieldEnd()
+        if self.timestamp is not None:
+            oprot.writeFieldBegin('timestamp', TType.I64, 4)
+            oprot.writeI64(self.timestamp)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 5)
+            oprot.writeBinary(self.value)
+            oprot.writeFieldEnd()
+        if self.deleteCell is not None:
+            oprot.writeFieldBegin('deleteCell', TType.BOOL, 6)
+            oprot.writeBool(self.deleteCell)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class DiskUsage(object):
+    """
+    Attributes:
+     - tables
+     - usage
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.LIST, 'tables', (TType.STRING, 'UTF8', False), None, ),  # 1
+        (2, TType.I64, 'usage', None, None, ),  # 2
+    )
+
+    def __init__(self, tables=None, usage=None,):
+        self.tables = tables
+        self.usage = usage
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.tables = []
+                    (_etype3, _size0) = iprot.readListBegin()
+                    for _i4 in range(_size0):
+                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.tables.append(_elem5)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.usage = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('DiskUsage')
+        if self.tables is not None:
+            oprot.writeFieldBegin('tables', TType.LIST, 1)
+            oprot.writeListBegin(TType.STRING, len(self.tables))
+            for iter6 in self.tables:
+                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.usage is not None:
+            oprot.writeFieldBegin('usage', TType.I64, 2)
+            oprot.writeI64(self.usage)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class KeyValue(object):
+    """
+    Attributes:
+     - key
+     - value
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'key', (Key, Key.thrift_spec), None, ),  # 1
+        (2, TType.STRING, 'value', 'BINARY', None, ),  # 2
+    )
+
+    def __init__(self, key=None, value=None,):
+        self.key = key
+        self.value = value
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.key = Key()
+                    self.key.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.value = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('KeyValue')
+        if self.key is not None:
+            oprot.writeFieldBegin('key', TType.STRUCT, 1)
+            self.key.write(oprot)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 2)
+            oprot.writeBinary(self.value)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ScanResult(object):
+    """
+    Attributes:
+     - results
+     - more
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.LIST, 'results', (TType.STRUCT, (KeyValue, KeyValue.thrift_spec), False), None, ),  # 1
+        (2, TType.BOOL, 'more', None, None, ),  # 2
+    )
+
+    def __init__(self, results=None, more=None,):
+        self.results = results
+        self.more = more
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.results = []
+                    (_etype10, _size7) = iprot.readListBegin()
+                    for _i11 in range(_size7):
+                        _elem12 = KeyValue()
+                        _elem12.read(iprot)
+                        self.results.append(_elem12)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.BOOL:
+                    self.more = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ScanResult')
+        if self.results is not None:
+            oprot.writeFieldBegin('results', TType.LIST, 1)
+            oprot.writeListBegin(TType.STRUCT, len(self.results))
+            for iter13 in self.results:
+                iter13.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.more is not None:
+            oprot.writeFieldBegin('more', TType.BOOL, 2)
+            oprot.writeBool(self.more)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class Range(object):
+    """
+    Attributes:
+     - start
+     - startInclusive
+     - stop
+     - stopInclusive
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'start', (Key, Key.thrift_spec), None, ),  # 1
+        (2, TType.BOOL, 'startInclusive', None, None, ),  # 2
+        (3, TType.STRUCT, 'stop', (Key, Key.thrift_spec), None, ),  # 3
+        (4, TType.BOOL, 'stopInclusive', None, None, ),  # 4
+    )
+
+    def __init__(self, start=None, startInclusive=None, stop=None, stopInclusive=None,):
+        self.start = start
+        self.startInclusive = startInclusive
+        self.stop = stop
+        self.stopInclusive = stopInclusive
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.start = Key()
+                    self.start.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.BOOL:
+                    self.startInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.stop = Key()
+                    self.stop.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.BOOL:
+                    self.stopInclusive = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Range')
+        if self.start is not None:
+            oprot.writeFieldBegin('start', TType.STRUCT, 1)
+            self.start.write(oprot)
+            oprot.writeFieldEnd()
+        if self.startInclusive is not None:
+            oprot.writeFieldBegin('startInclusive', TType.BOOL, 2)
+            oprot.writeBool(self.startInclusive)
+            oprot.writeFieldEnd()
+        if self.stop is not None:
+            oprot.writeFieldBegin('stop', TType.STRUCT, 3)
+            self.stop.write(oprot)
+            oprot.writeFieldEnd()
+        if self.stopInclusive is not None:
+            oprot.writeFieldBegin('stopInclusive', TType.BOOL, 4)
+            oprot.writeBool(self.stopInclusive)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ScanColumn(object):
+    """
+    Attributes:
+     - colFamily
+     - colQualifier
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'colFamily', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 2
+    )
+
+    def __init__(self, colFamily=None, colQualifier=None,):
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ScanColumn')
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 1)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class IteratorSetting(object):
+    """
+    Attributes:
+     - priority
+     - name
+     - iteratorClass
+     - properties
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.I32, 'priority', None, None, ),  # 1
+        (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'iteratorClass', 'UTF8', None, ),  # 3
+        (4, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
+    )
+
+    def __init__(self, priority=None, name=None, iteratorClass=None, properties=None,):
+        self.priority = priority
+        self.name = name
+        self.iteratorClass = iteratorClass
+        self.properties = properties
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I32:
+                    self.priority = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.iteratorClass = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.MAP:
+                    self.properties = {}
+                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
+                    for _i18 in range(_size14):
+                        _key19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val20 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.properties[_key19] = _val20
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('IteratorSetting')
+        if self.priority is not None:
+            oprot.writeFieldBegin('priority', TType.I32, 1)
+            oprot.writeI32(self.priority)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 2)
+            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldEnd()
+        if self.iteratorClass is not None:
+            oprot.writeFieldBegin('iteratorClass', TType.STRING, 3)
+            oprot.writeString(self.iteratorClass.encode('utf-8') if sys.version_info[0] == 2 else self.iteratorClass)
+            oprot.writeFieldEnd()
+        if self.properties is not None:
+            oprot.writeFieldBegin('properties', TType.MAP, 4)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
+            for kiter21, viter22 in list(self.properties.items()):
+                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
+                oprot.writeString(viter22.encode('utf-8') if sys.version_info[0] == 2 else viter22)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ScanOptions(object):
+    """
+    Attributes:
+     - authorizations
+     - range
+     - columns
+     - iterators
+     - bufferSize
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 1
+        (2, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ),  # 2
+        (3, TType.LIST, 'columns', (TType.STRUCT, (ScanColumn, ScanColumn.thrift_spec), False), None, ),  # 3
+        (4, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 4
+        (5, TType.I32, 'bufferSize', None, None, ),  # 5
+    )
+
+    def __init__(self, authorizations=None, range=None, columns=None, iterators=None, bufferSize=None,):
+        self.authorizations = authorizations
+        self.range = range
+        self.columns = columns
+        self.iterators = iterators
+        self.bufferSize = bufferSize
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype26, _size23) = iprot.readSetBegin()
+                    for _i27 in range(_size23):
+                        _elem28 = iprot.readBinary()
+                        self.authorizations.add(_elem28)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.range = Range()
+                    self.range.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.columns = []
+                    (_etype32, _size29) = iprot.readListBegin()
+                    for _i33 in range(_size29):
+                        _elem34 = ScanColumn()
+                        _elem34.read(iprot)
+                        self.columns.append(_elem34)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype38, _size35) = iprot.readListBegin()
+                    for _i39 in range(_size35):
+                        _elem40 = IteratorSetting()
+                        _elem40.read(iprot)
+                        self.iterators.append(_elem40)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.bufferSize = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ScanOptions')
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 1)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter41 in self.authorizations:
+                oprot.writeBinary(iter41)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.range is not None:
+            oprot.writeFieldBegin('range', TType.STRUCT, 2)
+            self.range.write(oprot)
+            oprot.writeFieldEnd()
+        if self.columns is not None:
+            oprot.writeFieldBegin('columns', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.columns))
+            for iter42 in self.columns:
+                iter42.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 4)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter43 in self.iterators:
+                iter43.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.bufferSize is not None:
+            oprot.writeFieldBegin('bufferSize', TType.I32, 5)
+            oprot.writeI32(self.bufferSize)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class BatchScanOptions(object):
+    """
+    Attributes:
+     - authorizations
+     - ranges
+     - columns
+     - iterators
+     - threads
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 1
+        (2, TType.LIST, 'ranges', (TType.STRUCT, (Range, Range.thrift_spec), False), None, ),  # 2
+        (3, TType.LIST, 'columns', (TType.STRUCT, (ScanColumn, ScanColumn.thrift_spec), False), None, ),  # 3
+        (4, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 4
+        (5, TType.I32, 'threads', None, None, ),  # 5
+    )
+
+    def __init__(self, authorizations=None, ranges=None, columns=None, iterators=None, threads=None,):
+        self.authorizations = authorizations
+        self.ranges = ranges
+        self.columns = columns
+        self.iterators = iterators
+        self.threads = threads
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype47, _size44) = iprot.readSetBegin()
+                    for _i48 in range(_size44):
+                        _elem49 = iprot.readBinary()
+                        self.authorizations.add(_elem49)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.LIST:
+                    self.ranges = []
+                    (_etype53, _size50) = iprot.readListBegin()
+                    for _i54 in range(_size50):
+                        _elem55 = Range()
+                        _elem55.read(iprot)
+                        self.ranges.append(_elem55)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.columns = []
+                    (_etype59, _size56) = iprot.readListBegin()
+                    for _i60 in range(_size56):
+                        _elem61 = ScanColumn()
+                        _elem61.read(iprot)
+                        self.columns.append(_elem61)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype65, _size62) = iprot.readListBegin()
+                    for _i66 in range(_size62):
+                        _elem67 = IteratorSetting()
+                        _elem67.read(iprot)
+                        self.iterators.append(_elem67)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.threads = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('BatchScanOptions')
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 1)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter68 in self.authorizations:
+                oprot.writeBinary(iter68)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.ranges is not None:
+            oprot.writeFieldBegin('ranges', TType.LIST, 2)
+            oprot.writeListBegin(TType.STRUCT, len(self.ranges))
+            for iter69 in self.ranges:
+                iter69.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.columns is not None:
+            oprot.writeFieldBegin('columns', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.columns))
+            for iter70 in self.columns:
+                iter70.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 4)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter71 in self.iterators:
+                iter71.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.threads is not None:
+            oprot.writeFieldBegin('threads', TType.I32, 5)
+            oprot.writeI32(self.threads)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class KeyValueAndPeek(object):
+    """
+    Attributes:
+     - keyValue
+     - hasNext
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'keyValue', (KeyValue, KeyValue.thrift_spec), None, ),  # 1
+        (2, TType.BOOL, 'hasNext', None, None, ),  # 2
+    )
+
+    def __init__(self, keyValue=None, hasNext=None,):
+        self.keyValue = keyValue
+        self.hasNext = hasNext
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.keyValue = KeyValue()
+                    self.keyValue.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.BOOL:
+                    self.hasNext = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('KeyValueAndPeek')
+        if self.keyValue is not None:
+            oprot.writeFieldBegin('keyValue', TType.STRUCT, 1)
+            self.keyValue.write(oprot)
+            oprot.writeFieldEnd()
+        if self.hasNext is not None:
+            oprot.writeFieldBegin('hasNext', TType.BOOL, 2)
+            oprot.writeBool(self.hasNext)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class KeyExtent(object):
+    """
+    Attributes:
+     - tableId
+     - endRow
+     - prevEndRow
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'tableId', 'UTF8', None, ),  # 1
+        (2, TType.STRING, 'endRow', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'prevEndRow', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, tableId=None, endRow=None, prevEndRow=None,):
+        self.tableId = tableId
+        self.endRow = endRow
+        self.prevEndRow = prevEndRow
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.tableId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.endRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.prevEndRow = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('KeyExtent')
+        if self.tableId is not None:
+            oprot.writeFieldBegin('tableId', TType.STRING, 1)
+            oprot.writeString(self.tableId.encode('utf-8') if sys.version_info[0] == 2 else self.tableId)
+            oprot.writeFieldEnd()
+        if self.endRow is not None:
+            oprot.writeFieldBegin('endRow', TType.STRING, 2)
+            oprot.writeBinary(self.endRow)
+            oprot.writeFieldEnd()
+        if self.prevEndRow is not None:
+            oprot.writeFieldBegin('prevEndRow', TType.STRING, 3)
+            oprot.writeBinary(self.prevEndRow)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class Column(object):
+    """
+    Attributes:
+     - colFamily
+     - colQualifier
+     - colVisibility
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'colFamily', 'BINARY', None, ),  # 1
+        (2, TType.STRING, 'colQualifier', 'BINARY', None, ),  # 2
+        (3, TType.STRING, 'colVisibility', 'BINARY', None, ),  # 3
+    )
+
+    def __init__(self, colFamily=None, colQualifier=None, colVisibility=None,):
+        self.colFamily = colFamily
+        self.colQualifier = colQualifier
+        self.colVisibility = colVisibility
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.colFamily = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.colQualifier = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.colVisibility = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Column')
+        if self.colFamily is not None:
+            oprot.writeFieldBegin('colFamily', TType.STRING, 1)
+            oprot.writeBinary(self.colFamily)
+            oprot.writeFieldEnd()
+        if self.colQualifier is not None:
+            oprot.writeFieldBegin('colQualifier', TType.STRING, 2)
+            oprot.writeBinary(self.colQualifier)
+            oprot.writeFieldEnd()
+        if self.colVisibility is not None:
+            oprot.writeFieldBegin('colVisibility', TType.STRING, 3)
+            oprot.writeBinary(self.colVisibility)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class Condition(object):
+    """
+    Attributes:
+     - column
+     - timestamp
+     - value
+     - iterators
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'column', (Column, Column.thrift_spec), None, ),  # 1
+        (2, TType.I64, 'timestamp', None, None, ),  # 2
+        (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
+        (4, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 4
+    )
+
+    def __init__(self, column=None, timestamp=None, value=None, iterators=None,):
+        self.column = column
+        self.timestamp = timestamp
+        self.value = value
+        self.iterators = iterators
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.column = Column()
+                    self.column.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.timestamp = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.value = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype75, _size72) = iprot.readListBegin()
+                    for _i76 in range(_size72):
+                        _elem77 = IteratorSetting()
+                        _elem77.read(iprot)
+                        self.iterators.append(_elem77)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('Condition')
+        if self.column is not None:
+            oprot.writeFieldBegin('column', TType.STRUCT, 1)
+            self.column.write(oprot)
+            oprot.writeFieldEnd()
+        if self.timestamp is not None:
+            oprot.writeFieldBegin('timestamp', TType.I64, 2)
+            oprot.writeI64(self.timestamp)
+            oprot.writeFieldEnd()
+        if self.value is not None:
+            oprot.writeFieldBegin('value', TType.STRING, 3)
+            oprot.writeBinary(self.value)
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 4)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter78 in self.iterators:
+                iter78.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ConditionalUpdates(object):
+    """
+    Attributes:
+     - conditions
+     - updates
+    """
+
+    thrift_spec = (
+        None,  # 0
+        None,  # 1
+        (2, TType.LIST, 'conditions', (TType.STRUCT, (Condition, Condition.thrift_spec), False), None, ),  # 2
+        (3, TType.LIST, 'updates', (TType.STRUCT, (ColumnUpdate, ColumnUpdate.thrift_spec), False), None, ),  # 3
+    )
+
+    def __init__(self, conditions=None, updates=None,):
+        self.conditions = conditions
+        self.updates = updates
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 2:
+                if ftype == TType.LIST:
+                    self.conditions = []
+                    (_etype82, _size79) = iprot.readListBegin()
+                    for _i83 in range(_size79):
+                        _elem84 = Condition()
+                        _elem84.read(iprot)
+                        self.conditions.append(_elem84)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.updates = []
+                    (_etype88, _size85) = iprot.readListBegin()
+                    for _i89 in range(_size85):
+                        _elem90 = ColumnUpdate()
+                        _elem90.read(iprot)
+                        self.updates.append(_elem90)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ConditionalUpdates')
+        if self.conditions is not None:
+            oprot.writeFieldBegin('conditions', TType.LIST, 2)
+            oprot.writeListBegin(TType.STRUCT, len(self.conditions))
+            for iter91 in self.conditions:
+                iter91.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.updates is not None:
+            oprot.writeFieldBegin('updates', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.updates))
+            for iter92 in self.updates:
+                iter92.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ConditionalWriterOptions(object):
+    """
+    Attributes:
+     - maxMemory
+     - timeoutMs
+     - threads
+     - authorizations
+     - durability
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.I64, 'maxMemory', None, None, ),  # 1
+        (2, TType.I64, 'timeoutMs', None, None, ),  # 2
+        (3, TType.I32, 'threads', None, None, ),  # 3
+        (4, TType.SET, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 4
+        (5, TType.I32, 'durability', None, None, ),  # 5
+    )
+
+    def __init__(self, maxMemory=None, timeoutMs=None, threads=None, authorizations=None, durability=None,):
+        self.maxMemory = maxMemory
+        self.timeoutMs = timeoutMs
+        self.threads = threads
+        self.authorizations = authorizations
+        self.durability = durability
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.maxMemory = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.timeoutMs = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.threads = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.authorizations = set()
+                    (_etype96, _size93) = iprot.readSetBegin()
+                    for _i97 in range(_size93):
+                        _elem98 = iprot.readBinary()
+                        self.authorizations.add(_elem98)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.durability = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ConditionalWriterOptions')
+        if self.maxMemory is not None:
+            oprot.writeFieldBegin('maxMemory', TType.I64, 1)
+            oprot.writeI64(self.maxMemory)
+            oprot.writeFieldEnd()
+        if self.timeoutMs is not None:
+            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
+            oprot.writeI64(self.timeoutMs)
+            oprot.writeFieldEnd()
+        if self.threads is not None:
+            oprot.writeFieldBegin('threads', TType.I32, 3)
+            oprot.writeI32(self.threads)
+            oprot.writeFieldEnd()
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.SET, 4)
+            oprot.writeSetBegin(TType.STRING, len(self.authorizations))
+            for iter99 in self.authorizations:
+                oprot.writeBinary(iter99)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.durability is not None:
+            oprot.writeFieldBegin('durability', TType.I32, 5)
+            oprot.writeI32(self.durability)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ActiveScan(object):
+    """
+    Attributes:
+     - client
+     - user
+     - table
+     - age
+     - idleTime
+     - type
+     - state
+     - extent
+     - columns
+     - iterators
+     - authorizations
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'client', 'UTF8', None, ),  # 1
+        (2, TType.STRING, 'user', 'UTF8', None, ),  # 2
+        (3, TType.STRING, 'table', 'UTF8', None, ),  # 3
+        (4, TType.I64, 'age', None, None, ),  # 4
+        (5, TType.I64, 'idleTime', None, None, ),  # 5
+        (6, TType.I32, 'type', None, None, ),  # 6
+        (7, TType.I32, 'state', None, None, ),  # 7
+        (8, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ),  # 8
+        (9, TType.LIST, 'columns', (TType.STRUCT, (Column, Column.thrift_spec), False), None, ),  # 9
+        (10, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 10
+        (11, TType.LIST, 'authorizations', (TType.STRING, 'BINARY', False), None, ),  # 11
+    )
+
+    def __init__(self, client=None, user=None, table=None, age=None, idleTime=None, type=None, state=None, extent=None, columns=None, iterators=None, authorizations=None,):
+        self.client = client
+        self.user = user
+        self.table = table
+        self.age = age
+        self.idleTime = idleTime
+        self.type = type
+        self.state = state
+        self.extent = extent
+        self.columns = columns
+        self.iterators = iterators
+        self.authorizations = authorizations
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.client = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.user = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.table = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I64:
+                    self.age = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I64:
+                    self.idleTime = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.I32:
+                    self.type = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.I32:
+                    self.state = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.STRUCT:
+                    self.extent = KeyExtent()
+                    self.extent.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 9:
+                if ftype == TType.LIST:
+                    self.columns = []
+                    (_etype103, _size100) = iprot.readListBegin()
+                    for _i104 in range(_size100):
+                        _elem105 = Column()
+                        _elem105.read(iprot)
+                        self.columns.append(_elem105)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 10:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype109, _size106) = iprot.readListBegin()
+                    for _i110 in range(_size106):
+                        _elem111 = IteratorSetting()
+                        _elem111.read(iprot)
+                        self.iterators.append(_elem111)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 11:
+                if ftype == TType.LIST:
+                    self.authorizations = []
+                    (_etype115, _size112) = iprot.readListBegin()
+                    for _i116 in range(_size112):
+                        _elem117 = iprot.readBinary()
+                        self.authorizations.append(_elem117)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ActiveScan')
+        if self.client is not None:
+            oprot.writeFieldBegin('client', TType.STRING, 1)
+            oprot.writeString(self.client.encode('utf-8') if sys.version_info[0] == 2 else self.client)
+            oprot.writeFieldEnd()
+        if self.user is not None:
+            oprot.writeFieldBegin('user', TType.STRING, 2)
+            oprot.writeString(self.user.encode('utf-8') if sys.version_info[0] == 2 else self.user)
+            oprot.writeFieldEnd()
+        if self.table is not None:
+            oprot.writeFieldBegin('table', TType.STRING, 3)
+            oprot.writeString(self.table.encode('utf-8') if sys.version_info[0] == 2 else self.table)
+            oprot.writeFieldEnd()
+        if self.age is not None:
+            oprot.writeFieldBegin('age', TType.I64, 4)
+            oprot.writeI64(self.age)
+            oprot.writeFieldEnd()
+        if self.idleTime is not None:
+            oprot.writeFieldBegin('idleTime', TType.I64, 5)
+            oprot.writeI64(self.idleTime)
+            oprot.writeFieldEnd()
+        if self.type is not None:
+            oprot.writeFieldBegin('type', TType.I32, 6)
+            oprot.writeI32(self.type)
+            oprot.writeFieldEnd()
+        if self.state is not None:
+            oprot.writeFieldBegin('state', TType.I32, 7)
+            oprot.writeI32(self.state)
+            oprot.writeFieldEnd()
+        if self.extent is not None:
+            oprot.writeFieldBegin('extent', TType.STRUCT, 8)
+            self.extent.write(oprot)
+            oprot.writeFieldEnd()
+        if self.columns is not None:
+            oprot.writeFieldBegin('columns', TType.LIST, 9)
+            oprot.writeListBegin(TType.STRUCT, len(self.columns))
+            for iter118 in self.columns:
+                iter118.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 10)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter119 in self.iterators:
+                iter119.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.authorizations is not None:
+            oprot.writeFieldBegin('authorizations', TType.LIST, 11)
+            oprot.writeListBegin(TType.STRING, len(self.authorizations))
+            for iter120 in self.authorizations:
+                oprot.writeBinary(iter120)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class ActiveCompaction(object):
+    """
+    Attributes:
+     - extent
+     - age
+     - inputFiles
+     - outputFile
+     - type
+     - reason
+     - localityGroup
+     - entriesRead
+     - entriesWritten
+     - iterators
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRUCT, 'extent', (KeyExtent, KeyExtent.thrift_spec), None, ),  # 1
+        (2, TType.I64, 'age', None, None, ),  # 2
+        (3, TType.LIST, 'inputFiles', (TType.STRING, 'UTF8', False), None, ),  # 3
+        (4, TType.STRING, 'outputFile', 'UTF8', None, ),  # 4
+        (5, TType.I32, 'type', None, None, ),  # 5
+        (6, TType.I32, 'reason', None, None, ),  # 6
+        (7, TType.STRING, 'localityGroup', 'UTF8', None, ),  # 7
+        (8, TType.I64, 'entriesRead', None, None, ),  # 8
+        (9, TType.I64, 'entriesWritten', None, None, ),  # 9
+        (10, TType.LIST, 'iterators', (TType.STRUCT, (IteratorSetting, IteratorSetting.thrift_spec), False), None, ),  # 10
+    )
+
+    def __init__(self, extent=None, age=None, inputFiles=None, outputFile=None, type=None, reason=None, localityGroup=None, entriesRead=None, entriesWritten=None, iterators=None,):
+        self.extent = extent
+        self.age = age
+        self.inputFiles = inputFiles
+        self.outputFile = outputFile
+        self.type = type
+        self.reason = reason
+        self.localityGroup = localityGroup
+        self.entriesRead = entriesRead
+        self.entriesWritten = entriesWritten
+        self.iterators = iterators
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.extent = KeyExtent()
+                    self.extent.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.age = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.inputFiles = []
+                    (_etype124, _size121) = iprot.readListBegin()
+                    for _i125 in range(_size121):
+                        _elem126 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.inputFiles.append(_elem126)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.outputFile = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.type = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.I32:
+                    self.reason = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.STRING:
+                    self.localityGroup = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.I64:
+                    self.entriesRead = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 9:
+                if ftype == TType.I64:
+                    self.entriesWritten = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 10:
+                if ftype == TType.LIST:
+                    self.iterators = []
+                    (_etype130, _size127) = iprot.readListBegin()
+                    for _i131 in range(_size127):
+                        _elem132 = IteratorSetting()
+                        _elem132.read(iprot)
+                        self.iterators.append(_elem132)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('ActiveCompaction')
+        if self.extent is not None:
+            oprot.writeFieldBegin('extent', TType.STRUCT, 1)
+            self.extent.write(oprot)
+            oprot.writeFieldEnd()
+        if self.age is not None:
+            oprot.writeFieldBegin('age', TType.I64, 2)
+            oprot.writeI64(self.age)
+            oprot.writeFieldEnd()
+        if self.inputFiles is not None:
+            oprot.writeFieldBegin('inputFiles', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRING, len(self.inputFiles))
+            for iter133 in self.inputFiles:
+                oprot.writeString(iter133.encode('utf-8') if sys.version_info[0] == 2 else iter133)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.outputFile is not None:
+            oprot.writeFieldBegin('outputFile', TType.STRING, 4)
+            oprot.writeString(self.outputFile.encode('utf-8') if sys.version_info[0] == 2 else self.outputFile)
+            oprot.writeFieldEnd()
+        if self.type is not None:
+            oprot.writeFieldBegin('type', TType.I32, 5)
+            oprot.writeI32(self.type)
+            oprot.writeFieldEnd()
+        if self.reason is not None:
+            oprot.writeFieldBegin('reason', TType.I32, 6)
+            oprot.writeI32(self.reason)
+            oprot.writeFieldEnd()
+        if self.localityGroup is not None:
+            oprot.writeFieldBegin('localityGroup', TType.STRING, 7)
+            oprot.writeString(self.localityGroup.encode('utf-8') if sys.version_info[0] == 2 else self.localityGroup)
+            oprot.writeFieldEnd()
+        if self.entriesRead is not None:
+            oprot.writeFieldBegin('entriesRead', TType.I64, 8)
+            oprot.writeI64(self.entriesRead)
+            oprot.writeFieldEnd()
+        if self.entriesWritten is not None:
+            oprot.writeFieldBegin('entriesWritten', TType.I64, 9)
+            oprot.writeI64(self.entriesWritten)
+            oprot.writeFieldEnd()
+        if self.iterators is not None:
+            oprot.writeFieldBegin('iterators', TType.LIST, 10)
+            oprot.writeListBegin(TType.STRUCT, len(self.iterators))
+            for iter134 in self.iterators:
+                iter134.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class WriterOptions(object):
+    """
+    Attributes:
+     - maxMemory
+     - latencyMs
+     - timeoutMs
+     - threads
+     - durability
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.I64, 'maxMemory', None, None, ),  # 1
+        (2, TType.I64, 'latencyMs', None, None, ),  # 2
+        (3, TType.I64, 'timeoutMs', None, None, ),  # 3
+        (4, TType.I32, 'threads', None, None, ),  # 4
+        (5, TType.I32, 'durability', None, None, ),  # 5
+    )
+
+    def __init__(self, maxMemory=None, latencyMs=None, timeoutMs=None, threads=None, durability=None,):
+        self.maxMemory = maxMemory
+        self.latencyMs = latencyMs
+        self.timeoutMs = timeoutMs
+        self.threads = threads
+        self.durability = durability
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.maxMemory = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I64:
+                    self.latencyMs = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I64:
+                    self.timeoutMs = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I32:
+                    self.threads = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.I32:
+                    self.durability = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('WriterOptions')
+        if self.maxMemory is not None:
+            oprot.writeFieldBegin('maxMemory', TType.I64, 1)
+            oprot.writeI64(self.maxMemory)
+            oprot.writeFieldEnd()
+        if self.latencyMs is not None:
+            oprot.writeFieldBegin('latencyMs', TType.I64, 2)
+            oprot.writeI64(self.latencyMs)
+            oprot.writeFieldEnd()
+        if self.timeoutMs is not None:
+            oprot.writeFieldBegin('timeoutMs', TType.I64, 3)
+            oprot.writeI64(self.timeoutMs)
+            oprot.writeFieldEnd()
+        if self.threads is not None:
+            oprot.writeFieldBegin('threads', TType.I32, 4)
+            oprot.writeI32(self.threads)
+            oprot.writeFieldEnd()
+        if self.durability is not None:
+            oprot.writeFieldBegin('durability', TType.I32, 5)
+            oprot.writeI32(self.durability)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class CompactionStrategyConfig(object):
+    """
+    Attributes:
+     - className
+     - options
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'className', 'UTF8', None, ),  # 1
+        (2, TType.MAP, 'options', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
+    )
+
+    def __init__(self, className=None, options=None,):
+        self.className = className
+        self.options = options
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.className = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.options = {}
+                    (_ktype136, _vtype137, _size135) = iprot.readMapBegin()
+                    for _i139 in range(_size135):
+                        _key140 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        _val141 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                        self.options[_key140] = _val141
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('CompactionStrategyConfig')
+        if self.className is not None:
+            oprot.writeFieldBegin('className', TType.STRING, 1)
+            oprot.writeString(self.className.encode('utf-8') if sys.version_info[0] == 2 else self.className)
+            oprot.writeFieldEnd()
+        if self.options is not None:
+            oprot.writeFieldBegin('options', TType.MAP, 2)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.options))
+            for kiter142, viter143 in list(self.options.items()):
+                oprot.writeString(kiter142.encode('utf-8') if sys.version_info[0] == 2 else kiter142)
+                oprot.writeString(viter143.encode('utf-8') if sys.version_info[0] == 2 else viter143)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
 
 class UnknownScanner(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('UnknownScanner')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('UnknownScanner')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class UnknownWriter(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('UnknownWriter')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('UnknownWriter')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class NoMoreEntriesException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('NoMoreEntriesException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NoMoreEntriesException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class AccumuloException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('AccumuloException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('AccumuloException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class AccumuloSecurityException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('AccumuloSecurityException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('AccumuloSecurityException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class TableNotFoundException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('TableNotFoundException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('TableNotFoundException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __ne__(self, other):
+        return not (self == other)
 
-  def __ne__(self, other):
-    return not (self == other)
 
 class TableExistsException(TException):
-  """
-  Attributes:
-   - msg
-  """
-
-  thrift_spec = (
-    None, # 0
-    (1, TType.STRING, 'msg', None, None, ), # 1
-  )
-
-  def __init__(self, msg=None,):
-    self.msg = msg
-
-  def read(self, iprot):
-    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
-      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
-      return
-    iprot.readStructBegin()
-    while True:
-      (fname, ftype, fid) = iprot.readFieldBegin()
-      if ftype == TType.STOP:
-        break
-      if fid == 1:
-        if ftype == TType.STRING:
-          self.msg = iprot.readString();
-        else:
-          iprot.skip(ftype)
-      else:
-        iprot.skip(ftype)
-      iprot.readFieldEnd()
-    iprot.readStructEnd()
-
-  def write(self, oprot):
-    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
-      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
-      return
-    oprot.writeStructBegin('TableExistsException')
-    if self.msg is not None:
-      oprot.writeFieldBegin('msg', TType.STRING, 1)
-      oprot.writeString(self.msg)
-      oprot.writeFieldEnd()
-    oprot.writeFieldStop()
-    oprot.writeStructEnd()
-
-  def validate(self):
-    return
-
-
-  def __str__(self):
-    return repr(self)
-
-  def __repr__(self):
-    L = ['%s=%r' % (key, value)
-      for key, value in self.__dict__.iteritems()]
-    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('TableExistsException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class MutationsRejectedException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('MutationsRejectedException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class NamespaceExistsException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NamespaceExistsException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class NamespaceNotFoundException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NamespaceNotFoundException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+
+class NamespaceNotEmptyException(TException):
+    """
+    Attributes:
+     - msg
+    """
+
+    thrift_spec = (
+        None,  # 0
+        (1, TType.STRING, 'msg', 'UTF8', None, ),  # 1
+    )
+
+    def __init__(self, msg=None,):
+        self.msg = msg
+
+    def read(self, iprot):
+        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
+            return
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.msg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        if oprot._fast_encode is not None and self.thrift_spec is not None:
+            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
+            return
+        oprot.writeStructBegin('NamespaceNotEmptyException')
+        if self.msg is not None:
+            oprot.writeFieldBegin('msg', TType.STRING, 1)
+            oprot.writeString(self.msg.encode('utf-8') if sys.version_info[0] == 2 else self.msg)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+             for key, value in list(self.__dict__.items())]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
 
-  def __eq__(self, other):
-    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
-  def __ne__(self, other):
-    return not (self == other)
+    def __ne__(self, other):
+        return not (self == other)
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/RELEASE-VERSION pyaccumulo-new/RELEASE-VERSION
--- pyaccumulo/RELEASE-VERSION	1970-01-01 00:00:00.000000000 +0000
+++ pyaccumulo-new/RELEASE-VERSION	2017-03-15 22:29:03.102584651 +0000
@@ -0,0 +1 @@
+1.5.0.10.dev7,g8adc
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/setup.py pyaccumulo-new/setup.py
--- pyaccumulo/setup.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/setup.py	2017-03-15 22:31:52.214584651 +0000
@@ -32,14 +32,14 @@
             if status:
                 raise RuntimeError("RPM build failed")
 
-            print ""
-            print "RPM built"
+            print("")
+            print("RPM built")
         else:
-            print """
+            print("""
 `setup.py rpm` is not supported for this version of Python.
 
 Please ask in the user forums for help.
-"""
+""")
 
 class doc(Command):
     description = "generate or test documentation"
@@ -72,15 +72,15 @@
             if status:
                 raise RuntimeError("documentation step '%s' failed" % mode)
 
-            print ""
-            print "Documentation step '%s' performed, results here:" % mode
-            print "   %s/" % path
+            print("")
+            print("Documentation step '%s' performed, results here:" % mode)
+            print("   %s/" % path)
         else:
-            print """
+            print("""
 `setup.py doc` is not supported for this version of Python.
 
 Please ask in the user forums for help.
-"""
+""")
 
 class PyTest(Command):
     '''run py.test'''
@@ -108,7 +108,7 @@
         # reload sys.path for any new libraries installed
         import site
         site.main()
-        print sys.path
+        print(sys.path)
         # use pytest to run tests
         pytest = __import__('pytest')
         exitcode = pytest.main(['--cov', 'pyaccumulo', '--cov-report', 'term', '-vvs', 'tests'])
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/tests/test_core.py pyaccumulo-new/tests/test_core.py
--- pyaccumulo/tests/test_core.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/tests/test_core.py	2017-03-15 23:38:47.843403005 +0000
@@ -30,13 +30,13 @@
         return conn
 
     def test_get_scan_columns(self):
-        self.assertEquals(None, pyaccumulo._get_scan_columns([]))
-        self.assertEquals([ ScanColumn(colFamily="cf", colQualifier="cq") ], pyaccumulo._get_scan_columns([ ["cf", "cq"]]))
-        self.assertEquals([ ScanColumn(colFamily="cf", colQualifier="cq"), ScanColumn(colFamily="a") ], pyaccumulo._get_scan_columns([ ["cf", "cq"], ["a"]]))
+        self.assertEqual(None, pyaccumulo._get_scan_columns([]))
+        self.assertEqual([ ScanColumn(colFamily="cf", colQualifier="cq") ], pyaccumulo._get_scan_columns([ ["cf", "cq"]]))
+        self.assertEqual([ ScanColumn(colFamily="cf", colQualifier="cq"), ScanColumn(colFamily="a") ], pyaccumulo._get_scan_columns([ ["cf", "cq"], ["a"]]))
 
     def test_following_array(self):
-        self.assertEquals("test\0", pyaccumulo.following_array("test"))
-        self.assertEquals(None, pyaccumulo.following_array(None))
+        self.assertEqual("test\0", pyaccumulo.following_array("test"))
+        self.assertEqual(None, pyaccumulo.following_array(None))
 
     def test_list_tables(self):
         conn = self._get_mock_connection()
@@ -45,7 +45,7 @@
 
         res = conn.list_tables()
         conn.client.listTables.assert_called_with("Login")
-        self.assertEquals(set(["t1", "t2", "t3"]), set(res))
+        self.assertEqual(set(["t1", "t2", "t3"]), set(res))
 
 
     def test_table_exists(self):
@@ -55,7 +55,7 @@
 
         res = conn.table_exists("mytable")
         conn.client.tableExists.assert_called_with("Login", "mytable")
-        self.assertEquals(True, res)
+        self.assertEqual(True, res)
 
 
     def test_create_table(self):
@@ -86,10 +86,10 @@
 
         res = conn._get_range(r)
         r.to_range.assert_called_with()
-        self.assertEquals("xyz", res)
+        self.assertEqual("xyz", res)
 
         res = conn._get_range(None)
-        self.assertEquals(None, res)
+        self.assertEqual(None, res)
 
     def test_get_ranges(self):
         conn = Accumulo(_connect=False)
@@ -99,10 +99,10 @@
 
         res = conn._get_ranges([r])
         r.to_range.assert_called_with()
-        self.assertEquals(["xyz"], res)
+        self.assertEqual(["xyz"], res)
 
         res = conn._get_ranges(None)
-        self.assertEquals(None, res)
+        self.assertEqual(None, res)
 
     def test_write(self):
         conn = Accumulo(_connect=False)
@@ -134,16 +134,16 @@
         conn = Accumulo(_connect=False)
 
         res = conn._get_iterator_settings(None)
-        self.assertEquals(None, res)
+        self.assertEqual(None, res)
 
     def test_process_iterator(self):
         conn = Accumulo(_connect=False)
 
         res = conn._process_iterator(IteratorSetting(name="i1"))
-        self.assertEquals(IteratorSetting(name="i1"), res)
+        self.assertEqual(IteratorSetting(name="i1"), res)
 
         res = conn._process_iterator(BaseIterator(name="n1", priority=21, classname="c1"))
-        self.assertEquals(IteratorSetting(priority=21, iteratorClass='c1', name='n1', properties={}), res)
+        self.assertEqual(IteratorSetting(priority=21, iteratorClass='c1', name='n1', properties={}), res)
 
         with self.assertRaises(Exception):
             conn._process_iterator("not an iterator")
@@ -172,11 +172,11 @@
 
     def test_following_key(self):
         conn = self._get_mock_connection()
-        key = Key(row="aabbcc", colFamily="cf", colQualifier="cq")
+        key = Key(timestamp=None, row="aabbcc", colFamily="cf", colQualifier="cq")
         conn.client.getFollowing = Mock(return_value=following_key(key))
         fkey = conn.following_key(key, PartialKey.ROW_COLFAM_COLQUAL_COLVIS)
         conn.client.getFollowing.assert_called_with(key, PartialKey.ROW_COLFAM_COLQUAL_COLVIS)
-        self.assertEqual(fkey, Key(row="aabbcc", colFamily="cf", colQualifier="cq\0"))
+        self.assertEqual(fkey, Key(timestamp=None, row="aabbcc", colFamily="cf", colQualifier="cq\0"))
 
     def test_get_max_row(self):
         conn = self._get_mock_connection()
@@ -296,73 +296,111 @@
 
         r = Range(srow=None, erow=None)
         rng = r.to_range()
-        self.assertEquals(None, rng.start)
-        self.assertEquals(None, rng.stop)
+        self.assertEqual(None, rng.start)
+        self.assertEqual(None, rng.stop)
 
         r = Range(srow="r01", erow="r02")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01"), rng.start)
-        self.assertEquals(Key(row="r02\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02\0"), rng.stop)
 
         r = Range(erow="r02", einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r02"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r02"), rng.stop)
 
         r = Range(srow="r01", sinclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r01\0"), rng.start)
 
         r = Range(srow="r01", scf="cf1", erow="r02", ecf="cf2")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2\0"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2\0"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", scv="xy", ecv="zx")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx\0"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx\0"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", sts=100, ets=101, scv="xy", ecv="zx")
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=100, colVisibility="xy"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=100, colVisibility="zx"), rng.stop)
+        self.assertEqual(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=100, colVisibility="xy"), rng.start)
+        self.assertEqual(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=100, colVisibility="zx"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", erow="r02", ecf="cf2", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1\0"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1\0"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", scv="xy", ecv="zx", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy\0"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx"), rng.stop)
+        self.assertEqual(Key(timestamp=None, row="r01", colFamily="cf1", colQualifier="cq1", colVisibility="xy\0"), rng.start)
+        self.assertEqual(Key(timestamp=None, row="r02", colFamily="cf2", colQualifier="cq2", colVisibility="zx"), rng.stop)
 
         r = Range(srow="r01", scf="cf1", scq="cq1", erow="r02", ecf="cf2", ecq="cq2", sts=100, ets=101, scv="xy", ecv="zx", sinclude=False, einclude=False)
         rng = r.to_range()
-        self.assertEquals(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=99, colVisibility="xy"), rng.start)
-        self.assertEquals(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=101, colVisibility="zx"), rng.stop)
+        self.assertEqual(Key(row="r01", colFamily="cf1", colQualifier="cq1", timestamp=99, colVisibility="xy"), rng.start)
+        self.assertEqual(Key(row="r02", colFamily="cf2", colQualifier="cq2", timestamp=101, colVisibility="zx"), rng.stop)
+
+    def test_followingPrefix(self):
+        self.assertIsNone(Range.followingPrefix(b''))
+
+        self.assertIsNone(Range.followingPrefix(b'\xff'))
+
+        self.assertEqual(b'\xff',  Range.followingPrefix(b'\xfe'))
+
+        self.assertEqual(b'\x44\xff\xfe\x08',
+            Range.followingPrefix(b'\x44\xff\xfe\x07\xff\xff'))
+
+    def test_prefix(self):
+        r = Range.prefix(b'')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertIsNone(r.erow)
+
+        r = Range.prefix(b'\xff')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'\xff', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertIsNone(r.erow)
+
+        r = Range.prefix(b'\xfe')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'\xfe', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertEqual(b'\xff', r.erow)
+        self.assertFalse(r.einclude)
+
+        r = Range.prefix(b'\x44\xff\xfe\x07\xff\xff')
+        self.assertIsInstance(r, Range)
+        self.assertEqual(b'\x44\xff\xfe\x07\xff\xff', r.srow)
+        self.assertTrue(r.sinclude)
+        self.assertEqual(b'\x44\xff\xfe\x08', r.erow)
+        self.assertFalse(r.einclude)
+
 
 class MutationTest(unittest.TestCase):
     def test_mutation(self):
         m = Mutation("row1")
-        self.assertEquals("row1", m.row)
-        self.assertEquals([], m.updates)
+        self.assertEqual("row1", m.row)
+        self.assertEqual([], m.updates)
 
     def test_put(self):
         m = Mutation("row1")
-        self.assertEquals([], m.updates)
+        self.assertEqual([], m.updates)
         m.put(cf="cf1", cq="cq1", cv="xy", ts=101, val="myval")
-        self.assertEquals([ColumnUpdate(colFamily="cf1", colQualifier="cq1", colVisibility="xy", timestamp=101, value="myval", deleteCell=None)], m.updates)
+        self.assertEqual([ColumnUpdate(colFamily="cf1", colQualifier="cq1", colVisibility="xy", timestamp=101, value="myval", deleteCell=None)], m.updates)
 
         
 class BatchWriterTest(unittest.TestCase):
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/tests/test_iterator.py pyaccumulo-new/tests/test_iterator.py
--- pyaccumulo/tests/test_iterator.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/tests/test_iterator.py	2017-03-15 22:32:50.690584651 +0000
@@ -15,6 +15,8 @@
 # limitations under the License.
 
 import unittest
+import base64
+
 from mock import Mock
 from pyaccumulo.iterators import *
 from pyaccumulo.proxy.ttypes import IteratorSetting, IteratorScope
@@ -22,15 +24,15 @@
 class BaseIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = BaseIterator(name="test123", priority=111, classname="com.test.Class")
-        self.assertEquals("test123", i.name)
-        self.assertEquals(111, i.priority)
-        self.assertEquals("com.test.Class", i.classname)
+        self.assertEqual("test123", i.name)
+        self.assertEqual(111, i.priority)
+        self.assertEqual("com.test.Class", i.classname)
 
         a = i.get_iterator_setting()
-        self.assertEquals("test123", a.name)
-        self.assertEquals(111, a.priority)
-        self.assertEquals("com.test.Class", a.iteratorClass)
-        self.assertEquals({}, a.properties)
+        self.assertEqual("test123", a.name)
+        self.assertEqual(111, a.priority)
+        self.assertEqual("com.test.Class", a.iteratorClass)
+        self.assertEqual({}, a.properties)
 
     def test_attach(self):
         i = BaseIterator(name="test123", priority=111, classname="com.test.Class")
@@ -49,18 +51,18 @@
 class BaseCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = BaseCombiner(name="test123", priority=111, classname="com.test.Class", columns=[["a", "b"], ["z", "y"]], encoding_type="STRING")
-        self.assertEquals("test123", i.name)
-        self.assertEquals(111, i.priority)
-        self.assertEquals("com.test.Class", i.classname)
-        self.assertEquals([["a", "b"], ["z", "y"]], i.columns)
-        self.assertEquals(False, i.combine_all_columns)
-        self.assertEquals("STRING", i.encoding_type)
+        self.assertEqual("test123", i.name)
+        self.assertEqual(111, i.priority)
+        self.assertEqual("com.test.Class", i.classname)
+        self.assertEqual([["a", "b"], ["z", "y"]], i.columns)
+        self.assertEqual(False, i.combine_all_columns)
+        self.assertEqual("STRING", i.encoding_type)
 
         a = i.get_iterator_setting()
-        self.assertEquals("test123", a.name)
-        self.assertEquals(111, a.priority)
-        self.assertEquals("com.test.Class", a.iteratorClass)
-        self.assertEquals(
+        self.assertEqual("test123", a.name)
+        self.assertEqual(111, a.priority)
+        self.assertEqual("com.test.Class", a.iteratorClass)
+        self.assertEqual(
             {
                 "type":"STRING",
                 "all": "false",
@@ -69,47 +71,47 @@
             a.properties)
 
         i.add_column(colf="c")
-        self.assertEquals([["a", "b"], ["z", "y"], ["c"]], i.columns)
+        self.assertEqual([["a", "b"], ["z", "y"], ["c"]], i.columns)
         
         i.add_column(colf="c", colq="d")
-        self.assertEquals([["a", "b"], ["z", "y"], ["c"], ["c", "d"]], i.columns)
+        self.assertEqual([["a", "b"], ["z", "y"], ["c"], ["c", "d"]], i.columns)
 
 
     def test_encode_col(self):
         i = BaseCombiner(name="test123", priority=111, classname="com.test.Class")
-        self.assertEquals("a", i._encode_column( ["a"] ) )
-        self.assertEquals("a:b", i._encode_column( ["a", "b"] ) )
+        self.assertEqual("a", i._encode_column( ["a"] ) )
+        self.assertEqual("a:b", i._encode_column( ["a", "b"] ) )
 
 
 class SummingCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = SummingCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.SummingCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.SummingCombiner", i.classname)
 
 class SummingArrayCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = SummingArrayCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.SummingArrayCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.SummingArrayCombiner", i.classname)
 
 class MaxCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = MaxCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.MaxCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.MaxCombiner", i.classname)
 
 class MinCombinerTest(unittest.TestCase):
     def test_iterator(self):
         i = MinCombiner()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.MinCombiner", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.MinCombiner", i.classname)
 
 class GrepIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = GrepIterator(term="grep")
-        self.assertEquals("grep", i.term)
-        self.assertEquals(False, i.negate) 
-        self.assertEquals("org.apache.accumulo.core.iterators.user.GrepIterator", i.classname)
+        self.assertEqual("grep", i.term)
+        self.assertEqual(False, i.negate) 
+        self.assertEqual("org.apache.accumulo.core.iterators.user.GrepIterator", i.classname)
 
         a = i.get_iterator_setting()
-        self.assertEquals(
+        self.assertEqual(
             {
                 "term":"grep",
                 "negate": "false"
@@ -119,22 +121,22 @@
 class RowDeletingIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = RowDeletingIterator()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.RowDeletingIterator", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.RowDeletingIterator", i.classname)
 
 class RegExFilterTest(unittest.TestCase):
     def test_iterator(self):
         i = RegExFilter()
-        self.assertEquals("org.apache.accumulo.core.iterators.user.RegExFilter", i.classname)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.RegExFilter", i.classname)
 
         i = RegExFilter(row_regex="xyz", cf_regex="abc", cq_regex="def", val_regex="jkl", or_fields=True, match_substring=False)
-        self.assertEquals("xyz", i.row_regex)
-        self.assertEquals("abc", i.cf_regex)
-        self.assertEquals("def", i.cq_regex)
-        self.assertEquals("jkl", i.val_regex)
-        self.assertEquals(True, i.or_fields)
-        self.assertEquals(False, i.match_substring)
+        self.assertEqual("xyz", i.row_regex)
+        self.assertEqual("abc", i.cf_regex)
+        self.assertEqual("def", i.cq_regex)
+        self.assertEqual("jkl", i.val_regex)
+        self.assertEqual(True, i.or_fields)
+        self.assertEqual(False, i.match_substring)
 
-        self.assertEquals(
+        self.assertEqual(
             {
                 "rowRegex": "xyz",
                 "colfRegex": "abc",
@@ -148,25 +150,25 @@
 class IntersectingIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = IntersectingIterator(terms=["quick", "brown", "fox"], not_flags=[False, True, False])
-        self.assertEquals("org.apache.accumulo.core.iterators.user.IntersectingIterator", i.classname)
-        self.assertEquals(["quick", "brown", "fox"], i.terms)
-        self.assertEquals([False, True, False], i.not_flags)
-
-        self.assertEquals("\001", i._convert_flag(True))
-        self.assertEquals("\0", i._convert_flag(False))
-
-        self.assertEquals("\001\0\001".encode("base64"), i._encode_not_flags([True, False, True]))
-        self.assertEquals("\0\001\0".encode("base64"), i._encode_not_flags([False, True, False]))
-        self.assertEquals(None, i._encode_not_flags([]))
+        self.assertEqual("org.apache.accumulo.core.iterators.user.IntersectingIterator", i.classname)
+        self.assertEqual(["quick", "brown", "fox"], i.terms)
+        self.assertEqual([False, True, False], i.not_flags)
+
+        self.assertEqual("\001", i._convert_flag(True))
+        self.assertEqual("\0", i._convert_flag(False))
+
+        self.assertEqual(base64.b64encode(b"\001\0\001").decode("utf-8"), i._encode_not_flags([True, False, True]))
+        self.assertEqual(base64.b64encode(b"\0\001\0").decode("utf-8"), i._encode_not_flags([False, True, False]))
+        self.assertEqual(None, i._encode_not_flags([]))
 
-        self.assertEquals(
-            "quick".encode("base64") + "brown".encode("base64")+ "fox".encode("base64").rstrip("\n"), 
+        self.assertEqual(
+            base64.b64encode(b"quick").decode("utf-8") + base64.b64encode(b"brown").decode("utf-8")+ base64.b64encode(b"fox").decode("utf-8").rstrip("\n"), 
             i._encode_columns(["quick", "brown", "fox"]))
 
-        self.assertEquals( 
+        self.assertEqual( 
             {
-                "columnFamilies": "quick".encode("base64") + "brown".encode("base64")+ "fox".encode("base64").rstrip("\n"), 
-                "notFlag": "\0\001\0".encode("base64")
+                "columnFamilies": base64.b64encode(b"quick").decode("utf-8") + base64.b64encode(b"brown").decode("utf-8")+ base64.b64encode(b"fox").decode("utf-8").rstrip("\n"), 
+                "notFlag": base64.b64encode(b"\0\001\0").decode("utf-8")
             },
             i._get_iterator_properties()
         )
@@ -174,16 +176,16 @@
 class IndexedDocIteratorTest(unittest.TestCase):
     def test_iterator(self):
         i = IndexedDocIterator(terms=["quick", "brown", "fox"], not_flags=[False, True, False], index_colf="index", doc_colf="docs")
-        self.assertEquals("org.apache.accumulo.core.iterators.user.IndexedDocIterator", i.classname)
-        self.assertEquals(["quick", "brown", "fox"], i.terms)
-        self.assertEquals([False, True, False], i.not_flags)
-        self.assertEquals("index", i.index_colf)
-        self.assertEquals("docs", i.doc_colf)
+        self.assertEqual("org.apache.accumulo.core.iterators.user.IndexedDocIterator", i.classname)
+        self.assertEqual(["quick", "brown", "fox"], i.terms)
+        self.assertEqual([False, True, False], i.not_flags)
+        self.assertEqual("index", i.index_colf)
+        self.assertEqual("docs", i.doc_colf)
 
-        self.assertEquals( 
+        self.assertEqual( 
             {
-                "columnFamilies": "quick".encode("base64") + "brown".encode("base64")+ "fox".encode("base64").rstrip("\n"), 
-                "notFlag": "\0\001\0".encode("base64"),
+                "columnFamilies": base64.b64encode(b"quick").decode("utf-8") + base64.b64encode(b"brown").decode("utf-8")+ base64.b64encode(b"fox").decode("utf-8").rstrip("\n"), 
+                "notFlag": base64.b64encode(b"\0\001\0").decode("utf-8"),
                 "indexFamily": "index", 
                 "docFamily": "docs"
             },
diff -Naur '--exclude=*.bak' '--exclude=*.pyc' pyaccumulo/version.py pyaccumulo-new/version.py
--- pyaccumulo/version.py	2015-07-03 14:44:49.000000000 +0000
+++ pyaccumulo-new/version.py	2017-03-15 22:36:52.582584651 +0000
@@ -53,7 +53,7 @@
                   stdout=PIPE, stderr=PIPE, 
                   cwd=os.path.dirname(os.path.abspath(__file__)))
         p.stderr.close()
-        describe_line = p.stdout.readlines()[0].strip()
+        describe_line = p.stdout.readlines()[0].strip().decode('utf-8')
 
         p = Popen(['git', 'rev-parse', 'HEAD'],
                   stdout=PIPE, stderr=PIPE)
@@ -75,16 +75,16 @@
 
         return version, source_hash
  
-    except Exception, exc:
+    except Exception as exc:
         sys.stderr.write('line: %r\n' % line)
         sys.stderr.write(traceback.format_exc(exc))
         try:
             sys.stderr.write('p.stderr.read()=%s\n' % p.stderr.read())
-        except Exception, exc:
+        except Exception as exc:
             sys.stderr.write(traceback.format_exc(exc))
         try:
             sys.stderr.write('os.getcwd()=%s\n' % os.getcwd())
-        except Exception, exc:
+        except Exception as exc:
             sys.stderr.write(traceback.format_exc(exc))
         return None, None
  
@@ -145,4 +145,4 @@
  
  
 if __name__ == "__main__":
-    print get_git_version()
+    print(get_git_version())
